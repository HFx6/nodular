// export default [
// 	{
// 		width: 158,
// 		height: 188,
// 		id: "nodular_1699757014128",
// 		type: "Function",
// 		position: {
// 			x: -117.89806123717328,
// 			y: -19.872990030818073,
// 		},
// 		data: {
// 			label: "isinarray",
// 			lang: "node",
// 			loading: false,
// 			func: "function isinarray(i, a) {\n\tvar bool = a.includes(i);\n\treturn bool;\n}\n\nconst val = isinarray(input, array);\nconst newR = !isinarray(input, array);\nmodule.exports = { val, newR }",
// 			args: ["input", "array"],
// 			returnArgs: ["val", "newR"],
// 			funcedit: true,
// 			argTypes: [],
// 			returnType: "",
// 			argTypeColors: [],
// 			hasfunc: true,
// 			funceval: null,
// 		},
// 		selected: false,
// 		positionAbsolute: {
// 			x: -117.89806123717328,
// 			y: -19.872990030818073,
// 		},
// 		dragging: false,
// 	},
// 	{
// 		width: 158,
// 		height: 75,
// 		id: "nodular_1699757045106",
// 		type: "Bool",
// 		position: {
// 			x: 328.46624890846675,
// 			y: 92.35054683718982,
// 		},
// 		data: {
// 			label: "bool",
// 			func: "function yorno(value) {\n\treturn value;\n} const boolval = yorno(bool); module.exports = {nodular_1699757045106: boolval };",
// 			funcedit: true,
// 			funcnode: false,
// 			hasfunc: true,
// 			defaultNode: true,
// 			argTypes: ["Bolean"],
// 			returnArgs: [],
// 			argTypeColors: [
// 				{
// 					backgroundColor: "#3380bd",
// 				},
// 			],
// 			args: ["bool"],
// 			funceval: null,
// 		},
// 		selected: false,
// 		positionAbsolute: {
// 			x: 328.46624890846675,
// 			y: 92.35054683718982,
// 		},
// 		dragging: false,
// 	},
// 	{
// 		width: 158,
// 		height: 75,
// 		id: "nodular_new892345uh",
// 		type: "Bool",
// 		position: {
// 			x: 302.5176090689936,
// 			y: -73.53540070801365,
// 		},
// 		data: {
// 			label: "bool",
// 			func: "function yorno(value) {\n\treturn value;\n} const boolval = yorno(bool); module.exports = {nodular_new892345uh: boolval };",
// 			funcedit: true,
// 			funcnode: false,
// 			hasfunc: true,
// 			defaultNode: true,
// 			argTypes: ["Bolean"],
// 			returnArgs: [],
// 			argTypeColors: [
// 				{
// 					backgroundColor: "#3380bd",
// 				},
// 			],
// 			args: ["bool"],
// 			funceval: null,
// 		},
// 		selected: false,
// 		positionAbsolute: {
// 			x: 302.5176090689936,
// 			y: -73.53540070801365,
// 		},
// 		dragging: false,
// 	},
// 	{
// 		width: 158,
// 		height: 93,
// 		id: "nodular_1699757046394",
// 		type: "Input",
// 		position: {
// 			x: -576.9514418160303,
// 			y: -91.70646027754003,
// 		},
// 		data: {
// 			label: "input",
// 			defaultNode: true,
// 			args: [],
// 			returnArgs: ["input"],
// 			funcedit: true,
// 			hasfunc: false,
// 			returnType: "String",
// 			returnTypeColor: {
// 				backgroundColor: "#A0D468",
// 			},
// 			func: "const input = `yellow`;\n\nmodule.exports = {input }",
// 			funceval: "yellow",
// 		},
// 		selected: false,
// 		positionAbsolute: {
// 			x: -576.9514418160303,
// 			y: -91.70646027754003,
// 		},
// 		dragging: false,
// 	},
// 	{
// 		width: 158,
// 		height: 65,
// 		id: "nodular_1699757053462",
// 		type: "Array",
// 		position: {
// 			x: -583.4939003165633,
// 			y: 171.88858359761193,
// 		},
// 		data: {
// 			label: "array",
// 			func: 'function array() {\n\treturn [\n\t\t"yellow",\n\t\t"blue",\n\t\t"orange",\n\t\t"red"\n\t];\n}\nmodule.exports = { array: array() }',
// 			args: [],
// 			defaultNode: true,
// 			returnArgs: ["array"],
// 			funcedit: true,
// 			hasfunc: true,
// 			returnType: "String",
// 			returnTypeColor: {
// 				backgroundColor: "#A0D468",
// 			},
// 			funceval: [],
// 		},
// 		selected: false,
// 		positionAbsolute: {
// 			x: -583.4939003165633,
// 			y: 171.88858359761193,
// 		},
// 		dragging: false,
// 	},
// ];

export default [
	{
		width: 158,
		height: 75,
		id: "nodular_1699757045106",
		type: "Bool",
		position: {
			x: 1349.3658865466373,
			y: -655.8012771633202,
		},
		data: {
			label: "bool",
			returnArgs: [],
			func: "function yorno(value) {\n\treturn value;\n} const boolval = yorno(bool); module.exports = {nodular_1699757045106: boolval };",
			funcedit: true,
			funcnode: false,
			hasfunc: true,
			defaultNode: true,
			argTypes: ["Bolean"],
			argTypeColors: [
				{
					backgroundColor: "#3380bd",
				},
			],
			args: ["bool"],
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 1349.3658865466373,
			y: -655.8012771633202,
		},
		dragging: false,
	},
	{
		width: 326,
		height: 190,
		id: "nodular_1694151916161",
		type: "Canvas",
		position: {
			x: 284.3039344704731,
			y: -74.03049092202002,
		},
		data: {
			label: "canvas",
			returnArgs: ["canvas"],
			func: "const canvas = document.getElementById('nodular_1694151916161');\nconst canvas = _canvas.transferControlToOffscreen();\nmodule.exports = {canvas};",
			funcnode: false,
			canvasRef: null,
			args: [],
			funcedit: false,
			hasfunc: false,
			returnType: "",
			returnTypeColor: {
				backgroundColor: "#A0D468",
			},
			funceval: "",
		},
		positionAbsolute: {
			x: 284.3039344704731,
			y: -74.03049092202002,
		},
		selected: true,
		dragging: false,
	},
	{
		width: 158,
		height: 75,
		id: "nodular_1694680825239",
		type: "Function",
		position: {
			x: -744.8010038395778,
			y: -399.62660970981926,
		},
		data: {
			label: "Utility.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Utility"],
			loading: false,
			func: "function Utility() {\n\n}\n\n/**\n *\n */\nUtility.convertDecToHexString = function(num, width, noPrefix) {\n  var str = num.toString(16);\n\n  var prefix = '';\n\n  if(num < 0)\n    prefix += '-';\n\n  if(noPrefix !== true)\n    prefix += '0x';\n\n  if(width === undefined)\n    return prefix + str;\n\n  var base = '';\n\n  for(var i = 0; i < width; i++)\n    base += '0';\n\n  return prefix + (base + str).substr(-1 * width);\n};\n\n module.exports = {Utility};",
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -744.8010038395778,
			y: -399.62660970981926,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 239,
		id: "nodular_1694680837546",
		type: "Function",
		position: {
			x: 876.0398543126855,
			y: -871.5568184662401,
		},
		data: {
			label: "Nes.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Nes"],
			loading: false,
			func: "function Nes() {\n  this.ppu = new Ppu();\n  this.cpu = new Cpu();\n  this.apu = new Apu();\n  this.pad1 = new Joypad();\n  this.pad2 = new Joypad();\n\n  this.rom = null;  // set by .setRom()\n\n  //\n\n  this.cpu.setPpu(this.ppu);\n  this.cpu.setApu(this.apu);\n  this.cpu.setJoypad1(this.pad1);\n  this.cpu.setJoypad2(this.pad2);\n\n  this.ppu.setCpu(this.cpu);\n\n  this.apu.setCpu(this.cpu);\n\n  //\n\n  this.state = this.STATES.POWER_OFF;\n\n  //\n\n  this.audioEnabled = false;\n\n  // for requestAnimationFrame()\n\n  var self = this;\n  this.runFunc = function() { self.run(); };\n\n  // event listeners\n\n  this.onFpsUpdates = [];\n}\n\nObject.assign(Nes.prototype, {\n  isNes: true,\n\n  //\n\n  STATES: {\n    POWER_OFF: 0,\n    RUN: 1,\n    STOP: 2\n  },\n\n  KEY_TO_PAD_BUTTONS: {\n    13: Joypad.BUTTONS.START,   // enter\n    32: Joypad.BUTTONS.SELECT,  // space\n    37: Joypad.BUTTONS.LEFT,    // left arrow\n    38: Joypad.BUTTONS.UP,      // up arrow\n    39: Joypad.BUTTONS.RIGHT,   // right arrow\n    40: Joypad.BUTTONS.DOWN,    // down arrow\n    88: Joypad.BUTTONS.A,       // x\n    90: Joypad.BUTTONS.B        // z\n  },\n\n  // event listeners\n\n  /**\n   * Registered callbacks will be invoked when\n   *   'fps': FPS number is updated\n   */\n  addEventListener: function(type, func) {\n    switch(type) {\n      case 'fps':\n        this.onFpsUpdates.push(func);\n        break;\n\n      default:\n        throw new Error('Nes.addEventListener: unknown type ' + type);\n    }\n  },\n\n  invokeFpsUpdateListeners: function(fps) {\n    for(var i = 0, il = this.onFpsUpdates.length; i < il; i++) {\n      this.onFpsUpdates[i](fps);\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  setRom: function(rom) {\n    this.rom = rom;\n    this.cpu.setRom(rom);\n    this.ppu.setRom(rom);\n  },\n\n  /**\n   *\n   */\n  setDisplay: function(display) {\n    this.ppu.setDisplay(display);\n  },\n\n  /**\n   *\n   */\n  setAudio: function(audio) {\n    this.apu.setAudio(audio);\n    this.audioEnabled = true;\n  },\n\n  /**\n   *\n   */\n  bootup: function() {\n    this.cpu.bootup();\n    this.ppu.bootup();\n    this.apu.bootup();\n    this.state = this.STATES.RUN;\n  },\n\n  /**\n   *\n   */\n  reset: function() {\n    this.cpu.reset();\n    this.ppu.reset();\n    this.apu.reset();\n  },\n\n  /**\n   *\n   */\n  stop: function() {\n    this.state = this.STATES.STOP;\n  },\n\n  /**\n   *\n   */\n  resume: function() {\n    this.state = this.STATES.RUN;\n    this.run();\n  },\n\n  /**\n   *\n   */\n  run: function() {\n    this.measureFps();\n\n    var cycles = (341 * 262 / 3) | 0; // TODO: temporal\n    for(var i = 0; i < cycles; i++) {\n      this.runCycle();\n    }\n\n    if(this.state === this.STATES.RUN)\n      requestAnimationFrame(this.runFunc);\n  },\n\n  /**\n   *\n   */\n  runCycle: function() {\n    this.cpu.runCycle();\n    this.ppu.runCycle();\n    this.ppu.runCycle();\n    this.ppu.runCycle();\n\n    if(this.audioEnabled === true)\n      this.apu.runCycle();\n  },\n\n  /**\n   *\n   */\n  runStep: function() {\n    if(this.state !== this.STATES.STOP)\n      return;\n\n    do {\n      this.runCycle();\n    } while(this.cpu.isStall())\n  },\n\n  // key input handlers\n\n  handleKeyDown: function(e) {\n    if(this.KEY_TO_PAD_BUTTONS[e.keyCode] !== undefined)\n      this.pad1.pressButton(this.KEY_TO_PAD_BUTTONS[e.keyCode]);\n    e.preventDefault();\n  },\n\n  handleKeyUp: function(e) {\n    if(this.KEY_TO_PAD_BUTTONS[e.keyCode] !== undefined)\n      this.pad1.releaseButton(this.KEY_TO_PAD_BUTTONS[e.keyCode]);\n    e.preventDefault();\n  },\n\n  //\n\n  measureFps: function() {\n    var oldTime = null;\n    var frame = 0;\n\n    return function measureFps() {\n      if(frame === 60) {\n        var newTime = performance.now();\n\n        if (oldTime !== null)\n          this.invokeFpsUpdateListeners(60000 / (newTime - oldTime));\n\n        oldTime = newTime;\n        frame = 0;\n      }\n      frame++;\n    };\n  }(),\n\n  // dump methods\n\n  dumpCpu: function() {\n    return this.cpu.dump();\n  },\n\n  dumpRam: function() {\n    return this.cpu.dumpRAM();\n  },\n\n  dumpRom: function() {\n    var buffer = '';\n    buffer += this.rom.dumpHeader();\n    buffer += '\\n';\n    buffer += this.rom.dump();\n    buffer += '\\n';\n    buffer += this.cpu.disassembleROM();\n    buffer += '\\n';\n    return buffer;\n  },\n\n  dumpPpu: function() {\n    return this.ppu.dump();\n  },\n\n  dumpVRam: function() {\n    return this.ppu.dumpVRAM();\n  },\n\n  dumpSprRam: function() {\n    return this.ppu.dumpSPRRAM();\n  }\n});\n\n module.exports = {Nes};",
			args: ["Cpu", "Ppu", "Apu", "Joypad"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 876.0398543126855,
			y: -871.5568184662401,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 239,
		id: "nodular_1694680838398",
		type: "Function",
		position: {
			x: 676.4525044547365,
			y: -581.9501828551445,
		},
		data: {
			label: "Rom.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Rom"],
			loading: false,
			func: "\n\n\n/**\n * Expects NES ROM arraybuffer consists of the three segments\n * in the following order.\n *   - Header (16bytes)\n *   - Program ROM data(Program ROM banks num * 0x4000 bytes)\n *   - Character ROM data(Character ROM banks num * 0x2000 bytes)\n */\nfunction Rom(arrayBuffer) {\n\tMemory.call(this, arrayBuffer);\n\tthis.header = new RomHeader(this);\n\n\tif (this.isNes() === false)\n\t\tthrow new Error('This rom doesn\\'t seem iNES format.');\n\n\tthis.mapper = (new MapperFactory()).create(this.header.getMapperNum(), this);\n}\n\n//\n\nRom.MIRRORINGS = {\n\tSINGLE_SCREEN: 0,\n\tHORIZONTAL: 1,\n\tVERTICAL: 2,\n\tFOUR_SCREEN: 3\n};\n\n//\n\nRom.prototype = Object.assign(Object.create(Memory.prototype), {\n\tisRom: true,\n\n\t//\n\n\tMIRRORINGS: Rom.MIRRORINGS,\n\n\t// load/store methods called by CPU.\n\n\t/**\n\t * CPU memory address:\n\t * 0x0000 - 0x1FFF: Character ROM access\n\t * 0x8000 - 0xFFFF: Program ROM access\n\t *\n\t * To access wide range ROM data with limited CPU memory address space\n\t * Mapper maps CPU memory address to ROM's.\n\t * In general writing control registers in Mapper via .store() switches bank.\n\t */\n\tload: function(address) {\n\t\tvar addressInRom = this.getHeaderSize();\n\n\t\tif (address < 0x2000) {\n\n\t\t\t// Character ROM access\n\n\t\t\taddressInRom += this.header.getPRGROMBanksNum() * 0x4000;\n\t\t\taddressInRom += this.mapper.mapForChrRom(address);\n\t\t} else {\n\n\t\t\t// Program ROM access\n\n\t\t\taddressInRom += this.mapper.map(address);\n\t\t}\n\n\t\treturn this.data[addressInRom];\n\t},\n\n\t/**\n\t * In general writing with ROM address space updates control registers in Mapper.\n\t */\n\tstore: function(address, value) {\n\t\tthis.mapper.store(address, value);\n\t},\n\n\t//\n\n\t/**\n\t *\n\t */\n\tisNes: function() {\n\t\treturn this.header.isNes();\n\t},\n\n\t/**\n\t *\n\t */\n\tgetHeaderSize: function() {\n\t\treturn this.header.getSize();\n\t},\n\n\t/**\n\t *\n\t */\n\thasChrRom: function() {\n\t\treturn this.header.hasChrRom();\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMirroringType: function() {\n\t\treturn this.mapper.getMirroringType();\n\t},\n\n\t// dump methods\n\n\t/**\n\t *\n\t */\n\tdumpHeader: function() {\n\t\treturn this.header.dump();\n\t},\n\n\t/**\n\t *\n\t */\n\t_getStartDumpAddress: function() {\n\t\treturn this.getHeaderSize();\n\t},\n\n\t/**\n\t *\n\t */\n\t_getEndDumpAddress: function() {\n\t\treturn this.getCapacity();\n\t}\n});\n\n/**\n *\n */\nfunction RomHeader(rom) {\n\tthis.rom = rom;\n}\n\nObject.assign(RomHeader.prototype, {\n\tisRomHeader: true,\n\n\tsize: 16, // 16bytes\n\n\t//\n\n\tVALID_SIGNATURE: 'NES',\n\tVALID_MAGIC_NUMBER: 0x1a,\n\n\t//\n\n\tSIGNATURE_ADDRESS: 0,\n\tSIGNATURE_SIZE: 3,\n\n\tMAGIC_NUMBER_ADDRESS: 3,\n\tMAGIC_NUMBER_SIZE: 1,\n\n\tPRG_ROM_BANKS_NUM_ADDRESS: 4,\n\tPRG_ROM_BANKS_NUM_SIZE: 1,\n\n\tCHR_ROM_BANKS_NUM_ADDRESS: 5,\n\tCHR_ROM_BANKS_NUM_SIZE: 1,\n\n\tCONTROL_BYTE1_ADDRESS: 6,\n\tCONTROL_BYTE1_SIZE: 1,\n\n\tCONTROL_BYTE2_ADDRESS: 7,\n\tCONTROL_BYTE2_SIZE: 1,\n\n\tRAM_BANKS_NUM_ADDRESS: 8,\n\tRAM_BANKS_NUM_SIZE: 1,\n\n\tUNUSED_ADDRESS: 9,\n\tUNUSED_SIZE: 7,\n\n\t//\n\n\tMIRRORING_TYPE_BIT: 0,\n\tMIRRORING_TYPE_BITS_WIDTH: 1,\n\tMIRRORING_TYPE_HORIZONTAL: 0,\n\tMIRRORING_TYPE_VERTICAL: 1,\n\n\tBATTERY_BACKED_RAM_BIT: 1,\n\tBATTERY_BACKED_RAM_BITS_WIDTH: 1,\n\n\tTRAINER_512BYTES_BIT: 2,\n\tTRAINER_512BYTES_BITS_WIDTH: 1,\n\n\tFOUR_SCREEN_MIRRORING_BIT: 3,\n\tFOUR_SCREEN_MIRRORING_BITS_WIDTH: 1,\n\n\tMAPPER_LOWER_BIT: 4,\n\tMAPPER_LOWER_BITS_WIDTH: 4,\n\n\tMAPPER_HIGHER_BIT: 4,\n\tMAPPER_HIGHER_BITS_WIDTH: 4,\n\n\t//\n\n\t/**\n\t *\n\t */\n\tgetSize: function() {\n\t\treturn this.size;\n\t},\n\n\t/**\n\t *\n\t */\n\tisNes: function() {\n\t\tif (this.getSignature() !== this.VALID_SIGNATURE)\n\t\t\treturn false;\n\n\t\tif (this.getMagicNumber() !== this.VALID_MAGIC_NUMBER)\n\t\t\treturn false;\n\n\t\treturn true;\n\t},\n\n\t//\n\n\t/**\n\t *\n\t */\n\tload: function(address) {\n\t\treturn this.rom.loadWithoutMapping(address);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetSignature: function() {\n\t\tvar str = '';\n\n\t\tfor (var i = 0; i < this.SIGNATURE_SIZE; i++)\n\t\t\tstr += String.fromCharCode(this.load(this.SIGNATURE_ADDRESS + i));\n\n\t\treturn str;\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMagicNumber: function() {\n\t\treturn this.load(this.MAGIC_NUMBER_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetPRGROMBanksNum: function() {\n\t\treturn this.load(this.PRG_ROM_BANKS_NUM_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetCHRROMBanksNum: function() {\n\t\treturn this.load(this.CHR_ROM_BANKS_NUM_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\thasChrRom: function() {\n\t\treturn this.getCHRROMBanksNum() > 0;\n\t},\n\n\t/**\n\t *\n\t */\n\tgetControlByte1: function() {\n\t\treturn this.load(this.CONTROL_BYTE1_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetControlByte2: function() {\n\t\treturn this.load(this.CONTROL_BYTE2_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetRAMBanksNum: function() {\n\t\treturn this.load(this.RAM_BANKS_NUM_ADDRESS);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetUnusedField: function() {\n\t\tvar value = 0;\n\n\t\tfor (var i = 0; i < this.UNUSED_SIZE; i++)\n\t\t\tvalue = (value << 8) | this.load(this.UNUSED_ADDRESS + i);\n\n\t\treturn value;\n\t},\n\n\t//\n\n\t/**\n\t *\n\t */\n\textractBits: function(value, offset, size) {\n\t\treturn (value >> offset) & ((1 << size) - 1);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMirroringType: function() {\n\t\treturn this.extractBits(this.getControlByte1(),\n\t\t\tthis.MIRRORING_TYPE_BIT, this.MIRRORING_TYPE_BITS_WIDTH);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMirroringTypeAsStrings: function() {\n\t\treturn (this.getMirroringType() === this.MIRRORING_TYPE_HORIZONTAL) ?\n\t\t\t'horizontal' : 'vertical';\n\t},\n\n\t/**\n\t *\n\t */\n\tisHorizontalMirroring: function() {\n\t\treturn this.getMirroringType() === this.MIRRORING_TYPE_HORIZONTAL;\n\t},\n\n\t/**\n\t *\n\t */\n\tgetBatteryBackedRAM: function() {\n\t\treturn this.extractBits(this.getControlByte1(),\n\t\t\tthis.BATTERY_BACKED_RAM_BIT, this.BATTERY_BACKED_RAM_BITS_WIDTH);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetTrainer512Bytes: function() {\n\t\treturn this.extractBits(this.getControlByte1(),\n\t\t\tthis.TRAINER_512BYTES_BIT, this.TRAINER_512BYTES_BITS_WIDTH);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetFourScreenMirroring: function() {\n\t\treturn this.extractBits(this.getControlByte1(),\n\t\t\tthis.FOUR_SCREEN_MIRRORING_BIT, this.FOUR_SCREEN_MIRRORING_BITS_WIDTH);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMapperNum: function() {\n\t\tvar lowerBits = this.extractBits(this.getControlByte1(),\n\t\t\tthis.MAPPER_LOWER_BIT, this.MAPPER_LOWER_BITS_WIDTH);\n\t\tvar higherBits = this.extractBits(this.getControlByte2(),\n\t\t\tthis.MAPPER_HIGHER_BIT, this.MAPPER_HIGHER_BITS_WIDTH);\n\t\treturn (higherBits << this.MAPPER_LOWER_BITS_WIDTH) | lowerBits;\n\t},\n\n\t/**\n\t *\n\t */\n\tdump: function() {\n\t\tvar buffer = '';\n\n\t\tbuffer += '0x ';\n\t\tfor (var i = 0; i < this.getSize(); i++) {\n\t\t\tbuffer += Utility.convertDecToHexString(this.load(i), 2, true) + ' ';\n\t\t}\n\t\tbuffer += '\\n\\n';\n\n\t\tbuffer += 'Signature: ' + this.getSignature() + '\\n';\n\t\tbuffer += 'Magic Number: ' + Utility.convertDecToHexString(this.getMagicNumber(), 2) + '\\n';\n\t\tbuffer += 'PRG-ROM banks num: ' +\n\t\t\tUtility.convertDecToHexString(this.getPRGROMBanksNum(), 2) + '\\n';\n\t\tbuffer += 'CHR-ROM banks num: ' +\n\t\t\tUtility.convertDecToHexString(this.getCHRROMBanksNum(), 2) + '\\n';\n\t\tbuffer += 'Control1: ' + Utility.convertDecToHexString(this.getControlByte1(), 2) + '\\n';\n\t\tbuffer += 'Control2: ' + Utility.convertDecToHexString(this.getControlByte2(), 2) + '\\n';\n\t\tbuffer += 'RAM banks num: ' + Utility.convertDecToHexString(this.getRAMBanksNum(), 2) + '\\n';\n\t\tbuffer += 'Unused field: ' + Utility.convertDecToHexString(this.getUnusedField(), 14) + '\\n';\n\t\tbuffer += '\\n';\n\t\tbuffer += 'In control bytes\\n';\n\t\tbuffer += 'Mirroring type: ' + Utility.convertDecToHexString(this.getMirroringType()) +\n\t\t\t'(' + this.getMirroringTypeAsStrings() + ')\\n';\n\t\tbuffer += 'Battery-backed RAM: ' +\n\t\t\tUtility.convertDecToHexString(this.getBatteryBackedRAM()) + '\\n';\n\t\tbuffer += '512-byte trainer: ' +\n\t\t\tUtility.convertDecToHexString(this.getTrainer512Bytes()) + '\\n';\n\t\tbuffer += 'Four screen mirroring: ' +\n\t\t\tUtility.convertDecToHexString(this.getFourScreenMirroring()) + '\\n';\n\t\tbuffer += 'Mapper number: ' + Utility.convertDecToHexString(this.getMapperNum(), 2) +\n\t\t\t'(' + (new MapperFactory()).getName(this.getMapperNum()) + ')';\n\t\treturn buffer;\n\t}\n});\n\n module.exports = {\n\tRom\n};",
			args: ["Memory", "Mapper", "MapperFactory", "Utility"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 676.4525044547365,
			y: -581.9501828551445,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 75,
		id: "nodular_1694680839013",
		type: "Function",
		position: {
			x: -465.14254896460665,
			y: -319.9371869300684,
		},
		data: {
			label: "Audio.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Audio"],
			loading: false,
			func: "/**\n * Handling audio output with Web Audio.\n */\nfunction Audio() {\n  var self = this;\n\n  //\n\n  var audioContext = AudioContext || webkitAudioContext;\n\n  if(audioContext === undefined)\n    throw new Error('This browser seems not to support AudioContext.');\n\n  //\n\n  this.bufferLength = 4096;\n  this.buffer = new Float32Array(this.bufferLength);\n  this.bufferIndex = 0;\n\n  //\n\n  this.context = new audioContext();\n  this.scriptProcessor = this.context.createScriptProcessor(this.bufferLength, 0, 1);\n\n  this.scriptProcessor.onaudioprocess = function(e) {\n    self.onAudioProcess(e);\n  };\n\n  this.scriptProcessor.connect(this.context.destination);\n  this.sampleRate = this.context.sampleRate;\n}\n\nObject.assign(Audio.prototype, {\n  isAudio: true,\n\n  /**\n   *\n   */\n  getSampleRate: function() {\n    return this.sampleRate;\n  },\n\n  /**\n   *\n   */\n  onAudioProcess: function(e) {\n    var data = e.outputBuffer.getChannelData(0);\n\n    for(var i = 0, il = this.bufferLength; i < il; i++)\n      data[i] = this.buffer[i];\n\n    // @TODO: Fix me\n\n    for(var i = this.bufferIndex, il = this.bufferLength; i < il; i++)\n      data[i] = this.bufferIndex === 0 ? 0.0 : this.buffer[this.bufferIndex - 1];\n\n    this.bufferIndex = 0;\n  },\n\n  /**\n   *\n   */\n  push: function(data) {\n    if(this.bufferIndex >= this.bufferLength)\n      return;\n\n    this.buffer[this.bufferIndex++] = data;\n  }\n});\n\n module.exports = {Audio};",
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -465.14254896460665,
			y: -319.9371869300684,
		},
		dragging: false,
	},
	{
		width: 188,
		height: 116,
		id: "nodular_1694680840273",
		type: "Function",
		position: {
			x: -48.21262732603612,
			y: -294.6166845871256,
		},
		data: {
			label: "Mapper.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Mapper", "MapperFactory"],
			loading: false,
			func: "\n\n\n/**\n *\n */\n\n/**\n *\n */\nfunction MapperFactory() {\n\n}\n\nObject.assign(MapperFactory.prototype, {\n\tisMapperFactory: true,\n\n\t//\n\n\tMAPPERS: {\n\t\t0: {\n\t\t\t'name': 'NROM',\n\t\t\tclass: NROMMapper\n\t\t},\n\t\t1: {\n\t\t\t'name': 'MMC1',\n\t\t\tclass: MMC1Mapper\n\t\t},\n\t\t2: {\n\t\t\t'name': 'UNROM',\n\t\t\tclass: UNROMMapper\n\t\t},\n\t\t3: {\n\t\t\t'name': 'CNROM',\n\t\t\tclass: CNROMMapper\n\t\t},\n\t\t4: {\n\t\t\t'name': 'MMC3',\n\t\t\tclass: MMC3Mapper\n\t\t},\n\t\t76: {\n\t\t\t'name': 'Mapper76',\n\t\t\tclass: Mapper76\n\t\t}\n\t},\n\n\t// public methods\n\n\t/**\n\t *\n\t */\n\tcreate: function(number, rom) {\n\t\treturn new(this.getMapperParam(number)).class(rom);\n\t},\n\n\t/**\n\t *\n\t */\n\tgetName: function(number) {\n\t\treturn this.getMapperParam(number).name;\n\t},\n\n\t// private method\n\n\t/**\n\t *\n\t */\n\tgetMapperParam: function(number) {\n\t\tif (this.MAPPERS[number] === undefined)\n\t\t\tthrow new Error('unsupport No.' + number + ' Mapper');\n\n\t\treturn this.MAPPERS[number];\n\t}\n});\n\n/**\n *\n */\nfunction Mapper(rom) {\n\tthis.rom = rom;\n\tthis.prgBankNum = rom.header.getPRGROMBanksNum();\n\tthis.chrBankNum = rom.header.getCHRROMBanksNum();\n}\n\nObject.assign(Mapper.prototype, {\n\tisMapper: true,\n\n\t/**\n\t * Maps CPU memory address 0x8000 - 0xFFFF to the offset\n\t * in Program segment of Rom for Program ROM access\n\t */\n\tmap: function(address) {\n\t\treturn address - 0x8000;\n\t},\n\n\t/**\n\t * Maps CPU memory address 0x0000 - 0x1FFF to the offset\n\t * in Character segment of Rom for Character ROM access\n\t */\n\tmapForChrRom: function(address) {\n\t\treturn address;\n\t},\n\n\t/**\n\t * In general, updates control registers in Mapper\n\t */\n\tstore: function(address, value) {},\n\n\t/**\n\t *\n\t */\n\tgetMirroringType: function() {\n\t\treturn this.rom.header.isHorizontalMirroring() === true ?\n\t\t\tthis.rom.MIRRORINGS.HORIZONTAL : this.rom.MIRRORINGS.VERTICAL;\n\t}\n});\n\n/**\n *\n */\nfunction NROMMapper(rom) {\n\tMapper.call(this, rom);\n}\n\nNROMMapper.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisNROMMapper: true,\n\n\t/**\n\t *\n\t */\n\tmap: function(address) {\n\t\t// 0x8000 - 0xBFFF: First 16 KB of ROM\n\t\t// 0xC000 - 0xFFFF: Last 16 KB of ROM (NROM-256) or\n\t\t//                  mirror of 0x8000 - 0xBFFF (NROM-128).\n\n\t\tif (this.prgBankNum === 1 && address >= 0xC000)\n\t\t\taddress -= 0x4000;\n\n\t\treturn address - 0x8000;\n\t}\n});\n\n/**\n *\n */\nfunction MMC1Mapper(rom) {\n\tMapper.call(this, rom);\n\n\tthis.controlRegister = new Register8bit(); // register 0\n\tthis.chrBank0Register = new Register8bit(); // register 1\n\tthis.chrBank1Register = new Register8bit(); // register 2\n\tthis.prgBankRegister = new Register8bit(); // register 3\n\n\tthis.latch = new Register8bit();\n\n\tthis.registerWriteCount = 0;\n\n\tthis.controlRegister.store(0x0C); // seems like 0xC would be default value\n}\n\nMMC1Mapper.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisMMC1Mapper: true,\n\n\t/**\n\t *\n\t */\n\tmap: function(address) {\n\t\tvar bank = 0;\n\t\tvar offset = address & 0x3FFF;\n\t\tvar bankNum = this.prgBankRegister.load() & 0x0F;\n\n\t\tswitch (this.controlRegister.loadBits(2, 2)) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\n\t\t\t\t// switch 32KB at 0x8000, ignoring low bit of bank number\n\n\t\t\t\t// TODO: Fix me\n\n\t\t\t\toffset = offset | (address & 0x4000);\n\t\t\t\tbank = bankNum & 0x0E;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\n\t\t\t\t// fix first bank at 0x8000 and switch 16KB bank at 0xC000\n\n\t\t\t\tbank = (address < 0xC000) ? 0 : bankNum;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\n\t\t\t\t// fix last bank at 0xC000 and switch 16KB bank at 0x8000\n\n\t\t\t\tbank = (address >= 0xC000) ? this.prgBankNum - 1 : bankNum;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn bank * 0x4000 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tmapForChrRom: function(address) {\n\t\tvar bank;\n\t\tvar offset = address & 0x0FFF;\n\n\t\tif (this.controlRegister.loadBit(4) === 0) {\n\n\t\t\t// switch 8KB at a time\n\n\t\t\tbank = (this.chrBank0Register.load() & 0x1E);\n\t\t\toffset = offset | (address & 0x1000);\n\t\t} else {\n\n\t\t\t// switch two separate 4KB banks\n\n\t\t\tbank = ((address < 0x1000) ? this.chrBank0Register.load() : this.chrBank1Register.load()) & 0x1F;\n\t\t}\n\n\t\treturn bank * 0x1000 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(address, value) {\n\t\tif (value & 0x80) {\n\t\t\tthis.registerWriteCount = 0;\n\t\t\tthis.latch.clear();\n\n\t\t\tif ((address & 0x6000) === 0)\n\t\t\t\tthis.controlRegister.storeBits(2, 2, 3)\n\t\t} else {\n\t\t\tthis.latch.store(((value & 1) << 4) | (this.latch.load() >> 1));\n\t\t\tthis.registerWriteCount++;\n\n\t\t\tif (this.registerWriteCount >= 5) {\n\t\t\t\tvar val = this.latch.load();\n\n\t\t\t\tswitch (address & 0x6000) {\n\t\t\t\t\tcase 0x0000:\n\t\t\t\t\t\tthis.controlRegister.store(val);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0x2000:\n\t\t\t\t\t\tthis.chrBank0Register.store(val);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0x4000:\n\t\t\t\t\t\tthis.chrBank1Register.store(val);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0x6000:\n\t\t\t\t\t\tthis.prgBankRegister.store(val);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthis.registerWriteCount = 0;\n\t\t\t\tthis.latch.clear();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * TODO: Fix me\n\t */\n\tgetMirroringType: function() {\n\t\tswitch (this.controlRegister.loadBits(0, 2)) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\treturn this.rom.MIRRORINGS.SINGLE_SCREEN;\n\n\t\t\tcase 2:\n\t\t\t\treturn this.rom.MIRRORINGS.VERTICAL;\n\n\t\t\tcase 3:\n\t\t\t\treturn this.rom.MIRRORINGS.HORIZONTAL;\n\t\t}\n\t}\n});\n\n/**\n *\n */\nfunction UNROMMapper(rom) {\n\tMapper.call(this, rom);\n\tthis.reg = new Register8bit();\n}\n\nUNROMMapper.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisUNROMMapper: true,\n\n\t/**\n\t *\n\t */\n\tmap: function(address) {\n\t\tvar bank = (address < 0xC000) ? this.reg.load() : this.prgBankNum - 1;\n\t\tvar offset = address & 0x3FFF;\n\t\treturn 0x4000 * bank + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(address, value) {\n\t\tthis.reg.store(value & 0xF);\n\t}\n});\n\n/**\n *\n */\nfunction CNROMMapper(rom) {\n\tMapper.call(this, rom);\n\tthis.reg = new Register8bit();\n}\n\nCNROMMapper.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisCNROMMapper: true,\n\n\t/**\n\t *\n\t */\n\tmapForChrRom: function(address) {\n\t\treturn this.reg.load() * 0x2000 + (address & 0x1FFF);\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(address, value) {\n\t\tthis.reg.store(value & 0xF);\n\t}\n});\n\n/**\n *\n */\nfunction MMC3Mapper(rom) {\n\tMapper.call(this, rom);\n\n\tthis.register0 = new Register8bit();\n\tthis.register1 = new Register8bit();\n\tthis.register2 = new Register8bit();\n\tthis.register3 = new Register8bit();\n\tthis.register4 = new Register8bit();\n\tthis.register5 = new Register8bit();\n\tthis.register6 = new Register8bit();\n\tthis.register7 = new Register8bit();\n\n\tthis.programRegister0 = new Register8bit();\n\tthis.programRegister1 = new Register8bit();\n\n\tthis.characterRegister0 = new Register8bit();\n\tthis.characterRegister1 = new Register8bit();\n\tthis.characterRegister2 = new Register8bit();\n\tthis.characterRegister3 = new Register8bit();\n\tthis.characterRegister4 = new Register8bit();\n\tthis.characterRegister5 = new Register8bit();\n\n\tthis.irqCounter = 0;\n\tthis.irqCounterReload = false;\n\tthis.irqEnabled = true; // @TODO: check if default is true\n}\n\nMMC3Mapper.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisMMC3Mapper: true,\n\n\t/**\n\t *\n\t */\n\tmap: function(address) {\n\t\taddress = address & 0xFFFF; // just in case\n\n\t\tvar offset = address & 0x1FFF;\n\t\tvar bank = 0;\n\n\t\tif (address >= 0x8000 && address < 0xA000) {\n\t\t\tbank = this.register0.isBitSet(6) === true ? this.prgBankNum * 2 - 2 : this.programRegister0.load();\n\t\t} else if (address >= 0xA000 && address < 0xC000) {\n\t\t\tbank = this.programRegister1.load();\n\t\t} else if (address >= 0xC000 && address < 0xE000) {\n\t\t\tbank = this.register0.isBitSet(6) === true ? this.programRegister0.load() : this.prgBankNum * 2 - 2;\n\t\t} else {\n\t\t\tbank = this.prgBankNum * 2 - 1;\n\t\t}\n\n\t\treturn bank * 0x2000 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tmapForChrRom: function(address) {\n\t\taddress = address & 0x1FFF; // just in case\n\n\t\tvar offset = address & 0x03FF;\n\t\tvar bank = 0;\n\n\t\tif (this.register0.isBitSet(7) === true) {\n\t\t\tif (address >= 0x0000 && address < 0x0400) {\n\t\t\t\tbank = this.characterRegister2.load();\n\t\t\t} else if (address >= 0x0400 && address < 0x0800) {\n\t\t\t\tbank = this.characterRegister3.load();\n\t\t\t} else if (address >= 0x0800 && address < 0x0C00) {\n\t\t\t\tbank = this.characterRegister4.load();\n\t\t\t} else if (address >= 0x0C00 && address < 0x1000) {\n\t\t\t\tbank = this.characterRegister5.load();\n\t\t\t} else if (address >= 0x1000 && address < 0x1400) {\n\t\t\t\tbank = this.characterRegister0.load() & 0xFE;\n\t\t\t} else if (address >= 0x1400 && address < 0x1800) {\n\t\t\t\tbank = this.characterRegister0.load() | 1;\n\t\t\t} else if (address >= 0x1800 && address < 0x1C00) {\n\t\t\t\tbank = this.characterRegister1.load() & 0xFE;\n\t\t\t} else {\n\t\t\t\tbank = this.characterRegister1.load() | 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (address >= 0x0000 && address < 0x0400) {\n\t\t\t\tbank = this.characterRegister0.load() & 0xFE;\n\t\t\t} else if (address >= 0x0400 && address < 0x0800) {\n\t\t\t\tbank = this.characterRegister0.load() | 1;\n\t\t\t} else if (address >= 0x0800 && address < 0x0C00) {\n\t\t\t\tbank = this.characterRegister1.load() & 0xFE;\n\t\t\t} else if (address >= 0x0C00 && address < 0x1000) {\n\t\t\t\tbank = this.characterRegister1.load() | 1;\n\t\t\t} else if (address >= 0x1000 && address < 0x1400) {\n\t\t\t\tbank = this.characterRegister2.load();\n\t\t\t} else if (address >= 0x1400 && address < 0x1800) {\n\t\t\t\tbank = this.characterRegister3.load();\n\t\t\t} else if (address >= 0x1800 && address < 0x1C00) {\n\t\t\t\tbank = this.characterRegister4.load();\n\t\t\t} else {\n\t\t\t\tbank = this.characterRegister5.load();\n\t\t\t}\n\t\t}\n\n\t\treturn bank * 0x400 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(address, value) {\n\t\taddress = address & 0xFFFF; // just in case\n\n\t\tif (address >= 0x8000 && address < 0xA000) {\n\t\t\tif ((address & 1) === 0) {\n\t\t\t\tthis.register0.store(value);\n\t\t\t} else {\n\t\t\t\tthis.register1.store(value);\n\n\t\t\t\tswitch (this.register0.loadBits(0, 3)) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tthis.characterRegister0.store(value & 0xFE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.characterRegister1.store(value & 0xFE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tthis.characterRegister2.store(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tthis.characterRegister3.store(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tthis.characterRegister4.store(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tthis.characterRegister5.store(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tthis.programRegister0.store(value & 0x3F);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tthis.programRegister1.store(value & 0x3F);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (address >= 0xA000 && address < 0xC000) {\n\t\t\tif ((address & 1) === 0) {\n\t\t\t\tthis.register2.store(value);\n\t\t\t} else {\n\t\t\t\tthis.register3.store(value);\n\t\t\t}\n\t\t} else if (address >= 0xC000 && address < 0xE000) {\n\t\t\tif ((address & 1) === 0) {\n\t\t\t\tthis.register4.store(value);\n\t\t\t} else {\n\t\t\t\tthis.register5.store(value);\n\t\t\t}\n\n\t\t\tthis.irqCounterReload = true;\n\t\t} else {\n\t\t\tif ((address & 1) === 0) {\n\t\t\t\tthis.register6.store(value);\n\t\t\t\tthis.irqEnabled = false;\n\t\t\t} else {\n\t\t\t\tthis.register7.store(value);\n\t\t\t\tthis.irqEnabled = true;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t *\n\t */\n\tgetMirroringType: function() {\n\t\treturn this.register2.isBitSet(0) === true ? this.rom.MIRRORINGS.HORIZONTAL : this.rom.MIRRORINGS.VERTICAL;\n\t},\n\n\t/**\n\t *\n\t */\n\tdriveIrqCounter: function(cpu) {\n\t\tif (this.irqCounterReload === true) {\n\t\t\tthis.irqCounter = this.register4.load();\n\t\t\tthis.irqCounterReload = false;\n\t\t} else {\n\t\t\tif (this.irqEnabled === true) {\n\t\t\t\tif (this.irqCounter > 0) {\n\t\t\t\t\tthis.irqCounter--;\n\n\t\t\t\t\tif (this.irqCounter === 0) {\n\t\t\t\t\t\tcpu.interrupt(cpu.INTERRUPTS.IRQ);\n\t\t\t\t\t\tthis.irqCounterReload = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n/**\n *\n */\nfunction Mapper76(rom) {\n\tMapper.call(this, rom);\n\tthis.addrReg = new Register8bit();\n\tthis.chrReg0 = new Register8bit();\n\tthis.chrReg1 = new Register8bit();\n\tthis.chrReg2 = new Register8bit();\n\tthis.chrReg3 = new Register8bit();\n\tthis.prgReg0 = new Register8bit();\n\tthis.prgReg1 = new Register8bit();\n}\n\nMapper76.prototype = Object.assign(Object.create(Mapper.prototype), {\n\tisMapper76: true,\n\n\t/**\n\t *\n\t */\n\tmap: function(address) {\n\t\tvar bank;\n\t\tvar offset = address & 0x1FFF;\n\n\t\tswitch (address & 0xE000) {\n\t\t\tcase 0x8000:\n\t\t\t\tbank = this.prgReg0.load();\n\t\t\t\tbreak;\n\n\t\t\tcase 0xA000:\n\t\t\t\tbank = this.prgReg1.load();\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC000:\n\t\t\t\tbank = this.prgBankNum * 2 - 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 0xE000:\n\t\t\t\tbank = this.prgBankNum * 2 - 1;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn bank * 0x2000 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tmapForChrRom: function(address) {\n\t\tvar bank;\n\t\tvar offset = address & 0x7FF;\n\n\t\tswitch (address & 0x1800) {\n\t\t\tcase 0x0000:\n\t\t\t\tbank = this.chrReg0.load();\n\t\t\t\tbreak;\n\n\t\t\tcase 0x0800:\n\t\t\t\tbank = this.chrReg1.load();\n\t\t\t\tbreak;\n\n\t\t\tcase 0x1000:\n\t\t\t\tbank = this.chrReg2.load();\n\t\t\t\tbreak;\n\n\t\t\tcase 0x1800:\n\t\t\t\tbank = this.chrReg3.load();\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn bank * 0x800 + offset;\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(address, value) {\n\t\tswitch (address & 0xE001) {\n\t\t\tcase 0x8000:\n\t\t\t\tthis.addrReg.store(value & 0x7);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x8001:\n\t\t\t\tvar reg;\n\n\t\t\t\tswitch (this.addrReg.load()) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treg = this.chrReg0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treg = this.chrReg1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treg = this.chrReg2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treg = this.chrReg3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\treg = this.prgReg0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treg = this.prgReg1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treg.store(value & 0x3F);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n module.exports = {\n\tMapper,\n\tMapperFactory\n};",
			args: ["Register8bit"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -48.21262732603612,
			y: -294.6166845871256,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 116,
		id: "nodular_1694680841259",
		type: "Function",
		position: {
			x: 382.2972189844184,
			y: -252.02719501895285,
		},
		data: {
			label: "Joypad.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Joypad"],
			loading: false,
			func: "\n\n\n/**\n * Standard joypad implementation.\n * Refer to https://wiki.nesdev.com/w/index.php/Standard_controller\n */\nfunction Joypad() {\n  this.register = new Register8bit();\n\n  this.latch = 0;\n  this.currentButton = 0;\n\n  this.buttonNum = this.getButtonsNum();\n\n  this.buttons = [];  // if buttons are being pressed.\n                      // index is corresponded to Joypad.BUTTONS'\n  for(var i = 0; i < this.buttonNum; i++)\n    this.buttons[i] = false;\n}\n\n//\n\nJoypad.BUTTONS = {\n  A:      0,\n  B:      1,\n  SELECT: 2,\n  START:  3,\n  UP:     4,\n  DOWN:   5,\n  LEFT:   6,\n  RIGHT:  7\n};\n\n//\n\nObject.assign(Joypad.prototype, {\n  isJoypad: true,\n\n  //\n\n  /**\n   *\n   */\n  getButtonsNum: function() {\n    var num = 0;\n    for (var key in Joypad.BUTTONS) {\n      num++;\n    }\n    return num;\n  },\n\n  //\n\n  /**\n   *\n   */\n  pressButton: function(type) {\n    this.buttons[type] = true;\n  },\n\n  /**\n   *\n   */\n  releaseButton: function(type) {\n    this.buttons[type] = false;\n  },\n\n  //\n\n  /**\n   *\n   */\n  loadRegister: function() {\n    var button = this.latch === 1 ? 0 : this.currentButton++;\n\n    // 1: a button is being pressed or after eight reads\n    // 0: otherwise\n    var value = (button >= this.buttonNum || this.buttons[button]) ? 1 : 0;\n\n    return value;\n  },\n\n  /**\n   *\n   */\n  storeRegister: function(value) {\n    this.register.store(value);\n\n    value = value & 1;\n\n    if (value === 1)\n      this.currentButton = 0;\n\n    this.latch = value;\n  },\n\n  // dump\n\n  /**\n   *\n   */\n  dump: function() {\n\n  }\n});\n\n module.exports = {Joypad};",
			args: ["Register8bit"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 382.2972189844184,
			y: -252.02719501895285,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 116,
		id: "nodular_1694680842023",
		type: "Function",
		position: {
			x: -60.0434276625365,
			y: -835.3081644755597,
		},
		data: {
			label: "Apu.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Apu"],
			loading: false,
			func: "\n\n\n/**\n * RP2A03(NTSC)\n * Audio Processing Unit implementation. Consists of\n *   - Pulse 1/2 channel\n *   - Triangle channel\n *   - Noise channel\n *   - DMC channel\n *\n * Refer to https://wiki.nesdev.com/w/index.php/APU\n */\nfunction Apu() {\n  // other devices\n\n  this.cpu = null;  // set by .setCpu()\n\n  //\n\n  this.audio = null;  // set by .setAudio()\n\n  // APU units, CPU memory address mapped registers\n\n  this.pulse1 = new ApuPulse(true);   // 0x4000 - 0x4003\n  this.pulse2 = new ApuPulse(false);  // 0x4004 - 0x4007\n  this.triangle = new ApuTriangle();  // 0x4008 - 0x400B\n  this.noise = new ApuNoise();        // 0x400C - 0x400F\n  this.dmc = new ApuDmc(this);        // 0x4010 - 0x4013\n\n  this.status = new ApuStatusRegister();  // 0x4015\n  this.frame = new ApuFrameRegister();    // 0x4017\n\n  //\n\n  this.cycle = 0;\n  this.step = 0;\n  this.samplePeriod = 0; // set by .setAudio()\n\n  //\n\n  this.frameIrqActive = false;\n  this.dmcIrqActive = false;\n}\n\nObject.assign(Apu.prototype, {\n  isApu: true,\n\n  // public methods\n\n  /**\n   *\n   */\n  setCpu: function(cpu) {\n    this.cpu = cpu;\n  },\n\n  /**\n   *\n   */\n  setAudio: function(audio) {\n    this.audio = audio;\n\n    // CPU clock frequency 1.789773 MHz\n\n    this.samplePeriod = (1789773 / this.audio.getSampleRate()) | 0;\n  },\n\n  /**\n   *\n   */\n  bootup: function() {\n    this.status.store(0x00);\n  },\n\n  /**\n   *\n   */\n  reset: function() {\n\n  },\n\n  /**\n   * Expects being called with CPU clock\n   */\n  runCycle: function() {\n    this.cycle++;\n\n    // Sampling at sample rate timing\n    // @TODO: Fix me, more precise timing\n\n    if((this.cycle % this.samplePeriod) === 0)\n      this.sample();\n\n    // Timers\n    // Clocked on every CPU cycles for triangle and 2CPU cycles for others\n\n    if((this.cycle % 2) === 0) {\n      this.pulse1.driveTimer();\n      this.pulse2.driveTimer();\n      this.noise.driveTimer();\n      this.dmc.driveTimer();\n    }\n\n    this.triangle.driveTimer();\n\n    // 240Hz Frame sequencer\n    // @TODO: Fix me, more precise timing\n\n    if((this.cycle % 7457) === 0) {\n      if(this.frame.isFiveStepMode() === true) {\n\n        // Five-step sequence\n        //\n        // 0 1 2 3 4    function\n        // -----------  -----------------------------\n        // - - - - -    IRQ (if bit 6 is clear)\n        // l - l - -    Length counter and sweep\n        // e e e e -    Envelope and linear counter\n\n        if(this.step < 4) {\n          this.pulse1.driveEnvelope();\n          this.pulse2.driveEnvelope();\n          this.triangle.driveLinear();\n          this.noise.driveEnvelope();\n        }\n\n        if(this.step === 0 || this.step === 2) {\n          this.pulse1.driveLength();\n          this.pulse1.driveSweep();\n          this.pulse2.driveLength();\n          this.pulse2.driveSweep();\n          this.triangle.driveLength();\n          this.noise.driveLength();\n        }\n\n        this.step = (this.step + 1) % 5;\n      } else {\n\n        // Four-step sequence\n        //\n        // 0 1 2 3    function\n        // ---------  -----------------------------\n        // - - - f    IRQ (if bit 6 is clear)\n        // - l - l    Length counter and sweep\n        // e e e e    Envelope and linear counter\n\n        this.pulse1.driveEnvelope();\n        this.pulse2.driveEnvelope();\n        this.triangle.driveLinear();\n        this.noise.driveEnvelope();\n\n        if(this.step === 1 || this.step === 3) {\n          this.pulse1.driveLength();\n          this.pulse1.driveSweep();\n          this.pulse2.driveLength();\n          this.pulse2.driveSweep();\n          this.triangle.driveLength();\n          this.noise.driveLength();\n        }\n\n        if(this.step === 3 && this.frame.disabledIrq() === false)\n          this.frameIrqActive = true;\n\n        // Seems like keep invoking IRQ once frame IRQ flag is on\n        // until IRQ flag is cleared or it's disabled...?\n        // @TODO: check sending IRQ timing\n\n        if(this.frameIrqActive === true && this.frame.disabledIrq() === false)\n          this.cpu.interrupt(this.cpu.INTERRUPTS.IRQ);\n\n        this.step = (this.step + 1) % 4;\n      }\n\n      // @TODO: check sending IRQ timing\n\n      if(this.dmcIrqActive === true)\n          this.cpu.interrupt(this.cpu.INTERRUPTS.IRQ);\n    }\n  },\n\n  // load/store CPU memory address mapped register methods called by CPU\n\n  /**\n   *\n   */\n  loadRegister: function(address) {\n    switch(address) {\n      case 0x4015:\n\n        // Loading status register\n        //\n        // bit\n        //   7: DMC interrupt\n        //   6: Frame interrupt\n        //   4: DMC remaining bytes > 0\n        //   3: Noise length counter > 0\n        //   2: Triangle length couter > 0\n        //   1: Pulse2 length counter > 0\n        //   0: Pulse1 length counter > 0\n\n        var value = 0;\n\n        value |= (this.dmcIrqActive === true ? 1 : 0) << 7;\n        value |= (this.frameIrqActive === true &&\n                   this.frame.disabledIrq() === false ? 1 : 0) << 6;\n        value |= (this.dmc.remainingBytes > 0 ? 1 : 0) << 4;\n        value |= (this.noise.lengthCounter > 0 ? 1 : 0) << 3;\n        value |= (this.triangle.lengthCounter > 0 ? 1 : 0) << 2;\n        value |= (this.pulse2.lengthCounter > 0 ? 1 : 0) << 1;\n        value |= (this.pulse1.lengthCounter > 0 ? 1 : 0) << 0;\n\n        // Loading status register clears the frame IRQ flag\n\n        this.frameIrqActive = false;\n\n        return value;\n    }\n\n    return 0;\n  },\n\n  /**\n   *\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n      case 0x4000:\n      case 0x4001:\n      case 0x4002:\n      case 0x4003:\n        this.pulse1.storeRegister(address, value);\n        break;\n\n      case 0x4004:\n      case 0x4005:\n      case 0x4006:\n      case 0x4007:\n        this.pulse2.storeRegister(address, value);\n        break;\n\n      case 0x4008:\n      case 0x4009:\n      case 0x400A:\n      case 0x400B:\n        this.triangle.storeRegister(address, value);\n        break;\n\n      case 0x400C:\n      case 0x400D:\n      case 0x400E:\n      case 0x400F:\n        this.noise.storeRegister(address, value);\n        break;\n\n      case 0x4010:\n      case 0x4011:\n      case 0x4012:\n      case 0x4013:\n        this.dmc.storeRegister(address, value);\n        break;\n\n      case 0x4015:\n\n        // Storing status register\n        //\n        // bit: Enable(1) / Disable(0)\n        //   4: DMC unit\n        //   3: Noise unit\n        //   2: Triangle unit\n        //   1: Pulse2 unit\n        //   0: Pulse1 unit\n        //\n        // Writing a zero to any of channel enables bits will\n        // set its length counter/remaining bytes to zero.\n\n        this.status.store(value);\n\n        this.dmc.setEnable((value & 0x10) === 0x10);\n        this.noise.setEnable((value & 0x8) === 0x8);\n        this.triangle.setEnable((value & 0x4) === 0x4);\n        this.pulse2.setEnable((value & 0x2) === 0x2);\n        this.pulse1.setEnable((value & 0x1) === 0x1);\n\n        // Storing status register clears the DMC interrupt flag\n\n        this.dmcIrqActive = false;\n\n        break;\n\n      case 0x4017:\n\n        // Storing frame counter register\n\n        this.frame.store(value);\n\n        // If interrupt inhibit flag is set, the frame IRQ flag is cleared.\n\n        if(this.frame.disabledIrq() === true)\n          this.frameIrqActive = false;\n\n        break;\n    }\n  },\n\n  // private method\n\n  /**\n   *\n   */\n  sample: function() {\n\n    // Calculates the audio output within the range of 0.0 to 1.0.\n    // Refer to https://wiki.nesdev.com/w/index.php/APU_Mixer\n\n    var pulse1 = this.pulse1.output();\n    var pulse2 = this.pulse2.output();\n    var triangle = this.triangle.output();\n    var noise = this.noise.output();\n    var dmc = this.dmc.output();\n\n    var pulseOut = 0;\n    var tndOut = 0;\n\n    if(pulse1 !== 0 || pulse2 !== 0)\n      pulseOut = 95.88 / ((8128 / (pulse1 + pulse2)) + 100);\n\n    if(triangle !== 0 || noise !== 0 || dmc !== 0)\n      tndOut = 159.79 / (1 / (triangle / 8227 + noise / 12241 + dmc / 22638) + 100);\n\n    this.audio.push(pulseOut + tndOut);\n  },\n\n  // dump\n\n  /**\n   *\n   */\n  dump: function() {\n\n  }\n});\n\n/**\n *\n */\nfunction ApuUnit(apu) {\n  this.apu = apu;\n}\n\n// Refer to https://wiki.nesdev.com/w/index.php/APU_Length_Counter\n\nApuUnit.LENGTH_TABLE = [\n  0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06,\n  0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E,\n  0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16,\n  0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E\n];\n\n/**\n * Apu Pulse channel. Consists of\n *   - Timer\n *   - Length counter\n *   - Envelope\n *   - Sweep\n */\nfunction ApuPulse(isChannel1) {\n\n  this.isChannel1 = isChannel1;\n\n  // CPU memory address mapped registers\n\n  // 0x4000 / 0x4004\n  //\n  // bit:\n  // 7-6: Duty cycle\n  //   5: Length counter halt\n  //   4: Enable envelope\n  // 3-0: Envelope divider period\n\n  // 0x4001 / 0x4005\n  //\n  // bit:\n  //   7: Enable sweep\n  // 6-4: Period\n  //   3: Negate\n  // 2-0: Shift amount per period\n\n  // 0x4002 / 0x4006\n  //\n  // bit:\n  // 7-0: Timer low 8-bit\n\n  // 0x4003 / 0x4007\n  //\n  // bit:\n  // 7-3: Length counter index\n  // 2-0: Timer high 3-bit\n\n  this.register0 = new Register8bit();  // 0x4000 / 0x4004\n  this.register1 = new Register8bit();  // 0x4001 / 0x4005\n  this.register2 = new Register8bit();  // 0x4002 / 0x4006\n  this.register3 = new Register8bit();  // 0x4003 / 0x4007\n\n  //\n\n  this.enabled = false;\n\n  //\n\n  this.timerCounter = 0;\n  this.timerPeriod = 0;\n  this.timerSequence = 0;\n\n  this.envelopeStartFlag = true;\n  this.envelopeCounter = 0;\n  this.envelopeDecayLevelCounter = 0;\n\n  this.lengthCounter = 0;\n\n  this.sweepReloadFlag = false;\n  this.sweepCycle = 0;\n  this.sweepCounter = 0;\n}\n\nObject.assign(ApuPulse.prototype, {\n  isApuPulse: true,\n\n  //\n\n  LENGTH_TABLE: ApuUnit.LENGTH_TABLE,\n\n  DUTY_TABLE: [\n    [0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 1, 1, 0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 1, 0, 0, 0],\n    [1, 0, 0, 1, 1, 1, 1, 1],\n  ],\n\n  //\n\n  /**\n   *\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n      case 0x4000:\n      case 0x4004:\n        this.register0.store(value);\n\n        break;\n\n      case 0x4001:\n      case 0x4005:\n        this.register1.store(value);\n\n        // Side effect\n        //   - Sets the sweep reload flag\n\n        this.sweepReloadFlag = true;\n\n        break;\n\n      case 0x4002:\n      case 0x4006:\n        this.register2.store(value);\n        this.timerPeriod = this.getTimer();\n\n        break;\n\n      case 0x4003:\n      case 0x4007:\n        this.register3.store(value);\n\n        // Side effects\n        //   - If the enabled flag is set, the length counter is reloaded\n        //   - The envelope is restarted\n        //   - The sequencer is immediately restarted at the first value of the current\n        //     sequence. The period divider is not reset.\n\n        if(this.enabled === true)\n          this.lengthCounter = this.LENGTH_TABLE[this.getLengthCounterIndex()];\n\n        this.timerPeriod = this.getTimer();\n        this.timerSequence = 0;\n        this.envelopeStartFlag = true;\n\n        break;\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  setEnable: function(enabled) {\n    this.enabled = enabled;\n\n    // When the enabled bit is cleared (via $4015), the length counter is forced to 0\n\n    if(enabled === false)\n      this.lengthCounter = 0;\n  },\n\n  /**\n   *\n   */\n  getDuty: function() {\n    return this.register0.loadBits(6, 2);\n  },\n\n  /**\n   *\n   */\n  enabledEnvelopeLoop: function() {\n    return this.register0.isBitSet(5);\n  },\n\n  /**\n   *\n   */\n  disabledEnvelope: function() {\n    return this.register0.isBitSet(4);\n  },\n\n  /**\n   *\n   */\n  getEnvelopePeriod: function() {\n    return this.register0.loadBits(0, 4);\n  },\n\n  /**\n   *\n   */\n  enabledSweep: function() {\n    return this.register1.isBitSet(7);\n  },\n\n  /**\n   *\n   */\n  getSweepPeriod: function() {\n    return this.register1.loadBits(4, 3);\n  },\n\n  /**\n   *\n   */\n  negatedSweep: function() {\n    return this.register1.isBitSet(3);\n  },\n\n  /**\n   *\n   */\n  getSweepShiftAmount: function() {\n    return this.register1.loadBits(0, 3);\n  },\n\n  /**\n   *\n   */\n  getTimerLow: function() {\n    return this.register2.load();\n  },\n\n  /**\n   *\n   */\n  getTimerHigh: function() {\n    return this.register3.loadBits(0, 3);\n  },\n\n  /**\n   *\n   */\n  getTimer: function() {\n    return ((this.getTimerHigh() << 8) | this.getTimerLow());\n  },\n\n  /**\n   *\n   */\n  getLengthCounterIndex: function() {\n    return this.register3.loadBits(3, 5);\n  },\n\n  //\n\n  /**\n   *\n   */\n  driveTimer: function() {\n    if(this.timerCounter > 0) {\n      this.timerCounter--;\n    } else {\n      this.timerCounter = this.timerPeriod;\n      this.timerSequence++;\n\n      // 8-step sequencer\n\n      if(this.timerSequence === 8)\n        this.timerSequence = 0;\n    }\n  },\n\n  /**\n   *\n   */\n  driveLength: function() {\n    if(this.disabledEnvelope() === false && this.lengthCounter > 0)\n      this.lengthCounter--;\n  },\n\n  /**\n   *\n   */\n  driveEnvelope: function() {\n    if(this.envelopeStartFlag === true) {\n      this.envelopeCounter = this.getEnvelopePeriod();\n      this.envelopeDecayLevelCounter = 0xF;\n      this.envelopeStartFlag = false;\n      return;\n    }\n\n    if(this.envelopeCounter > 0) {\n      this.envelopeCounter--;\n    } else {\n      this.envelopeCounter = this.getEnvelopePeriod();\n\n      if(this.envelopeDecayLevelCounter > 0)\n        this.envelopeDecayLevelCounter--;\n      else if(this.envelopeDecayLevelCounter === 0 && this.enabledEnvelopeLoop() === true)\n        this.envelopeDecayLevelCounter = 0xF;\n    }\n  },\n\n  /**\n   *\n   */\n  driveSweep: function() {\n    if(this.sweepCounter === 0 && this.enabledSweep() === true &&\n        this.getSweepShiftAmount() !== 0 &&\n        this.timerPeriod >= 8 && this.timerPeriod <= 0x7FF) {\n      var change = this.timerPeriod >> this.getSweepShiftAmount();\n\n      // In negated mode, Pulse 1 adds the ones' complement while\n      // Pulse 2 adds the twos' complement\n\n      if(this.negatedSweep() === true) {\n        change = -change;\n\n        if(this.isChannel1 === true)\n          change--;\n      }\n\n      this.timerPeriod += change;\n    }\n\n    if(this.sweepReloadFlag === true || this.sweepCounter === 0) {\n      this.sweepReloadFlag = false;\n      this.sweepCounter = this.getSweepPeriod();\n    } else {\n      this.sweepCounter--;\n    }\n  },\n\n  /**\n   *\n   */\n  output: function() {\n    if(this.lengthCounter === 0 || this.timerPeriod < 8 || this.timerPeriod > 0x7FF ||\n        this.DUTY_TABLE[this.getDuty()][this.timerSequence] === 0)\n      return 0;\n\n    // 4-bit output\n\n    return (this.disabledEnvelope() === true ? this.getEnvelopePeriod() : this.envelopeDecayLevelCounter) & 0xF;\n  }\n});\n\n/**\n * Apu Triangle channel. Consists of\n *   - Timer\n *   - Length counter\n *   - Linear counter\n */\nfunction ApuTriangle() {\n\n  // CPU memory address mapped registers\n\n  // 0x4008\n  //\n  // bit:\n  //   7: Length counter halt\n  // 6-0: Linear counter period\n\n  // 0x4009\n  //\n  // Unused\n\n  // 0x400A\n  //\n  // bit:\n  // 7-0: Timer low 8-bit\n\n  // 0x400B\n  //\n  // bit:\n  // 7-3: Length counter index\n  // 2-0: Timer high 3-bit\n\n  this.register0 = new Register8bit();  // 0x4008\n  this.register1 = new Register8bit();  // 0x4009\n  this.register2 = new Register8bit();  // 0x400A\n  this.register3 = new Register8bit();  // 0x400B\n\n  //\n\n  this.enabled = false;\n\n  //\n\n  this.timerCounter = 0;\n  this.timerSequence = 0;\n\n  this.lengthCounter = 0;\n\n  this.linearReloadFlag = false;\n  this.linearCounter = 0;\n}\n\nObject.assign(ApuTriangle.prototype, {\n  isApuTriangle: true,\n\n  //\n\n  LENGTH_TABLE: ApuUnit.LENGTH_TABLE,\n\n  SEQUENCE_TABLE: [\n    15, 14, 13, 12, 11, 10,  9,  8,\n     7,  6,  5,  4,  3,  2,  1,  0,\n     0,  1,  2,  3,  4,  5,  6,  7,\n     8,  9, 10, 11, 12, 13, 14, 15\n  ],\n\n  //\n\n  /**\n   *\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n      case 0x4008:\n        this.register0.store(value);\n        break;\n\n      case 0x4009:\n        this.register1.store(value);\n        break;\n\n      case 0x400A:\n        this.register2.store(value);\n        break;\n\n      case 0x400B:\n        this.register3.store(value);\n\n        // Side effects\n        //   - If the enabled flag is set, the length counter is reloaded\n        //   - Sets the linear counter reload flag\n        //   - The sequencer is immediately restarted at the first value of the current\n        //     sequence. The period divider is not reset.\n\n        if(this.enabled === true)\n          this.lengthCounter = this.LENGTH_TABLE[this.getLengthCounterIndex()];\n\n        this.timerSequence = 0;\n        this.linearReloadFlag = true;\n\n        break;\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  setEnable: function(enabled) {\n    this.enabled = enabled;\n\n    // When the enabled bit is cleared (via $4015), the length counter is forced to 0\n\n    if(enabled === false)\n      this.lengthCounter = 0;\n  },\n\n  /**\n   *\n   */\n  getLinearCounter: function() {\n    return this.register0.loadBits(0, 7);\n  },\n\n  /**\n   *\n   */\n  disabledLengthCounter: function() {\n    return this.register0.isBitSet(7);\n  },\n\n  /**\n   *\n   */\n  getLengthCounterIndex: function() {\n    return this.register3.loadBits(3, 5);\n  },\n\n  /**\n   *\n   */\n  getTimerLow: function() {\n    return this.register2.load();\n  },\n\n  /**\n   *\n   */\n  getTimerHigh: function() {\n    return this.register3.loadBits(0, 3);\n  },\n\n  /**\n   *\n   */\n  getTimer: function() {\n    return (this.getTimerHigh() << 8) | this.getTimerLow();\n  },\n\n  //\n\n  /**\n   *\n   */\n  driveTimer: function() {\n    if(this.timerCounter > 0) {\n      this.timerCounter--;\n    } else {\n      this.timerCounter = this.getTimer();\n\n      // The sequencer is clocked by the timer as long as\n      // both the linear counter and the length counter are nonzero.\n\n      if(this.lengthCounter > 0 && this.linearCounter > 0) {\n        this.timerSequence++;\n\n        // 32-step sequencer\n\n        if(this.timerSequence === 32)\n          this.timerSequence = 0;\n      }\n    }\n  },\n\n  /**\n   *\n   */\n  driveLinear: function() {\n    if(this.linearReloadFlag === true)\n      this.linearCounter = this.getLinearCounter();\n    else if(this.linearCounter > 0)\n      this.linearCounter--;\n\n    if(this.disabledLengthCounter() === false)\n      this.linearReloadFlag = false;\n  },\n\n  /**\n   *\n   */\n  driveLength: function() {\n    if(this.disabledLengthCounter() === false && this.lengthCounter > 0)\n      this.lengthCounter--;\n  },\n\n  /**\n   *\n   */\n  output: function() {\n    if(this.enabled === false || this.lengthCounter === 0 ||\n        this.linearCounter === 0 || this.getTimer() < 2)\n      return 0;\n\n    // 4-bit output\n\n    return this.SEQUENCE_TABLE[this.timerSequence] & 0xF;\n  }\n});\n\n/**\n * Apu Noise channel. Consists of\n *   - Timer\n *   - Length counter\n *   - Envelope\n *   - Linear feedback shift register\n */\nfunction ApuNoise() {\n\n  // CPU memory address mapped registers\n\n  // 0x400C\n  //\n  // bit:\n  //   5: Length counter halt\n  //   4: Disable envelope\n  // 3-0: Envelope\n\n  // 0x400D\n  //\n  // Unused\n\n  // 0x400E\n  //\n  // bit:\n  //   7: Loop noise\n  // 3-0: Noise period\n\n  // 0x400F\n  //\n  // bit:\n  // 7-3: Length counter index\n\n  this.register0 = new Register8bit();  // 0x400C\n  this.register1 = new Register8bit();  // 0x400D\n  this.register2 = new Register8bit();  // 0x400E\n  this.register3 = new Register8bit();  // 0x400F\n\n  //\n\n  this.enabled = false;\n\n  //\n\n  this.timerCounter = 0;\n  this.timerPeriod = 0;\n\n  this.envelopeStartFlag = false;\n  this.envelopeCounter = 0;\n  this.envelopeDecayLevelCounter = 0;\n\n  this.lengthCounter = 0;\n\n  this.shiftRegister = 1;  // 15-bit register\n}\n\nObject.assign(ApuNoise.prototype, {\n  isApuNoise: true,\n\n  //\n\n  LENGTH_TABLE: ApuUnit.LENGTH_TABLE,\n\n  TIMER_TABLE: [\n    0x004, 0x008, 0x010, 0x020,\n    0x040, 0x060, 0x080, 0x0A0,\n    0x0CA, 0x0FE, 0x17C, 0x1FC,\n    0x2FA, 0x3F8, 0x7F2, 0xFE4\n  ],\n\n  //\n\n  /**\n   *\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n      case 0x400C:\n        this.register0.store(value);\n        break;\n\n      case 0x400D:\n        this.register1.store(value);\n        break;\n\n      case 0x400E:\n        this.register2.store(value);\n        this.timerPeriod = this.TIMER_TABLE[this.getTimerIndex()]\n\n        break;\n\n      case 0x400F:\n        this.register3.store(value);\n\n        // Side effects\n        //   - If the enabled flag is set, the length counter is reloaded\n        //   - The envelope is restarted\n\n        if(this.enabled === true)\n          this.lengthCounter = this.LENGTH_TABLE[this.getLengthCounterIndex()];\n\n        this.envelopeStartFlag = true;\n\n        break;\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  setEnable: function(enabled) {\n    this.enabled = enabled;\n\n    // When the enabled bit is cleared (via $4015), the length counter is forced to 0\n\n    if(enabled === false)\n      this.lengthCounter = 0;\n  },\n\n  /**\n   *\n   */\n  disabledLengthCounter: function() {\n    return this.register0.isBitSet(5);\n  },\n\n  /**\n   *\n   */\n  disabledEnvelope: function() {\n    return this.register0.isBitSet(4);\n  },\n\n  /**\n   *\n   */\n  getEnvelopePeriod: function() {\n    return this.register0.loadBits(0, 4);\n  },\n\n  /**\n   *\n   */\n  isRandom: function() {\n    return this.register2.isBitSet(7);\n  },\n\n  /**\n   *\n   */\n  getTimerIndex: function() {\n    return this.register2.loadBits(0, 4);\n  },\n\n  /**\n   *\n   */\n  getLengthCounterIndex: function() {\n    return this.register3.loadBits(3, 5);\n  },\n\n  //\n\n  /**\n   *\n   */\n  driveTimer: function() {\n    if(this.timerCounter > 0) {\n      this.timerCounter--;\n    } else {\n      this.timerCounter = this.timerPeriod;\n\n      // Feedback is calculated as the exclusive-OR of bit 0\n      // and another bit: bit 6 if Mode flag is set, otherwise bit 1.\n\n      var feedback = (this.shiftRegister & 1) ^\n                       ((this.shiftRegister >> (this.isRandom() === true ? 6 : 1)) & 1);\n\n      this.shiftRegister = (feedback << 14) | (this.shiftRegister >> 1);\n    }\n  },\n\n  /**\n   *\n   */\n  driveEnvelope: function() {\n    if(this.envelopeStartFlag === true) {\n      this.envelopeCounter = this.getEnvelopePeriod();\n      this.envelopeDecayLevelCounter = 0xF;\n      this.envelopeStartFlag = false;\n      return;\n    }\n\n    if(this.envelopeCounter > 0) {\n      this.envelopeCounter--;\n    } else {\n      this.envelopeCounter = this.getEnvelopePeriod();\n\n      if(this.envelopeDecayLevelCounter > 0)\n        this.envelopeDecayLevelCounter--;\n      else if(this.envelopeDecayLevelCounter === 0 && this.disabledLengthCounter() === true)\n        this.envelopeDecayLevelCounter = 0xF;\n    }\n  },\n\n  /**\n   *\n   */\n  driveLength: function() {\n    if(this.disabledLengthCounter() === false && this.lengthCounter > 0)\n      this.lengthCounter--;\n  },\n\n  /**\n   *\n   */\n  output: function() {\n    if(this.lengthCounter === 0 || (this.shiftRegister & 1) === 1)\n      return 0;\n\n    // 4-bit output\n\n    return (this.disabledEnvelope() === true ? this.getEnvelopePeriod() : this.envelopeDecayLevelCounter) & 0xF;\n  }\n});\n\n/**\n * Apu DMC channel. Consists of\n *   - Timer\n *   - Memory reader\n *   - Sample buffer\n *   - Output unit\n */\nfunction ApuDmc(apu) {\n  this.apu = apu;\n\n  // 0x4010\n  //\n  // bit:\n  //   7: IRQ enable\n  //   6: Loop\n  // 3-0: Timer index\n\n  // 0x4011\n  //\n  // bit:\n  // 6-0: Delta counter\n  // Unused\n\n  // 0x4012\n  //\n  // bit:\n  // 7-0: Sample address\n\n  // 0x4013\n  //\n  // bit:\n  // 7-0: Sample length\n\n  this.register0 = new Register8bit();  // 0x4010\n  this.register1 = new Register8bit();  // 0x4011\n  this.register2 = new Register8bit();  // 0x4012\n  this.register3 = new Register8bit();  // 0x4013\n\n  //\n\n  this.enabled = false;\n\n  //\n\n  this.timerPeriod = 0;\n  this.timerCounter = 0;\n\n  this.deltaCounter = 0;\n  this.addressCounter = 0;\n  this.remainingBytesCounter = 0;\n\n  this.sampleBuffer = 0;  // 8-bit\n  this.sampleBufferIsEmpty = true;\n\n  this.shiftRegister = 0;\n  this.remainingBitsCounter = 0;\n\n  this.silenceFlag = true;\n}\n\nObject.assign(ApuDmc.prototype, {\n  isApuDmc: true,\n\n  //\n\n  TIMER_TABLE: [\n    0x1AC, 0x17C, 0x154, 0x140,\n    0x11E, 0x0FE, 0x0E2, 0x0D6,\n    0x0BE, 0x0A0, 0x08E, 0x080,\n    0x06A, 0x054, 0x048, 0x036\n  ],\n\n  //\n\n  /**\n   *\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n      case 0x4010:\n        this.register0.store(value);\n        this.timerPeriod = this.TIMER_TABLE[this.getTimerIndex()] >> 1;\n\n        break;\n\n      case 0x4011:\n        this.register1.store(value);\n        this.start();\n\n        break;\n\n      case 0x4012:\n        this.register2.store(value);\n        this.start();\n\n        break;\n\n      case 0x4013:\n        this.register3.store(value);\n        this.start();\n\n        break;\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  setEnable: function(enabled) {\n    this.enabled = enabled;\n\n    // If DMC enable flag is set via 0x4015,\n    // the DMC sample will be restarted only if its remaining bytes is 0.\n\n    if(enabled === true) {\n      if(this.remainingBytesCounter === 0)\n        this.start();\n    } else {\n      this.remainingBytesCounter = 0;\n    }\n  },\n\n  /**\n   *\n   */\n  start: function() {\n    this.deltaCounter = this.getDeltaCounter();\n    this.addressCounter = this.getSampleAddress() * 0x40 + 0xC000;\n    this.remainingBytesCounter = this.getSampleLength() * 0x10 + 1;\n  },\n\n  /**\n   *\n   */\n  enabledIrq: function() {\n    return this.register0.isBitSet(7);\n  },\n\n  /**\n   *\n   */\n  isLoop: function() {\n    return this.register0.isBitSet(6);\n  },\n\n  /**\n   *\n   */\n  getTimerIndex: function() {\n    return this.register0.loadBits(0, 4);\n  },\n\n  /**\n   *\n   */\n  getDeltaCounter: function() {\n    return this.register1.loadBits(0, 7);\n  },\n\n  /**\n   *\n   */\n  getSampleAddress: function() {\n    return this.register2.load();\n  },\n\n  /**\n   *\n   */\n  getSampleLength: function() {\n    return this.register3.load();\n  },\n\n  //\n\n  /**\n   *\n   */\n  driveTimer: function() {\n    if(this.timerCounter > 0) {\n      this.timerCounter--;\n    } else {\n      this.timerCounter = this.timerPeriod;\n\n      // Memory reader\n\n      if(this.remainingBytesCounter > 0 && this.sampleBufferIsEmpty === true) {\n        this.sampleBuffer = this.apu.cpu.load(this.sampleAddress++);\n        this.sampleBufferIsEmpty = false;\n\n        // if address exceeds 0xFFFF, it is wrapped around to 0x8000.\n\n        if(this.sampleAddress > 0xFFFF)\n          this.sampleAddress = 0x8000;\n\n        this.remainingBytesCounter--;\n\n        // If the bytes remaining counter becomes zero\n        //   - the sample is restarted if the loop flag is set\n        //   - otherwise, the interrupt flag is set if IRQ enabled flag is set\n\n        if(this.remainingBytesCounter === 0) {\n          if(this.isLoop() === true) {\n            this.start();\n          } else {\n            if(this.enabledIrq() === true)\n              this.apu.dmcIrqActive = true;\n          }\n        }\n\n        // The CPU is stalled for up to 4 CPU cycles\n\n        this.apu.cpu.stallCycle += 4;\n      }\n\n      // Output unit\n\n      if(this.remainingBitsCounter === 0) {\n        this.remainingBitsCounter = 8;\n\n        if(this.sampleBufferIsEmpty === true) {\n          this.silenceFlag = true;\n        } else {\n          this.silenceFlag = false;\n          this.sampleBufferIsEmpty = true;\n          this.shiftRegister = this.sampleBuffer;\n          this.sampleBuffer = 0;\n        }\n      }\n\n      if(this.silenceFlag === false) {\n        if((this.shiftRegister & 1) === 0) {\n          if(this.deltaCounter > 1)\n            this.deltaCounter -= 2;\n        } else {\n          if(this.deltaCounter < 126)\n            this.deltaCounter += 2;\n        }\n      }\n\n      this.shiftRegister = this.shiftRegister >> 1;\n      this.remainingBitsCounter--;\n    }\n  },\n\n  /**\n   *\n   */\n  output: function() {\n\n    // Seems like we should ignore enable bit set via 0x4015\n    // (or no enable bit in DMC unit?)\n\n    //if(this.enabled === false)\n    //  return 0;\n\n    if(this.silenceFlag === true)\n      return 0;\n\n    // 7-bit output\n\n    return this.deltaCounter & 0x7F;\n  }\n});\n\n/**\n *\n */\nfunction ApuStatusRegister() {\n  Register8bit.call(this);\n}\n\nApuStatusRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isApuStatusRegister: true,\n\n  //\n\n  ENABLE_DMC_BIT: 4,\n  ENABLE_NOISE_BIT: 3,\n  ENABLE_TRIANGLE_BIT: 2,\n  ENABLE_PULSE2_BIT: 1,\n  ENABLE_PULSE1_BIT: 0\n});\n\n/**\n *\n */\nfunction ApuFrameRegister() {\n  Register8bit.call(this);\n}\n\nApuFrameRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isApuFrameRegister: true,\n\n  //\n\n  MODE_BIT: 7,\n  IRQ_BIT: 6,\n\n  //\n\n  /**\n   *\n   */\n  isFiveStepMode: function() {\n    return this.isBitSet(this.MODE_BIT);\n  },\n\n  /**\n   *\n   */\n  disabledIrq: function() {\n    return this.isBitSet(this.IRQ_BIT);\n  }\n});\n\n module.exports = {Apu};",
			args: ["Register8bit"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -60.0434276625365,
			y: -835.3081644755597,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 75,
		id: "nodular_1694680842836",
		type: "Function",
		position: {
			x: -416.01442324022946,
			y: -143.72291454497883,
		},
		data: {
			label: "Display.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Display"],
			loading: false,
			func: "/**\n *\n */\nfunction Display(canvas) {\n  this.ctx = canvas.getContext('2d');\n\n  this.width = canvas.width = 256;\n  this.height = canvas.height = 240;\n\n  this.data = this.ctx.createImageData(this.width, this.height);\n  this.uint32 = new Uint32Array(this.data.data.buffer);\n}\n\nObject.assign(Display.prototype, {\n  isDisplay: true,\n\n  /**\n   *\n   */\n  renderPixel: function(x, y, c) {\n    var index = y * this.width + x;\n    this.uint32[index] = c;\n  },\n\n  /**\n   *\n   */\n  updateScreen: function() {\n    this.ctx.putImageData(this.data, 0, 0);\n  }\n});\n\n module.exports = {Display};",
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -416.01442324022946,
			y: -143.72291454497883,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 239,
		id: "nodular_1694680843696",
		type: "Function",
		position: {
			x: 177.00480532585647,
			y: -588.018785675443,
		},
		data: {
			label: "Cpu.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Cpu"],
			loading: false,
			func: "\n\n/**\n * Ricoh 6502\n * Refer to https://wiki.nesdev.com/w/index.php/CPU\n */\nfunction Cpu() {\n\n  // registers\n\n  this.pc = new Register16bit();\n  this.sp = new Register8bit();\n  this.a = new Register8bit();\n  this.x = new Register8bit();\n  this.y = new Register8bit();\n  this.p = new CpuStatusRegister();\n\n  // CPU inside RAM\n\n  this.ram = new Memory(64 * 1024);  // 64KB\n\n  // other devices\n\n  this.ppu = null;  // set by setPpu()\n  this.apu = null;  // set by setApu()\n  this.pad1 = null; // set by setJoypad1()\n  this.pad2 = null; // set by setJoypad2()\n\n  // cartridge ROM\n\n  this.rom = null;  // set by setRom()\n\n  // Executing an instruction takes 1, 2, or more cycles.\n  // .stallCycle represents the number of cycles left to\n  // complete the currently executed instruction.\n\n  this.stallCycle = 0;\n}\n\n// Interrups\n\nCpu.INTERRUPTS = {\n  NMI:   0,\n  RESET: 1,\n  IRQ:   2,\n  BRK:   3  // not interrupt but instruction\n};\n\nCpu.INTERRUPT_HANDLER_ADDRESSES = [];\nCpu.INTERRUPT_HANDLER_ADDRESSES[Cpu.INTERRUPTS.NMI]   = 0xFFFA;\nCpu.INTERRUPT_HANDLER_ADDRESSES[Cpu.INTERRUPTS.RESET] = 0xFFFC;\nCpu.INTERRUPT_HANDLER_ADDRESSES[Cpu.INTERRUPTS.IRQ]   = 0xFFFE;\nCpu.INTERRUPT_HANDLER_ADDRESSES[Cpu.INTERRUPTS.BRK]   = 0xFFFE;\n\n// Instructions\n\nCpu.INSTRUCTIONS = {\n  INV: {'id':  0, 'name': 'inv'}, // Invalid\n  ADC: {'id':  1, 'name': 'adc'},\n  AND: {'id':  2, 'name': 'and'},\n  ASL: {'id':  3, 'name': 'asl'},\n  BCC: {'id':  4, 'name': 'bcc'},\n  BCS: {'id':  5, 'name': 'bcs'},\n  BEQ: {'id':  6, 'name': 'beq'},\n  BIT: {'id':  7, 'name': 'bit'},\n  BMI: {'id':  8, 'name': 'bmi'},\n  BNE: {'id':  9, 'name': 'bne'},\n  BPL: {'id': 10, 'name': 'bpl'},\n  BRK: {'id': 11, 'name': 'brk'},\n  BVC: {'id': 12, 'name': 'bvc'},\n  BVS: {'id': 13, 'name': 'bvs'},\n  CLC: {'id': 14, 'name': 'clc'},\n  CLD: {'id': 15, 'name': 'cld'},\n  CLI: {'id': 16, 'name': 'cli'},\n  CLV: {'id': 17, 'name': 'clv'},\n  CMP: {'id': 18, 'name': 'cmp'},\n  CPX: {'id': 19, 'name': 'cpx'},\n  CPY: {'id': 20, 'name': 'cpy'},\n  DEC: {'id': 21, 'name': 'dec'},\n  DEX: {'id': 22, 'name': 'dex'},\n  DEY: {'id': 23, 'name': 'dey'},\n  EOR: {'id': 24, 'name': 'eor'},\n  INC: {'id': 25, 'name': 'inc'},\n  INX: {'id': 26, 'name': 'inx'},\n  INY: {'id': 27, 'name': 'iny'},\n  JMP: {'id': 28, 'name': 'jmp'},\n  JSR: {'id': 29, 'name': 'jsr'},\n  LDA: {'id': 30, 'name': 'lda'},\n  LDX: {'id': 31, 'name': 'ldx'},\n  LDY: {'id': 32, 'name': 'ldy'},\n  LSR: {'id': 33, 'name': 'lsr'},\n  NOP: {'id': 34, 'name': 'nop'},\n  ORA: {'id': 35, 'name': 'ora'},\n  PHA: {'id': 36, 'name': 'pha'},\n  PHP: {'id': 37, 'name': 'php'},\n  PLA: {'id': 38, 'name': 'pla'},\n  PLP: {'id': 39, 'name': 'plp'},\n  ROL: {'id': 40, 'name': 'rol'},\n  ROR: {'id': 41, 'name': 'ror'},\n  RTI: {'id': 42, 'name': 'rti'},\n  RTS: {'id': 43, 'name': 'rts'},\n  SBC: {'id': 44, 'name': 'sbc'},\n  SEC: {'id': 45, 'name': 'sec'},\n  SED: {'id': 46, 'name': 'sed'},\n  SEI: {'id': 47, 'name': 'sei'},\n  STA: {'id': 48, 'name': 'sta'},\n  STX: {'id': 49, 'name': 'stx'},\n  STY: {'id': 50, 'name': 'sty'},\n  TAX: {'id': 51, 'name': 'tax'},\n  TAY: {'id': 52, 'name': 'tay'},\n  TSX: {'id': 53, 'name': 'tsx'},\n  TXA: {'id': 54, 'name': 'txa'},\n  TXS: {'id': 55, 'name': 'txs'},\n  TYA: {'id': 56, 'name': 'tya'}\n};\n\n// Addressing modes\n\nCpu.ADDRESSINGS = {\n  IMMEDIATE:           {'id':  0, 'pc': 2, 'name': 'immediate'},\n  ABSOLUTE:            {'id':  1, 'pc': 3, 'name': 'absolute'},\n  INDEXED_ABSOLUTE_X:  {'id':  2, 'pc': 3, 'name': 'indexed_absolute_x'},\n  INDEXED_ABSOLUTE_Y:  {'id':  3, 'pc': 3, 'name': 'indexed_absolute_y'},\n  ZERO_PAGE:           {'id':  4, 'pc': 2, 'name': 'zero_page'},\n  INDEXED_ZERO_PAGE_X: {'id':  5, 'pc': 2, 'name': 'indexed_zero_page_x'},\n  INDEXED_ZERO_PAGE_Y: {'id':  6, 'pc': 2, 'name': 'indexed_zero_page_y'},\n  IMPLIED:             {'id':  7, 'pc': 1, 'name': 'implied'},\n  ACCUMULATOR:         {'id':  8, 'pc': 1, 'name': 'accumulator'},\n  INDIRECT:            {'id':  9, 'pc': 3, 'name': 'indirect'},\n  INDEXED_INDIRECT_X:  {'id': 10, 'pc': 2, 'name': 'indexed_indirect_x'},\n  INDEXED_INDIRECT_Y:  {'id': 11, 'pc': 2, 'name': 'indexed_indirect_y'},\n  RELATIVE:            {'id': 12, 'pc': 2, 'name': 'relative'}\n};\n\n// Operations (the combinations of interuction and addressing mode)\n// Decoding in advance because it's much easier than implementing decoder.\n\nCpu.OPS = [\n  /* 0x00 */ {'instruction': Cpu.INSTRUCTIONS.BRK, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x01 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0x02 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x03 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x04 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x05 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x06 */ {'instruction': Cpu.INSTRUCTIONS.ASL, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x07 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x08 */ {'instruction': Cpu.INSTRUCTIONS.PHP, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x09 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0x0A */ {'instruction': Cpu.INSTRUCTIONS.ASL, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.ACCUMULATOR},\n  /* 0x0B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x0C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x0D */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x0E */ {'instruction': Cpu.INSTRUCTIONS.ASL, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x0F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x10 */ {'instruction': Cpu.INSTRUCTIONS.BPL, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0x11 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0x12 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x13 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x14 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x15 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x16 */ {'instruction': Cpu.INSTRUCTIONS.ASL, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x17 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x18 */ {'instruction': Cpu.INSTRUCTIONS.CLC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x19 */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0x1A */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x1B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x1C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x1D */ {'instruction': Cpu.INSTRUCTIONS.ORA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x1E */ {'instruction': Cpu.INSTRUCTIONS.ASL, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x1F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x20 */ {'instruction': Cpu.INSTRUCTIONS.JSR, 'cycle': 0, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x21 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0x22 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x23 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x24 */ {'instruction': Cpu.INSTRUCTIONS.BIT, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x25 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x26 */ {'instruction': Cpu.INSTRUCTIONS.ROL, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x27 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x28 */ {'instruction': Cpu.INSTRUCTIONS.PLP, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x29 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0x2A */ {'instruction': Cpu.INSTRUCTIONS.ROL, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.ACCUMULATOR},\n  /* 0x2B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x2C */ {'instruction': Cpu.INSTRUCTIONS.BIT, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x2D */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x2E */ {'instruction': Cpu.INSTRUCTIONS.ROL, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x2F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x30 */ {'instruction': Cpu.INSTRUCTIONS.BMI, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0x31 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0x32 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x33 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x34 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x35 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x36 */ {'instruction': Cpu.INSTRUCTIONS.ROL, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x37 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x38 */ {'instruction': Cpu.INSTRUCTIONS.SEC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x39 */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0x3A */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x3B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x3C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x3D */ {'instruction': Cpu.INSTRUCTIONS.AND, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x3E */ {'instruction': Cpu.INSTRUCTIONS.ROL, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x3F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x40 */ {'instruction': Cpu.INSTRUCTIONS.RTI, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x41 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0x42 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x43 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x44 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x45 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x46 */ {'instruction': Cpu.INSTRUCTIONS.LSR, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x47 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x48 */ {'instruction': Cpu.INSTRUCTIONS.PHA, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x49 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0x4A */ {'instruction': Cpu.INSTRUCTIONS.LSR, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.ACCUMULATOR},\n  /* 0x4B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x4C */ {'instruction': Cpu.INSTRUCTIONS.JMP, 'cycle': 0, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x4D */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x4E */ {'instruction': Cpu.INSTRUCTIONS.LSR, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x4F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x50 */ {'instruction': Cpu.INSTRUCTIONS.BVC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0x51 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0x52 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x53 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x54 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x55 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x56 */ {'instruction': Cpu.INSTRUCTIONS.LSR, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x57 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x58 */ {'instruction': Cpu.INSTRUCTIONS.CLI, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x59 */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0x5A */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x5B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x5C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x5D */ {'instruction': Cpu.INSTRUCTIONS.EOR, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x5E */ {'instruction': Cpu.INSTRUCTIONS.LSR, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x5F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x60 */ {'instruction': Cpu.INSTRUCTIONS.RTS, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x61 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0x62 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x63 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x64 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x65 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x66 */ {'instruction': Cpu.INSTRUCTIONS.ROR, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x67 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x68 */ {'instruction': Cpu.INSTRUCTIONS.PLA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x69 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0x6A */ {'instruction': Cpu.INSTRUCTIONS.ROR, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.ACCUMULATOR},\n  /* 0x6B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x6C */ {'instruction': Cpu.INSTRUCTIONS.JMP, 'cycle': 0, 'mode': Cpu.ADDRESSINGS.INDIRECT},\n  /* 0x6D */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x6E */ {'instruction': Cpu.INSTRUCTIONS.ROR, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x6F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x70 */ {'instruction': Cpu.INSTRUCTIONS.BVS, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0x71 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0x72 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x73 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x74 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x75 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x76 */ {'instruction': Cpu.INSTRUCTIONS.ROR, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x77 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x78 */ {'instruction': Cpu.INSTRUCTIONS.SEI, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x79 */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0x7A */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x7B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x7C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x7D */ {'instruction': Cpu.INSTRUCTIONS.ADC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x7E */ {'instruction': Cpu.INSTRUCTIONS.ROR, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x7F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x80 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x81 */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0x82 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x83 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x84 */ {'instruction': Cpu.INSTRUCTIONS.STY, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x85 */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x86 */ {'instruction': Cpu.INSTRUCTIONS.STX, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0x87 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x88 */ {'instruction': Cpu.INSTRUCTIONS.DEY, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x89 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x8A */ {'instruction': Cpu.INSTRUCTIONS.TXA, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x8B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x8C */ {'instruction': Cpu.INSTRUCTIONS.STY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x8D */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x8E */ {'instruction': Cpu.INSTRUCTIONS.STX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0x8F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x90 */ {'instruction': Cpu.INSTRUCTIONS.BCC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0x91 */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0x92 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x93 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x94 */ {'instruction': Cpu.INSTRUCTIONS.STY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x95 */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0x96 */ {'instruction': Cpu.INSTRUCTIONS.STX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_Y},\n  /* 0x97 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0x98 */ {'instruction': Cpu.INSTRUCTIONS.TYA, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x99 */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0x9A */ {'instruction': Cpu.INSTRUCTIONS.TXS, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0x9B */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x9C */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x9D */ {'instruction': Cpu.INSTRUCTIONS.STA, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0x9E */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0x9F */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xA0 */ {'instruction': Cpu.INSTRUCTIONS.LDY, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xA1 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0xA2 */ {'instruction': Cpu.INSTRUCTIONS.LDX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xA3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xA4 */ {'instruction': Cpu.INSTRUCTIONS.LDY, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xA5 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xA6 */ {'instruction': Cpu.INSTRUCTIONS.LDX, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xA7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xA8 */ {'instruction': Cpu.INSTRUCTIONS.TAY, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xA9 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xAA */ {'instruction': Cpu.INSTRUCTIONS.TAX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xAB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xAC */ {'instruction': Cpu.INSTRUCTIONS.LDY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xAD */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xAE */ {'instruction': Cpu.INSTRUCTIONS.LDX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xAF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xB0 */ {'instruction': Cpu.INSTRUCTIONS.BCS, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0xB1 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0xB2 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xB3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xB4 */ {'instruction': Cpu.INSTRUCTIONS.LDY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xB5 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xB6 */ {'instruction': Cpu.INSTRUCTIONS.LDX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_Y},\n  /* 0xB7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xB8 */ {'instruction': Cpu.INSTRUCTIONS.CLV, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xB9 */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0xBA */ {'instruction': Cpu.INSTRUCTIONS.TSX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xBB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xBC */ {'instruction': Cpu.INSTRUCTIONS.LDY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xBD */ {'instruction': Cpu.INSTRUCTIONS.LDA, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xBE */ {'instruction': Cpu.INSTRUCTIONS.LDX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0xBF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xC0 */ {'instruction': Cpu.INSTRUCTIONS.CPY, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xC1 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0xC2 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xC3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xC4 */ {'instruction': Cpu.INSTRUCTIONS.CPY, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xC5 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xC6 */ {'instruction': Cpu.INSTRUCTIONS.DEC, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xC7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xC8 */ {'instruction': Cpu.INSTRUCTIONS.INY, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xC9 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xCA */ {'instruction': Cpu.INSTRUCTIONS.DEX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xCB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xCC */ {'instruction': Cpu.INSTRUCTIONS.CPY, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xCD */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xCE */ {'instruction': Cpu.INSTRUCTIONS.DEC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xCF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xD0 */ {'instruction': Cpu.INSTRUCTIONS.BNE, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0xD1 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0xD2 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xD3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xD4 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xD5 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xD6 */ {'instruction': Cpu.INSTRUCTIONS.DEC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xD7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xD8 */ {'instruction': Cpu.INSTRUCTIONS.CLD, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xD9 */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0xDA */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xDB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xDC */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xDD */ {'instruction': Cpu.INSTRUCTIONS.CMP, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xDE */ {'instruction': Cpu.INSTRUCTIONS.DEC, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xDF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xE0 */ {'instruction': Cpu.INSTRUCTIONS.CPX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xE1 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_X},\n  /* 0xE2 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xE3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xE4 */ {'instruction': Cpu.INSTRUCTIONS.CPX, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xE5 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 3, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xE6 */ {'instruction': Cpu.INSTRUCTIONS.INC, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.ZERO_PAGE},\n  /* 0xE7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xE8 */ {'instruction': Cpu.INSTRUCTIONS.INX, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xE9 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMMEDIATE},\n  /* 0xEA */ {'instruction': Cpu.INSTRUCTIONS.NOP, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xEB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xEC */ {'instruction': Cpu.INSTRUCTIONS.CPX, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xED */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xEE */ {'instruction': Cpu.INSTRUCTIONS.INC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.ABSOLUTE},\n  /* 0xEF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xF0 */ {'instruction': Cpu.INSTRUCTIONS.BEQ, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.RELATIVE},\n  /* 0xF1 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 5, 'mode': Cpu.ADDRESSINGS.INDEXED_INDIRECT_Y},\n  /* 0xF2 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xF3 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xF4 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xF5 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xF6 */ {'instruction': Cpu.INSTRUCTIONS.INC, 'cycle': 6, 'mode': Cpu.ADDRESSINGS.INDEXED_ZERO_PAGE_X},\n  /* 0xF7 */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n\n  /* 0xF8 */ {'instruction': Cpu.INSTRUCTIONS.SED, 'cycle': 2, 'mode': Cpu.ADDRESSINGS.IMPLIED},\n  /* 0xF9 */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_Y},\n  /* 0xFA */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xFB */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xFC */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null},\n  /* 0xFD */ {'instruction': Cpu.INSTRUCTIONS.SBC, 'cycle': 4, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xFE */ {'instruction': Cpu.INSTRUCTIONS.INC, 'cycle': 7, 'mode': Cpu.ADDRESSINGS.INDEXED_ABSOLUTE_X},\n  /* 0xFF */ {'instruction': Cpu.INSTRUCTIONS.INV, 'cycle': 0, 'mode': null}\n];\n\nObject.assign(Cpu.prototype, {\n  isCpu: true,\n\n  //\n\n  INTERRUPTS: Cpu.INTERRUPTS,\n  INTERRUPT_HANDLER_ADDRESSES: Cpu.INTERRUPT_HANDLER_ADDRESSES,\n  ADDRESSINGS: Cpu.ADDRESSINGS,\n  INSTRUCTIONS: Cpu.INSTRUCTIONS,\n  OPS: Cpu.OPS,\n\n  // public methods\n\n  // set methods\n\n  /**\n   *\n   */\n  setPpu: function(ppu) {\n    this.ppu = ppu;\n  },\n\n  /**\n   *\n   */\n  setApu: function(apu) {\n    this.apu = apu;\n  },\n\n  /**\n   *\n   */\n  setJoypad1: function(pad1) {\n    this.pad1 = pad1;\n  },\n\n  /**\n   *\n   */\n  setJoypad2: function(pad2) {\n    this.pad2 = pad2;\n  },\n\n  /**\n   *\n   */\n  setRom: function(rom) {\n    this.rom = rom;\n  },\n\n  //\n\n  /**\n   * Refer to https://wiki.nesdev.com/w/index.php/CPU_power_up_state\n   */\n  bootup: function() {\n    this.p.store(0x34);\n    this.a.clear();\n    this.x.clear();\n    this.y.clear();\n    this.sp.store(0xFD);\n\n    for(var i = 0; i < 0xF; i++)\n      this.store(0x4000 + i, 0);\n\n    this.store(0x4015, 0);\n    this.store(0x4017, 0);\n\n    this.interrupt(this.INTERRUPTS.RESET);\n  },\n\n  /**\n   * Refer to https://wiki.nesdev.com/w/index.php/CPU_power_up_state\n   */\n  reset: function() {\n    this.sp.sub(3);\n    this.p.setI();\n    this.interrupt(this.INTERRUPTS.RESET);\n  },\n\n  /**\n   *\n   */\n  runCycle: function() {\n    if(this.isStall() !== true) {\n      var opc = this.fetch();\n      var op = this.decode(opc);\n\n      this.operate(op, opc);\n      this.stallCycle = op.cycle;\n    }\n\n    this.stallCycle--;\n  },\n\n  /**\n   *\n   */\n  isStall: function() {\n    return this.stallCycle > 0;\n  },\n\n  /**\n   *\n   */\n  interrupt: function(type) {\n    if(type === this.INTERRUPTS.IRQ && this.p.isI() === true)\n      return;\n\n    if(type !== this.INTERRUPTS.RESET) {\n      if(type !== this.INTERRUPTS.BRK)\n        this.p.clearB();\n\n      this.p.setA();\n\n      this.pushStack2Bytes(this.pc.load());\n      this.pushStack(this.p.load());\n      this.p.setI();\n    }\n\n    this.jumpToInterruptHandler(type);\n  },\n\n  // load/store methods\n\n  /**\n   *\n   */\n  load: function(address) {\n    address = address & 0xFFFF;  // just in case\n\n    // 0x0000 - 0x07FF: 2KB internal RAM\n    // 0x0800 - 0x1FFF: Mirrors of 0x0000 - 0x07FF (repeats every 0x800 bytes)\n\n    if(address >= 0 && address < 0x2000)\n      return this.ram.load(address & 0x07FF);\n\n    // 0x2000 - 0x2007: PPU registers\n    // 0x2008 - 0x3FFF: Mirrors of 0x2000 - 0x2007 (repeats every 8 bytes)\n\n    if(address >= 0x2000 && address < 0x4000)\n      return this.ppu.loadRegister(address & 0x2007);\n\n    // 0x4000 - 0x4017: APU, PPU and I/O registers\n    // 0x4018 - 0x401F: APU and I/O functionality that is normally disabled\n\n    if(address >= 0x4000 && address < 0x4014)\n      return this.apu.loadRegister(address);\n\n    if(address === 0x4014)\n      return this.ppu.loadRegister(address);\n\n    if(address === 0x4015)\n      return this.apu.loadRegister(address);\n\n    if(address === 0x4016)\n      return this.pad1.loadRegister();\n\n    if(address >= 0x4017 && address < 0x4020)\n      return this.apu.loadRegister(address);\n\n    // cartridge space\n\n    if(address >= 0x4020 && address < 0x6000)\n      return this.ram.load(address);\n\n    // 0x6000 - 0x7FFF: Battery Backed Save or Work RAM\n\n    if(address >= 0x6000 && address < 0x8000)\n      return this.ram.load(address);\n\n    // 0x8000 - 0xFFFF: ROM\n    if(address >= 0x8000 && address < 0x10000)\n      return this.rom.load(address);\n  },\n\n  /**\n   *\n   */\n  store: function(address, value) {\n    address = address & 0xFFFF;  // just in case\n\n    // 0x0000 - 0x07FF: 2KB internal RAM\n    // 0x0800 - 0x1FFF: Mirrors of 0x0000 - 0x07FF (repeats every 0x800 bytes)\n\n    if(address >= 0 && address < 0x2000)\n      return this.ram.store(address & 0x07FF, value);\n\n    // 0x2000 - 0x2007: PPU registers\n    // 0x2008 - 0x3FFF: Mirrors of 0x2000 - 0x2007 (repeats every 8 bytes)\n\n    if(address >= 0x2000 && address < 0x4000)\n      return this.ppu.storeRegister(address & 0x2007, value);\n\n    // 0x4000 - 0x4017: APU, PPU and I/O registers\n    // 0x4018 - 0x401F: APU and I/O functionality that is normally disabled\n\n    if(address >= 0x4000 && address < 0x4014)\n      return this.apu.storeRegister(address, value);\n\n    if(address === 0x4014)\n      return this.ppu.storeRegister(address, value);\n\n    if(address === 0x4015)\n      return this.apu.storeRegister(address, value);\n\n    if(address === 0x4016)\n      return this.pad1.storeRegister(value);\n\n    if(address >= 0x4017 && address < 0x4020)\n      return this.apu.storeRegister(address, value);\n\n    // cartridge space\n\n    if(address >= 0x4020 && address < 0x6000)\n      return this.ram.store(address, value);\n\n    // 0x6000 - 0x7FFF: Battery Backed Save or Work RAM\n\n    if(address >= 0x6000 && address < 0x8000)\n      return this.ram.store(address, value);\n\n    // 0x8000 - 0xFFFF: ROM\n    if(address >= 0x8000 && address < 0x10000)\n      return this.rom.store(address, value);\n  },\n\n  // private methods\n\n  // load/store methods\n\n  /**\n   *\n   */\n  load2Bytes: function(address) {\n    return this.load(address) | (this.load(address + 1) << 8);\n  },\n\n  /**\n   *\n   */\n  load2BytesFromZeropage: function(address) {\n    return this.ram.load(address & 0xff) | (this.ram.load((address + 1) & 0xff) << 8);\n  },\n\n  /**\n   *\n   */\n  load2BytesInPage: function(address) {\n    var addr1 = address;\n    var addr2 = (address & 0xff00) | ((address + 1) & 0xff);\n    return this.load(addr1) | (this.load(addr2) << 8);\n  },\n\n  /**\n   *\n   */\n  store2Bytes: function(address, value) {\n    this.store(address, value);\n    this.store(address + 1, value >> 8);\n  },\n\n  // processing methods\n\n  /**\n   *\n   */\n  fetch: function() {\n    var opc = this.load(this.pc.load());\n    this.pc.increment();\n    return opc;\n  },\n\n  /**\n   *\n   */\n  decode: function(opc) {\n    return this.OPS[opc];\n  },\n\n  /**\n   *\n   */\n  jumpToInterruptHandler: function(type) {\n    this.pc.store(this.load2Bytes(this.INTERRUPT_HANDLER_ADDRESSES[type]));\n  },\n\n  //\n\n  /**\n   *\n   */\n  loadWithAddressingMode: function(op) {\n    if(op.mode.id === this.ADDRESSINGS.ACCUMULATOR.id)\n      return this.a.load();\n\n    var address = this.getAddressWithAddressingMode(op);\n    var value = this.load(address);\n\n    // expects that relative addressing mode is used only for load.\n    if(op.mode.id === this.ADDRESSINGS.RELATIVE.id) {\n      // TODO: confirm if this logic is right.\n      if(value & 0x80)\n        value = value | 0xff00;\n    }\n\n    return value;\n  },\n\n  storeWithAddressingMode: function(op, value) {\n    if(op.mode.id === this.ADDRESSINGS.ACCUMULATOR.id) {\n      this.a.store(value);\n      return;\n    }\n\n    var address = this.getAddressWithAddressingMode(op);\n    this.store(address, value);\n  },\n\n  updateMemoryWithAddressingMode: function(op, func) {\n    var address;\n    var src;\n\n    if(op.mode.id == this.ADDRESSINGS.ACCUMULATOR.id) {\n      src = this.a.load();\n    } else {\n      address = this.getAddressWithAddressingMode(op);\n      src = this.load(address);\n    }\n\n    var result = func(src);\n\n    if(op.mode.id == this.ADDRESSINGS.ACCUMULATOR.id) {\n      this.a.store(result);\n    } else {\n      this.store(address, result);\n    }\n  },\n\n  getAddressWithAddressingMode: function(op) {\n    var address = null;\n\n    switch(op.mode.id) {\n      case this.ADDRESSINGS.IMMEDIATE.id:\n      case this.ADDRESSINGS.RELATIVE.id:\n        address = this.pc.load();\n        this.pc.increment();\n        break;\n\n      case this.ADDRESSINGS.ABSOLUTE.id:\n      case this.ADDRESSINGS.INDEXED_ABSOLUTE_X.id:\n      case this.ADDRESSINGS.INDEXED_ABSOLUTE_Y.id:\n        address = this.load2Bytes(this.pc.load());\n        this.pc.incrementBy2();\n        switch(op.mode.id) {\n          case this.ADDRESSINGS.INDEXED_ABSOLUTE_X.id:\n            address += this.x.load();\n            break;\n          case this.ADDRESSINGS.INDEXED_ABSOLUTE_Y.id:\n            address += this.y.load();\n            break;\n        }\n        address = address & 0xffff;\n        break;\n\n      case this.ADDRESSINGS.ZERO_PAGE.id:\n      case this.ADDRESSINGS.INDEXED_ZERO_PAGE_X.id:\n      case this.ADDRESSINGS.INDEXED_ZERO_PAGE_Y.id:\n        address = this.load(this.pc.load());\n        this.pc.increment();\n        switch(op.mode.id) {\n          case this.ADDRESSINGS.INDEXED_ZERO_PAGE_X.id:\n          address += this.x.load();\n          break;\n          case this.ADDRESSINGS.INDEXED_ZERO_PAGE_Y.id:\n          address += this.y.load();\n          break;\n        }\n        address = address & 0xff;\n        break;\n\n      case this.ADDRESSINGS.INDIRECT.id:\n        var tmp = this.load2Bytes(this.pc.load());\n        this.pc.incrementBy2();\n        address = this.load2BytesInPage(tmp);\n        break;\n\n      case this.ADDRESSINGS.INDEXED_INDIRECT_X.id:\n        var tmp = this.load(this.pc.load());\n        this.pc.increment();\n        tmp += this.x.load();\n        tmp = tmp & 0xff;\n        address = this.load2BytesFromZeropage(tmp);\n        break;\n\n      case this.ADDRESSINGS.INDEXED_INDIRECT_Y.id:\n        var tmp = this.load(this.pc.load());\n        this.pc.increment();\n        address = this.load2BytesFromZeropage(tmp);\n        address += this.y.load();\n        address = address & 0xffff;\n        break;\n\n      default:\n        throw new Error('Cpu: Unkown addressing mode.');\n        break;\n    }\n    return address;\n  },\n\n  /**\n   *\n   */\n  updateN: function(value) {\n    if((value & 0x80) === 0)\n      this.p.clearN();\n    else\n      this.p.setN();\n  },\n\n  /**\n   *\n   */\n  updateZ: function(value) {\n    if((value & 0xff) === 0)\n      this.p.setZ();\n    else\n      this.p.clearZ();\n  },\n\n  /**\n   *\n   */\n  updateC: function(value) {\n    if((value & 0x100) === 0)\n      this.p.clearC();\n    else\n      this.p.setC();\n  },\n\n  getStackAddress: function() {\n    return this.sp.load() + 0x100;\n  },\n\n  pushStack: function(value) {\n    this.store(this.getStackAddress(), value);\n    this.sp.decrement();\n  },\n\n  pushStack2Bytes: function(value) {\n    this.store(this.getStackAddress(), (value >> 8) & 0xff);\n    this.sp.decrement();\n    this.store(this.getStackAddress(), value & 0xff);\n    this.sp.decrement();\n  },\n\n  popStack: function() {\n    this.sp.increment();\n    return this.load(this.getStackAddress());\n  },\n\n  popStack2Bytes: function() {\n    this.sp.increment();\n    var value = this.load(this.getStackAddress());\n    this.sp.increment();\n    return (this.load(this.getStackAddress()) << 8) | value;\n  },\n\n  doBranch: function(op, flag) {\n    var result = this.loadWithAddressingMode(op);\n    if(flag)\n      this.pc.add(result);\n  },\n\n  operate: function(op, opc) {\n    switch(op.instruction.id) {\n      case this.INSTRUCTIONS.ADC.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var c = this.p.isC() ? 1 : 0;\n        var result = src1 + src2 + c;\n        this.a.store(result);\n        this.updateN(result)\n        this.updateZ(result)\n        this.updateC(result)\n        if(!((src1 ^ src2) & 0x80) && ((src2 ^ result) & 0x80))\n          this.p.setV();\n        else\n          this.p.clearV();\n        break;\n\n      case this.INSTRUCTIONS.AND.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var result = src1 & src2;\n        this.a.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.ASL.id:\n        var self = this;\n        var func = function(src) {\n          var result = src << 1;\n          self.updateN(result)\n          self.updateZ(result);\n          self.updateC(result);\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      case this.INSTRUCTIONS.BCC.id:\n        this.doBranch(op, !this.p.isC());\n        break;\n\n      case this.INSTRUCTIONS.BCS.id:\n        this.doBranch(op, this.p.isC());\n        break;\n\n      case this.INSTRUCTIONS.BEQ.id:\n        this.doBranch(op, this.p.isZ());\n        break;\n\n      // TODO: check logic.\n      case this.INSTRUCTIONS.BIT.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var result = src1 & src2;\n        this.updateN(src2);\n        this.updateZ(result);\n        if((src2 & 0x40) == 0)\n          this.p.clearV();\n        else\n          this.p.setV();\n        break;\n\n      case this.INSTRUCTIONS.BMI.id:\n        this.doBranch(op, this.p.isN());\n        break;\n\n      case this.INSTRUCTIONS.BNE.id:\n        this.doBranch(op, !this.p.isZ());\n        break;\n\n      case this.INSTRUCTIONS.BPL.id:\n        this.doBranch(op, !this.p.isN());\n        break;\n\n      case this.INSTRUCTIONS.BRK.id:\n        this.pc.increment(); // seems like necessary\n        this.p.setA();\n        this.p.setB();\n        this.interrupt(this.INTERRUPTS.BRK);\n        break;\n\n      case this.INSTRUCTIONS.BVC.id:\n        this.doBranch(op, !this.p.isV());\n        break;\n\n      case this.INSTRUCTIONS.BVS.id:\n        this.doBranch(op, this.p.isV());\n        break;\n\n      case this.INSTRUCTIONS.CLC.id:\n        this.p.clearC();\n        break;\n\n      case this.INSTRUCTIONS.CLD.id:\n        this.p.clearD();\n        break;\n\n      case this.INSTRUCTIONS.CLI.id:\n        this.p.clearI();\n        break;\n\n      case this.INSTRUCTIONS.CLV.id:\n        this.p.clearV();\n        break;\n\n      // TODO: separate?\n      case this.INSTRUCTIONS.CMP.id:\n      case this.INSTRUCTIONS.CPX.id:\n      case this.INSTRUCTIONS.CPY.id:\n        var src1;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.CMP.id:\n            src1 = this.a.load();\n            break;\n          case this.INSTRUCTIONS.CPX.id:\n            src1 = this.x.load();\n            break;\n          case this.INSTRUCTIONS.CPY.id:\n            src1 = this.y.load();\n            break;\n        }\n        var src2 = this.loadWithAddressingMode(op);\n        var result = src1 - src2;\n        this.updateN(result);\n        this.updateZ(result);\n        if(src1 >= src2)\n          this.p.setC();\n        else\n          this.p.clearC();\n        break;\n\n      case this.INSTRUCTIONS.DEC.id:\n        var self = this;\n        var func = function(src) {\n          var result = src - 1;\n          self.updateN(result);\n          self.updateZ(result);\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      case this.INSTRUCTIONS.DEX.id:\n      case this.INSTRUCTIONS.DEY.id:\n        var reg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.DEX.id:\n            reg = this.x;\n            break;\n          case this.INSTRUCTIONS.DEY.id:\n            reg = this.y;\n            break;\n        }\n        var src1 = reg.load();\n        var result = src1 - 1;\n        reg.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.EOR.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var result = src1 ^ src2;\n        this.a.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.INC.id:\n        var self = this;\n        var func = function(src) {\n          var result = src + 1;\n          self.updateN(result);\n          self.updateZ(result);\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      case this.INSTRUCTIONS.INX.id:\n      case this.INSTRUCTIONS.INY.id:\n        var reg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.INX.id:\n            reg = this.x;\n            break;\n          case this.INSTRUCTIONS.INY.id:\n            reg = this.y;\n            break;\n        }\n        var src1 = reg.load();\n        var result = src1 + 1;\n        reg.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      // TODO: check the logic.\n      case this.INSTRUCTIONS.JMP.id:\n        var address = this.getAddressWithAddressingMode(op);\n        this.pc.store(address);\n        break;\n\n      // TODO: check the logic.\n      case this.INSTRUCTIONS.JSR.id:\n        var address = this.getAddressWithAddressingMode(op);\n        this.pc.decrement();\n        this.pushStack2Bytes(this.pc.load());\n        this.pc.store(address);\n        break;\n\n      case this.INSTRUCTIONS.LDA.id:\n      case this.INSTRUCTIONS.LDX.id:\n      case this.INSTRUCTIONS.LDY.id:\n        var result = this.loadWithAddressingMode(op);\n        var reg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.LDA.id:\n            reg = this.a;\n            break;\n          case this.INSTRUCTIONS.LDX.id:\n            reg = this.x;\n            break;\n          case this.INSTRUCTIONS.LDY.id:\n            reg = this.y;\n            break;\n        }\n        reg.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.LSR.id:\n        var self = this;\n        var func = function(src) {\n          var result = src >> 1;\n          self.p.clearN();\n          self.updateZ(result);\n          if((src & 1) == 0)\n            self.p.clearC();\n          else\n            self.p.setC();\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      case this.INSTRUCTIONS.NOP.id:\n        break;\n\n      case this.INSTRUCTIONS.ORA.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var result = src1 | src2;\n        this.a.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.PHA.id:\n      case this.INSTRUCTIONS.PHP.id:\n        var reg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.PHA.id:\n            reg = this.a;\n            break;\n          case this.INSTRUCTIONS.PHP.id:\n            this.p.setA();\n            this.p.setB();\n            reg = this.p;\n            break;\n        }\n        this.pushStack(reg.load());\n        break;\n\n      case this.INSTRUCTIONS.PLA.id:\n        var result = this.popStack();\n        this.a.store(result);\n        this.updateN(result);\n        this.updateZ(result);\n        break;\n\n      case this.INSTRUCTIONS.PLP.id:\n        this.p.store(this.popStack());\n        break;\n\n      case this.INSTRUCTIONS.ROL.id:\n        var self = this;\n        var func = function(src) {\n          var c = self.p.isC() ? 1 : 0;\n          var result = (src << 1) | c;\n          self.updateN(result);\n          self.updateZ(result);\n          self.updateC(result);\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      case this.INSTRUCTIONS.ROR.id:\n        var self = this;\n        var func = function(src) {\n          var c = self.p.isC() ? 0x80 : 0x00;\n          var result = (src >> 1) | c;\n          self.updateN(result);\n          self.updateZ(result);\n          if((src & 1) == 0)\n            self.p.clearC();\n          else\n            self.p.setC();\n          return result;\n        };\n        this.updateMemoryWithAddressingMode(op, func);\n        break;\n\n      // TODO: check logic.\n      case this.INSTRUCTIONS.RTI.id:\n        this.p.store(this.popStack());\n        this.pc.store(this.popStack2Bytes());\n        break;\n\n      // TODO: check logic.\n      case this.INSTRUCTIONS.RTS.id:\n        this.pc.store(this.popStack2Bytes() + 1);\n        break;\n\n      case this.INSTRUCTIONS.SBC.id:\n        var src1 = this.a.load();\n        var src2 = this.loadWithAddressingMode(op);\n        var c = this.p.isC() ? 0 : 1;\n        var result = src1 - src2 - c;\n        this.a.store(result);\n        this.updateN(result)\n        this.updateZ(result)\n        // TODO: check if this logic is right.\n        if(src1 >= src2 + c) \n          this.p.setC();\n        else\n          this.p.clearC();\n        // TODO: implement right overflow logic.\n        //       this is just a temporal logic.\n        if(((src1 ^ result) & 0x80) && ((src1 ^ src2) & 0x80))\n          this.p.setV();\n        else\n          this.p.clearV();\n        break;\n\n      case this.INSTRUCTIONS.SEC.id:\n        this.p.setC();\n        break;\n\n      case this.INSTRUCTIONS.SED.id:\n        this.p.setD();\n        break;\n\n      case this.INSTRUCTIONS.SEI.id:\n        this.p.setI();\n        break;\n\n      case this.INSTRUCTIONS.STA.id:\n      case this.INSTRUCTIONS.STX.id:\n      case this.INSTRUCTIONS.STY.id:\n        var reg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.STA.id:\n            reg = this.a;\n            break;\n          case this.INSTRUCTIONS.STX.id:\n            reg = this.x;\n            break;\n          case this.INSTRUCTIONS.STY.id:\n            reg = this.y;\n            break;\n        }\n        this.storeWithAddressingMode(op, reg.load());\n        break;\n\n      case this.INSTRUCTIONS.TAX.id:\n      case this.INSTRUCTIONS.TAY.id:\n      case this.INSTRUCTIONS.TSX.id:\n      case this.INSTRUCTIONS.TXA.id:\n      case this.INSTRUCTIONS.TXS.id:\n      case this.INSTRUCTIONS.TYA.id:\n        var srcReg;\n        var desReg;\n        switch(op.instruction.id) {\n          case this.INSTRUCTIONS.TAX.id:\n            srcReg = this.a;\n            desReg = this.x;\n            break;\n          case this.INSTRUCTIONS.TAY.id:\n            srcReg = this.a;\n            desReg = this.y;\n            break;\n          case this.INSTRUCTIONS.TSX.id:\n            srcReg = this.sp;\n            desReg = this.x;\n            break;\n          case this.INSTRUCTIONS.TXA.id:\n            srcReg = this.x;\n            desReg = this.a;\n            break;\n          case this.INSTRUCTIONS.TXS.id:\n            srcReg = this.x;\n            desReg = this.sp;\n            break;\n          case this.INSTRUCTIONS.TYA.id:\n            srcReg = this.y;\n            desReg = this.a;\n            break;\n        }\n        var result = srcReg.load();\n        desReg.store(result);\n        if(op.instruction.id != this.INSTRUCTIONS.TXS.id) {\n          this.updateN(result);\n          this.updateZ(result);\n        }\n        break;\n\n      default:\n        throw new Error('Cpu.operate: Invalid instruction, pc=' + Utility.convertDecToHexString(this.pc.load() - 1) + ' opc=' + Utility.convertDecToHexString(opc, 2) + ' name=' + op.instruction.name);\n        break;\n    }\n  },\n\n  // disassemble method\n\n  disassembleROM: function() {\n    var buffer = '';\n    var rom = this.rom;\n    var pc = rom.getHeaderSize();\n    var previousIsZero = false;\n    var skipZero = false;\n\n    // TODO: temporal\n    while(pc < 0x4010) {\n      var str = '';\n      var opc = rom.loadWithoutMapping(pc);\n      var op = this.decode(opc);\n\n      if(previousIsZero && opc == 0 && rom.loadWithoutMapping((pc+1)&0xffff) == 0) {\n        pc += 1;\n        skipZero = true;\n        continue;\n      }\n\n      if(skipZero)\n        buffer += '...\\n';\n      skipZero = false;\n\n      str += Utility.convertDecToHexString(pc - rom.getHeaderSize(), 4) + ' ';\n      str += Utility.convertDecToHexString(opc, 2) + ' ';\n      str += op.instruction.name + ' ';\n      str += this.dumpMemoryAddressingMode(op,\n                                           rom,\n                                           (pc + 1) & 0xffff)\n             + ' ';\n\n      while(str.length < 30) {\n        str += ' ' ;\n      }\n\n      if(op.mode) {\n        str += op.mode.name;\n        pc += op.mode.pc;\n      } else {\n        pc += 1;\n      }\n\n      buffer += str + '\\n';\n      previousIsZero = opc == 0;\n    }\n    return buffer;\n  },\n\n  // dump methods\n\n  dump: function() {\n    var buffer = '';\n    var opc = this.load(this.pc.load());\n    var op = this.decode(opc);\n\n    buffer += 'p:'  + this.p.dump()  + ' ';\n    buffer += 'pc:' + this.pc.dump() + '(' + Utility.convertDecToHexString(opc, 2) + ')' + ' ';\n    buffer += 'sp:' + this.sp.dump() + ' ';\n    buffer += 'a:'  + this.a.dump()  + ' ';\n    buffer += 'x:'  + this.x.dump()  + ' ';\n    buffer += 'y:'  + this.y.dump()  + ' ';\n\n    buffer += op.instruction.name + ' ' +\n                this.dumpMemoryAddressingMode(op,\n                                              this,\n                                              (this.pc.load() + 1) & 0xffff)\n                + ' ';\n\n    while(buffer.length < 90) {\n      buffer += ' ' ;\n    }\n\n    buffer += op.mode.name;\n\n    return buffer;\n  },\n\n  dumpRAM: function() {\n    return this.ram.dump();\n  },\n\n  dumpMemoryAddressingMode: function(op, mem, pc) {\n    var buffer = '';\n    var ramDump = (mem instanceof Cpu) ? true : false;\n\n    switch(op.mode) {\n      case this.ADDRESSINGS.IMMEDIATE:\n        buffer += '#' + Utility.convertDecToHexString(mem.load(pc, true), 2);\n        break;\n\n      case this.ADDRESSINGS.RELATIVE:\n        var value = mem.load(pc, true);\n        if(value & 0x80) {\n          value = -(0x100 - value); // make negative native integer.\n        }\n        buffer += value.toString(10);\n        break;\n\n      case this.ADDRESSINGS.ABSOLUTE:\n        var address = mem.load2Bytes(pc, true);\n        buffer += Utility.convertDecToHexString(address, 4);\n        if(ramDump) {\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_ABSOLUTE_X:\n        var address = mem.load2Bytes(pc, true);\n        buffer += Utility.convertDecToHexString(address, 4) + ',X ';\n        if(ramDump) {\n          address += this.x.load();\n          address = address & 0xffff;\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_ABSOLUTE_Y:\n        var address = mem.load2Bytes(pc, true);\n        buffer += Utility.convertDecToHexString(address, 4) + ',Y ';\n        if(ramDump) {\n          address += this.y.load();\n          address = address & 0xffff;\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.ZERO_PAGE:\n        var address = mem.load(pc, true);\n        buffer += Utility.convertDecToHexString(address, 2);\n        if(ramDump) {\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_ZERO_PAGE_X:\n        var address = mem.load(pc, true);\n        buffer += Utility.convertDecToHexString(address, 2) + ',X ';\n        if(ramDump) {\n          address += this.x.load();\n          address = address & 0xff;\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_ZERO_PAGE_Y:\n        var address = mem.load(pc, true);\n        buffer += Utility.convertDecToHexString(address, 2) + ',Y ';\n        if(ramDump) {\n          address += this.y.load();\n          address = address & 0xff;\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address, true), 2) + ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDIRECT:\n        var address = mem.load2Bytes(pc, true);\n        buffer += Utility.convertDecToHexString(address, 4);\n        if(ramDump) {\n          var address2 = mem.load2Bytes(address, true);\n          buffer += '(';\n          buffer += Utility.convertDecToHexString(address2, 4);\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address2, true), 2) + ')';\n          buffer += ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_INDIRECT_X:\n        var address = mem.load(pc, true);\n        buffer += '(' + Utility.convertDecToHexString(address, 2) + ',X) ';\n        if(ramDump) {\n          address += this.x.load();\n          address = address & 0xffff;\n          var address2 = mem.load2Bytes(address, true);\n          buffer += '(';\n          buffer += Utility.convertDecToHexString(address2, 4);\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address2, true), 2) + ')';\n          buffer += ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.INDEXED_INDIRECT_Y:\n        var address = mem.load(pc, true);\n        buffer += '(' + Utility.convertDecToHexString(address, 2) + '),Y ';\n        if(ramDump) {\n          var address2 = mem.load2BytesFromZeropage(address, true);\n          address2 += this.y.load();\n          address2 = address2 & 0xffff;\n          buffer += '(';\n          buffer += Utility.convertDecToHexString(address2, 4);\n          buffer += '(' + Utility.convertDecToHexString(mem.load(address2, true), 2) + ')';\n          buffer += ')';\n        }\n        break;\n\n      case this.ADDRESSINGS.ACCUMULATOR:\n        if(ramDump) {\n          buffer += 'A(' + Utility.convertDecToHexString(this.a.load(), 2) + ')';\n        }\n        break;\n\n      default:\n        throw new Error('Cpu: Unkown addressing mode.');\n        break;\n    }\n    return buffer;\n  }\n});\n\n/**\n *\n */\nfunction CpuStatusRegister() {\n  Register8bit.call(this);\n}\n\nCpuStatusRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isCpuStatusRegister: true,\n\n  //\n\n  N_BIT: 7,\n  V_BIT: 6,\n  A_BIT: 5,  // unused bit. A is random name\n  B_BIT: 4,\n  D_BIT: 3,\n  I_BIT: 2,\n  Z_BIT: 1,\n  C_BIT: 0,\n\n  //\n\n  isN: function() {\n    return this.isBitSet(this.N_BIT);\n  },\n\n  setN: function() {\n    this.setBit(this.N_BIT);\n  },\n\n  clearN: function() {\n    this.clearBit(this.N_BIT);\n  },\n\n  isV: function() {\n    return this.isBitSet(this.V_BIT);\n  },\n\n  setV: function() {\n    this.setBit(this.V_BIT);\n  },\n\n  clearV: function() {\n    this.clearBit(this.V_BIT);\n  },\n\n  isA: function() {\n    return this.IsBitSet(this.A_BIT);\n  },\n\n  setA: function() {\n    this.setBit(this.A_BIT);\n  },\n\n  clearA: function() {\n    this.clearBit(this.A_BIT);\n  },\n\n  isB: function() {\n    return this.isBitSet(this.B_BIT);\n  },\n\n  setB: function() {\n    this.setBit(this.B_BIT);\n  },\n\n  clearB: function() {\n    this.clearBit(this.B_BIT);\n  },\n\n  isD: function() {\n    return this.isBitSet(this.D_BIT);\n  },\n\n  setD: function() {\n    this.setBit(this.D_BIT);\n  },\n\n  clearD: function() {\n    this.clearBit(this.D_BIT);\n  },\n\n  isI: function() {\n    return this.isBitSet(this.I_BIT);\n  },\n\n  setI: function() {\n    this.setBit(this.I_BIT);\n  },\n\n  clearI: function() {\n    this.clearBit(this.I_BIT);\n  },\n\n  isZ: function() {\n    return this.isBitSet(this.Z_BIT);\n  },\n\n  setZ: function() {\n    this.setBit(this.Z_BIT);\n  },\n\n  clearZ: function() {\n    this.clearBit(this.Z_BIT);\n  },\n\n  isC: function() {\n    return this.isBitSet(this.C_BIT);\n  },\n\n  setC: function() {\n    this.setBit(this.C_BIT);\n  },\n\n  clearC: function() {\n    this.clearBit(this.C_BIT);\n  },\n\n  // dump\n\n  dump: function() {\n    var buffer = '';\n    buffer += Register8bit.prototype.dump.call(this);\n    buffer += '(';\n    buffer += this.isN() ? 'N' : '-';\n    buffer += this.isV() ? 'V' : '-';\n    buffer += this.isB() ? 'B' : '-';\n    buffer += this.isD() ? 'D' : '-';\n    buffer += this.isI() ? 'I' : '-';\n    buffer += this.isZ() ? 'Z' : '-';\n    buffer += this.isC() ? 'C' : '-';\n    buffer += ')';\n    return buffer;\n  }\n});\n module.exports = {Cpu};",
			args: ["Register8bit", "Register16bit", "Memory", "Utility"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 177.00480532585647,
			y: -588.018785675443,
		},
		dragging: false,
	},
	{
		width: 203,
		height: 116,
		id: "nodular_1694680844481",
		type: "Function",
		position: {
			x: -364.7944543836295,
			y: -845.9848882177932,
		},
		data: {
			label: "Register.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Register8bit", "Register16bit"],
			loading: false,
			func: "\n\n\n/**\n * General Register implementation.\n * Specific register for CPU and PPU are implemented in each class.\n */\n\n/**\n *\n */\nfunction Register(type) {\n\tthis.data = new type(1); // Uint8Array or Uint16Array\n\tthis.data[0] = 0;\n}\n\nRegister.TYPE_8BIT = Uint8Array;\nRegister.TYPE_16BIT = Uint16Array;\n\nObject.assign(Register.prototype, {\n\tisRegister: true,\n\n\t/**\n\t *\n\t */\n\tgetWidth: function() {\n\t\treturn this.data.byteLength * 8;\n\t},\n\n\t/**\n\t *\n\t */\n\tload: function() {\n\t\treturn this.data[0];\n\t},\n\n\t/**\n\t *\n\t */\n\tloadBit: function(pos) {\n\t\treturn (this.data[0] >> pos) & 1;\n\t},\n\n\t/**\n\t *\n\t */\n\tloadBits: function(offset, size) {\n\t\treturn (this.data[0] >> offset) & ((1 << size) - 1);\n\t},\n\n\t/**\n\t *\n\t */\n\tstore: function(value) {\n\t\tthis.data[0] = value;\n\t},\n\n\t/**\n\t *\n\t */\n\tstoreBit: function(pos, value) {\n\t\tvalue = value & 1; // just in case\n\t\tthis.data[0] = this.data[0] & ~(1 << pos) | (value << pos);\n\t},\n\n\t/**\n\t *\n\t */\n\tstoreBits: function(offset, size, value) {\n\t\tvar mask = (1 << size) - 1;\n\t\tvalue = value & mask; // just in case\n\t\tthis.data[0] = this.data[0] & ~(mask << offset) | (value << offset);\n\t},\n\n\t/**\n\t *\n\t */\n\tclear: function() {\n\t\tthis.data[0] = 0;\n\t},\n\n\t/**\n\t *\n\t */\n\tsetBit: function(pos) {\n\t\tthis.storeBit(pos, 1);\n\t},\n\n\t/**\n\t *\n\t */\n\tclearBit: function(pos) {\n\t\tthis.storeBit(pos, 0);\n\t},\n\n\t/**\n\t *\n\t */\n\tisBitSet: function(pos) {\n\t\treturn this.loadBit(pos) === 1;\n\t},\n\n\t/**\n\t *\n\t */\n\tincrement: function() {\n\t\tthis.data[0]++;\n\t},\n\n\t/**\n\t *\n\t */\n\tincrementBy2: function() {\n\t\tthis.data[0] += 2;\n\t},\n\n\t/**\n\t *\n\t */\n\tadd: function(value) {\n\t\tthis.data[0] += value;\n\t},\n\n\t/**\n\t *\n\t */\n\tdecrement: function() {\n\t\tthis.data[0]--;\n\t},\n\n\t/**\n\t *\n\t */\n\tdecrementBy2: function() {\n\t\tthis.data[0] -= 2;\n\t},\n\n\t/**\n\t *\n\t */\n\tsub: function(value) {\n\t\tthis.data[0] -= value;\n\t},\n\n\t/**\n\t *\n\t */\n\tshift: function(value) {\n\t\tvalue = value & 1; // just in case\n\t\tvar carry = this.loadBit(this.getWidth() - 1);\n\t\tthis.data[0] = (this.data[0] << 1) | value;\n\t\treturn carry;\n\t},\n\n\t/**\n\t *\n\t */\n\tdump: function() {\n\t\treturn Utility.convertDecToHexString(this.load(), this.getWidth() / 4);\n\t}\n});\n\n/**\n *\n */\nfunction Register8bit() {\n\tRegister.call(this, Register.TYPE_8BIT);\n}\n\nRegister8bit.prototype = Object.assign(Object.create(Register.prototype), {\n\tisRegister8bit: true\n});\n\n/**\n *\n */\nfunction Register16bit() {\n\tRegister.call(this, Register.TYPE_16BIT);\n\tthis.bytes = new Uint8Array(this.data.buffer);\n}\n\nRegister16bit.prototype = Object.assign(Object.create(Register.prototype), {\n\tisRegister16bit: true,\n\n\t/**\n\t *\n\t */\n\tloadHigherByte: function() {\n\t\treturn this.bytes[1];\n\t},\n\n\t/**\n\t *\n\t */\n\tloadLowerByte: function() {\n\t\treturn this.bytes[0];\n\t},\n\n\t/**\n\t *\n\t */\n\tstoreHigherByte: function(value) {\n\t\tthis.bytes[1] = value;\n\t},\n\n\t/**\n\t *\n\t */\n\tstoreLowerByte: function(value) {\n\t\tthis.bytes[0] = value;\n\t}\n});\n module.exports = {\n\tRegister8bit,\n\tRegister16bit\n};",
			args: ["Utility"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -364.7944543836295,
			y: -845.9848882177932,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 239,
		id: "nodular_1694680845344",
		type: "Function",
		position: {
			x: 403.62031170513376,
			y: -844.2941958520564,
		},
		data: {
			label: "Ppu.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Ppu"],
			loading: false,
			func: "\n\n/**\n * RP2A03\n * Refer to https://wiki.nesdev.com/w/index.php/PPU\n */\nfunction Ppu() {\n\n  //\n\n  this.frame = 0;\n\n  this.scanLine = 0;\n  this.cycle = 0;\n\n  // other devices\n\n  this.cpu = null;  // set by .setCpu()\n  this.rom = null;  // set by .setRom()\n  this.display = null;  // set by .setDisplay();\n\n  // inside memory\n\n  this.vRam = new Memory(16 * 1024);  // 16KB\n  this.oamRam = new Memory(256);      // 256B, primary OAM memory\n  this.oamRam2 = new Memory(32);      // 32B, secondary OAM memory\n\n  // CPU memory mapped registers\n\n  this.ppuctrl = new PpuControlRegister();  // 0x2000\n  this.ppumask = new PpuMaskRegister();     // 0x2001\n  this.ppustatus = new PpuStatusRegister(); // 0x2002\n  this.oamaddr = new Register8bit();        // 0x2003\n  this.oamdata = new Register8bit();        // 0x2004\n  this.ppuscroll = new Register8bit();      // 0x2005\n  this.ppuaddr = new Register8bit();        // 0x2006\n  this.ppudata = new Register8bit();        // 0x2007\n  this.oamdma = new Register8bit();         // 0x4014\n\n  // inside shift registers\n\n  this.nameTableRegister = new Register8bit();\n  this.attributeTableLowRegister = new Register16bit();\n  this.attributeTableHighRegister = new Register16bit();\n  this.patternTableLowRegister = new Register16bit();\n  this.patternTableHighRegister = new Register16bit();\n\n  // inside latches\n\n  this.nameTableLatch = 0;\n  this.attributeTableLowLatch = 0;\n  this.attributeTableHighLatch = 0;\n  this.patternTableLowLatch = 0;\n  this.patternTableHighLatch = 0\n\n  //\n\n  this.fineXScroll = 0;\n  this.currentVRamAddress = 0;\n  this.temporalVRamAddress = 0;\n\n  //\n\n  this.vRamReadBuffer = 0;\n  this.registerFirstStore = true;\n\n  // sprites\n\n  this.spritesManager = new SpritesManager(this.oamRam);\n  this.spritesManager2 = new SpritesManager(this.oamRam2);\n\n  // for one scan line\n\n  this.spritePixels = [];\n  this.spriteIds = [];\n  this.spritePriorities = [];\n\n  for(var i = 0; i < 256; i++) {\n    this.spritePixels[i] = -1;\n    this.spriteIds[i] = -1;\n    this.spritePriorities[i] = -1;\n  }\n}\n\n//\n\n\n//\n\nObject.assign(Ppu.prototype, {\n  isPpu: true,\n\n  //\n\n  PALETTES: [\n    /* 0x00 */ 0xff757575,\n    /* 0x01 */ 0xff8f1b27,\n    /* 0x02 */ 0xffab0000,\n    /* 0x03 */ 0xff9f0047,\n    /* 0x04 */ 0xff77008f,\n    /* 0x05 */ 0xff1300ab,\n    /* 0x06 */ 0xff0000a7,\n    /* 0x07 */ 0xff000b7f,\n    /* 0x08 */ 0xff002f43,\n    /* 0x09 */ 0xff004700,\n    /* 0x0a */ 0xff005100,\n    /* 0x0b */ 0xff173f00,\n    /* 0x0c */ 0xff5f3f1b,\n    /* 0x0d */ 0xff000000,\n    /* 0x0e */ 0xff000000,\n    /* 0x0f */ 0xff000000,\n    /* 0x10 */ 0xffbcbcbc,\n    /* 0x11 */ 0xffef7300,\n    /* 0x12 */ 0xffef3b23,\n    /* 0x13 */ 0xfff30083,\n    /* 0x14 */ 0xffbf00bf,\n    /* 0x15 */ 0xff5b00e7,\n    /* 0x16 */ 0xff002bdb,\n    /* 0x17 */ 0xff0f4fcb,\n    /* 0x18 */ 0xff00738b,\n    /* 0x19 */ 0xff009700,\n    /* 0x1a */ 0xff00ab00,\n    /* 0x1b */ 0xff3b9300,\n    /* 0x1c */ 0xff8b8300,\n    /* 0x1d */ 0xff000000,\n    /* 0x1e */ 0xff000000,\n    /* 0x1f */ 0xff000000,\n    /* 0x20 */ 0xffffffff,\n    /* 0x21 */ 0xffffbf3f,\n    /* 0x22 */ 0xffff975f,\n    /* 0x23 */ 0xfffd8ba7,\n    /* 0x24 */ 0xffff7bf7,\n    /* 0x25 */ 0xffb777ff,\n    /* 0x26 */ 0xff6377ff,\n    /* 0x27 */ 0xff3b9bff,\n    /* 0x28 */ 0xff3fbff3,\n    /* 0x29 */ 0xff13d383,\n    /* 0x2a */ 0xff4bdf4f,\n    /* 0x2b */ 0xff98f858,\n    /* 0x2c */ 0xffdbeb00,\n    /* 0x2d */ 0xff000000,\n    /* 0x2e */ 0xff000000,\n    /* 0x2f */ 0xff000000,\n    /* 0x30 */ 0xffffffff,\n    /* 0x31 */ 0xffffe7ab,\n    /* 0x32 */ 0xffffd7c7,\n    /* 0x33 */ 0xffffcbd7,\n    /* 0x34 */ 0xffffc7ff,\n    /* 0x35 */ 0xffdbc7ff,\n    /* 0x36 */ 0xffb3bfff,\n    /* 0x37 */ 0xffabdbff,\n    /* 0x38 */ 0xffa3e7ff,\n    /* 0x39 */ 0xffa3ffe3,\n    /* 0x3a */ 0xffbff3ab,\n    /* 0x3b */ 0xffcfffb3,\n    /* 0x3c */ 0xfff3ff9f,\n    /* 0x3d */ 0xff000000,\n    /* 0x3e */ 0xff000000,\n    /* 0x3f */ 0xff000000\n  ],\n\n  // public methods\n\n  // set methods\n\n  /**\n   *\n   */\n  setCpu: function(cpu) {\n    this.cpu = cpu;\n  },\n\n  /**\n   *\n   */\n  setRom: function(rom) {\n    this.rom = rom;\n  },\n\n  /**\n   *\n   */\n  setDisplay: function(display) {\n    this.display = display;\n  },\n\n  //\n\n  /**\n   * Refer to https://wiki.nesdev.com/w/index.php/PPU_power_up_state\n   */\n  bootup: function() {\n    this.ppustatus.store(0x80);\n  },\n\n  /**\n   *\n   */\n  reset: function() {\n\n  },\n\n  /**\n   *\n   */\n  runCycle: function() {\n    this.renderPixel();\n    this.shiftRegisters();\n    this.fetch();\n    this.evaluateSprites();\n    this.updateFlags();\n    this.countUpScrollCounters();\n    this.countUpCycle();\n  },\n\n  // load/store methods\n\n  /**\n   * Called from Cpu\n   */\n  loadRegister: function(address) {\n    switch(address) {\n\n      // ppustatus load\n\n      case 0x2002:\n        var value = this.ppustatus.load();\n        this.ppustatus.clearVBlank();\n        this.registerFirstStore = true;\n        return value;\n\n      // oamdata load\n\n      case 0x2004:\n        return this.oamRam.load(this.oamaddr.load());\n\n      // ppudata load\n\n      case 0x2007:\n        var value;\n\n        if((this.currentVRamAddress & 0x3FFF) >= 0 &&\n            (this.currentVRamAddress & 0x3FFF) < 0x3F00) {\n          value = this.vRamReadBuffer;\n          this.vRamReadBuffer = this.load(this.currentVRamAddress);\n        } else {\n          value = this.load(this.currentVRamAddress);\n          this.vRamReadBuffer = value;\n        }\n\n        this.incrementVRamAddress();\n        return value;\n    }\n\n    return 0;\n  },\n\n  /**\n   * Called from Cpu.\n   */\n  storeRegister: function(address, value) {\n    switch(address) {\n\n      // ppuctrl store\n\n      case 0x2000:\n        this.ppuctrl.store(value);\n        this.temporalVRamAddress &= ~0xC00;\n        this.temporalVRamAddress |= (value & 0x3) << 10;\n        break;\n\n      // ppumask store\n\n      case 0x2001:\n        this.ppumask.store(value);\n        break;\n\n      // oamaddr store\n\n      case 0x2003:\n        this.oamaddr.store(value);\n        break;\n\n      // oamdata store\n\n      case 0x2004:\n        this.oamdata.store(value);\n        this.oamRam.store(this.oamaddr.load(), value);\n        this.oamaddr.increment();\n        break;\n\n      // ppuscroll store\n\n      case 0x2005:\n        this.ppuscroll.store(value);\n\n        if(this.registerFirstStore === true) {\n          this.fineXScroll = value & 0x7;\n          this.temporalVRamAddress &= ~0x1F;\n          this.temporalVRamAddress |= (value >> 3) & 0x1F;\n        } else {\n          this.temporalVRamAddress &= ~0x73E0;\n          this.temporalVRamAddress |= (value & 0xF8) << 2;\n          this.temporalVRamAddress |= (value & 0x7) << 12;\n        }\n\n        this.registerFirstStore = !this.registerFirstStore;\n\n        break;\n\n      // ppuaddr store\n\n      case 0x2006:\n        if(this.registerFirstStore === true) {\n          this.temporalVRamAddress &= ~0x7F00;\n          this.temporalVRamAddress |= (value & 0x3F) << 8;\n        } else {\n          this.ppuaddr.store(value);\n          this.temporalVRamAddress &= ~0xFF;\n          this.temporalVRamAddress |= (value & 0xFF);\n          this.currentVRamAddress = this.temporalVRamAddress;\n        }\n\n        this.registerFirstStore = !this.registerFirstStore;\n\n        break;\n\n      // ppudata store\n\n      case 0x2007:\n        this.ppudata.store(value);\n\n        this.store(this.currentVRamAddress, value);\n        this.incrementVRamAddress();\n\n        break;\n\n      // oamdma store\n\n      case 0x4014:\n        this.oamdma.store(value);\n\n        var offset = value * 0x100;\n\n        for(var i = this.oamaddr.load(); i < 256; i++)\n          this.oamRam.store(i, this.cpu.load(offset + i));\n\n        this.cpu.stallCycle += 514;\n\n        break;\n    }\n  },\n\n  /**\n   *\n   */\n  load: function(address) {\n    address = address & 0x3FFF;  // just in case\n\n    // 0x0000 - 0x1FFF is mapped with cartridge's CHR-ROM if it exists\n\n    if(address < 0x2000 && this.rom.hasChrRom() === true)\n      return this.rom.load(address);\n\n    // 0x0000 - 0x0FFF: pattern table 0\n    // 0x1000 - 0x1FFF: pattern table 1\n    // 0x2000 - 0x23FF: nametable 0\n    // 0x2400 - 0x27FF: nametable 1\n    // 0x2800 - 0x2BFF: nametable 2\n    // 0x2C00 - 0x2FFF: nametable 3\n    // 0x3000 - 0x3EFF: Mirrors of 0x2000 - 0x2EFF\n    // 0x3F00 - 0x3F1F: Palette RAM indices\n    // 0x3F20 - 0x3FFF: Mirrors of 0x3F00 - 0x3F1F\n\n    if(address >= 0x2000 && address < 0x3F00)\n      return this.vRam.load(this.getNameTableAddressWithMirroring(address & 0x2FFF));\n\n    if(address >= 0x3F00 && address < 0x4000)\n      address = address & 0x3F1F;\n\n    // Addresses for palette\n    // 0x3F10/0x3F14/0x3F18/0x3F1C are mirrors of\n    // 0x3F00/0x3F04/0x3F08/0x3F0C.\n\n    if(address === 0x3F10)\n      address = 0x3F00;\n\n    if(address === 0x3F14)\n      address = 0x3F04;\n\n    if(address === 0x3F18)\n      address = 0x3F08;\n\n    if(address === 0x3F1C)\n      address = 0x3F0C;\n\n    return this.vRam.load(address);\n  },\n\n  /**\n   *\n   */\n  store: function(address, value) {\n    address = address & 0x3FFF;  // just in case\n\n    // 0x0000 - 0x1FFF is mapped with cartridge's CHR-ROM if it exists\n\n    if(address < 0x2000 && this.rom.hasChrRom() === true) {\n      this.rom.store(address, value);\n      return;\n    }\n\n    // 0x0000 - 0x0FFF: pattern table 0\n    // 0x1000 - 0x1FFF: pattern table 1\n    // 0x2000 - 0x23FF: nametable 0\n    // 0x2400 - 0x27FF: nametable 1\n    // 0x2800 - 0x2BFF: nametable 2\n    // 0x2C00 - 0x2FFF: nametable 3\n    // 0x3000 - 0x3EFF: Mirrors of 0x2000 - 0x2EFF\n    // 0x3F00 - 0x3F1F: Palette RAM indices\n    // 0x3F20 - 0x3FFF: Mirrors of 0x3F00 - 0x3F1F\n\n    if(address >= 0x2000 && address < 0x3F00) {\n      this.vRam.store(this.getNameTableAddressWithMirroring(address & 0x2FFF), value);\n      return;\n    }\n\n    if(address >= 0x3F00 && address < 0x4000)\n      address = address & 0x3F1F;\n\n    // Addresses for palette\n    // 0x3F10/0x3F14/0x3F18/0x3F1C are mirrors of\n    // 0x3F00/0x3F04/0x3F08/0x3F0C.\n\n    if(address === 0x3F10)\n      address = 0x3F00;\n\n    if(address === 0x3F14)\n      address = 0x3F04;\n\n    if(address === 0x3F18)\n      address = 0x3F08;\n\n    if(address === 0x3F1C)\n      address = 0x3F0C;\n\n    return this.vRam.store(address, value);\n  },\n\n  // private methods\n\n  getNameTableAddressWithMirroring: function(address) {\n    address = address & 0x2FFF;  // just in case\n\n    var baseAddress = 0;\n\n    switch(this.rom.getMirroringType()) {\n      case this.rom.MIRRORINGS.SINGLE_SCREEN:\n        baseAddress = 0x2000;\n        break;\n\n      case this.rom.MIRRORINGS.HORIZONTAL:\n        if(address >= 0x2000 && address < 0x2400)\n          baseAddress = 0x2000;\n        else if(address >= 0x2400 && address < 0x2800)\n          baseAddress = 0x2000;\n        else if(address >= 0x2800 && address < 0x2C00)\n          baseAddress = 0x2400;\n        else\n          baseAddress = 0x2400;\n\n        break;\n\n      case this.rom.MIRRORINGS.VERTICAL:\n        if(address >= 0x2000 && address < 0x2400)\n          baseAddress = 0x2000;\n        else if(address >= 0x2400 && address < 0x2800)\n          baseAddress = 0x2400;\n        else if(address >= 0x2800 && address < 0x2C00)\n          baseAddress = 0x2000;\n        else\n          baseAddress = 0x2400;\n\n        break;\n\n      case this.rom.MIRRORINGS.FOUR_SCREEN:\n        if(address >= 0x2000 && address < 0x2400)\n          baseAddress = 0x2000;\n        else if(address >= 0x2400 && address < 0x2800)\n          baseAddress = 0x2400;\n        else if(address >= 0x2800 && address < 0x2C00)\n          baseAddress = 0x2800;\n        else\n          baseAddress = 0x2C00;\n\n        break;\n    }\n\n    return baseAddress | (address & 0x3FF);\n  },\n\n  // rendering\n\n  /**\n   *\n   */\n  renderPixel: function() {\n    // Note: this comparison order is for performance.\n    if(this.cycle >= 257 || this.scanLine >= 240 || this.cycle === 0)\n      return;\n\n    var x = this.cycle - 1 ;\n    var y = this.scanLine;\n\n    var backgroundVisible = this.ppumask.isBackgroundVisible();\n    var spritesVisible = this.ppumask.isSpritesVisible();\n\n    var backgroundPixel = this.getBackgroundPixel();\n    var spritePixel = this.spritePixels[x];\n    var spriteId = this.spriteIds[x];\n    var spritePriority = this.spritePriorities[x];\n\n    var c = this.PALETTES[this.load(0x3F00)];\n\n    // TODO: fix me\n\n    if(backgroundVisible === true && spritesVisible === true) {\n      if(spritePixel === -1) {\n        c = backgroundPixel;\n      } else {\n        if(backgroundPixel === c)\n          c = spritePixel\n        else\n          c = spritePriority === 0 ? spritePixel : backgroundPixel;\n      }\n    } else if(backgroundVisible === true && spritesVisible === false) {\n      c = backgroundPixel;\n    } else if(backgroundVisible === false && spritesVisible === true) {\n      if(spritePixel !== -1)\n        c = spritePixel;\n    }\n\n    // TODO: fix me\n\n    if(this.ppumask.emphasisRed() === true)\n      c = c | 0x00FF0000;\n    if(this.ppumask.emphasisGreen() === true)\n      c = c | 0x0000FF00;\n    if(this.ppumask.emphasisBlue() === true)\n      c = c | 0x000000FF;\n\n    // TODO: fix me\n\n    if(backgroundVisible === true && spritesVisible === true &&\n       spriteId === 0 && spritePixel !== 0 && backgroundPixel !== 0)\n      this.ppustatus.setZeroHit();\n\n    this.display.renderPixel(x, y, c);\n  },\n\n  /**\n   *\n   */\n  getBackgroundPixel: function() {\n    var offset = 15 - this.fineXScroll;\n\n    var lsb = (this.patternTableHighRegister.loadBit(offset) << 1) |\n                this.patternTableLowRegister.loadBit(offset);\n    var msb = (this.attributeTableHighRegister.loadBit(offset) << 1) |\n                this.attributeTableLowRegister.loadBit(offset);\n    var index = (msb << 2) | lsb;\n\n    // TODO: fix me\n\n    if(this.ppumask.isGreyscale() === true)\n      index = index & 0x30;\n\n    return this.PALETTES[this.load(0x3F00 + index)];\n  },\n\n  //\n\n  /**\n   *\n   */\n  shiftRegisters: function() {\n    if(this.scanLine >= 240 && this.scanLine <= 260)\n      return;\n\n    if((this.cycle >= 1 && this.cycle <= 256) ||\n       (this.cycle >= 329 && this.cycle <= 336)) {\n      this.patternTableLowRegister.shift(0);\n      this.patternTableHighRegister.shift(0);\n      this.attributeTableLowRegister.shift(0);\n      this.attributeTableHighRegister.shift(0);\n    }\n  },\n\n  // fetch\n\n  /**\n   *\n   */\n  fetch: function() {\n    if(this.scanLine >= 240 && this.scanLine <= 260)\n      return;\n\n    if(this.cycle === 0)\n      return;\n\n    if((this.cycle >= 257 && this.cycle <= 320) || this.cycle >= 337)\n      return;\n\n    switch((this.cycle - 1) % 8) {\n      case 0:\n        this.fetchNameTable();\n        break;\n\n      case 2:\n        this.fetchAttributeTable();\n        break;\n\n      case 4:\n        this.fetchPatternTableLow();\n        break;\n\n      case 6:\n        this.fetchPatternTableHigh();\n        break;\n\n      default:\n        break;\n    }\n\n    if(this.cycle % 8 === 1) {\n      this.nameTableRegister.store(this.nameTableLatch);\n      this.attributeTableLowRegister.storeLowerByte(this.attributeTableLowLatch);\n      this.attributeTableHighRegister.storeLowerByte(this.attributeTableHighLatch);\n      this.patternTableLowRegister.storeLowerByte(this.patternTableLowLatch);\n      this.patternTableHighRegister.storeLowerByte(this.patternTableHighLatch);\n    }\n  },\n\n  /**\n   * Refer to http://wiki.nesdev.com/w/index.php/PPU_scrolling\n   */\n  fetchNameTable: function() {\n    this.nameTableLatch = this.load(0x2000 | (this.currentVRamAddress & 0x0FFF));\n  },\n\n  /**\n   *\n   */\n  fetchAttributeTable: function() {\n    var v = this.currentVRamAddress;\n    var address = 0x23C0 | (v & 0x0C00) | ((v >> 4) & 0x38) | ((v >> 2) & 0x07);\n\n    var byte = this.load(address);\n\n    var coarseX = v & 0x1F;\n    var coarseY = (v >> 5) & 0x1F\n\n    var topbottom = (coarseY % 4) >= 2 ? 1 : 0; // bottom, top\n    var rightleft = (coarseX % 4) >= 2 ? 1 : 0; // right, left\n\n    var position = (topbottom << 1) | rightleft; // bottomright, bottomleft,\n                                                 // topright, topleft\n\n    var value = (byte >> (position << 1)) & 0x3;\n    var highBit = value >> 1;\n    var lowBit = value & 1;\n\n    this.attributeTableHighLatch = highBit === 1 ? 0xff : 0;\n    this.attributeTableLowLatch = lowBit === 1 ? 0xff : 0;\n  },\n\n  /**\n   *\n   */\n  fetchPatternTableLow: function() {\n    var fineY = (this.currentVRamAddress >> 12) & 0x7;\n    var index = this.ppuctrl.getBackgroundPatternTableNum() * 0x1000 +\n                  this.nameTableRegister.load() * 0x10 + fineY;\n\n    this.patternTableLowLatch = this.load(index);\n  },\n\n  /**\n   *\n   */\n  fetchPatternTableHigh: function() {\n    var fineY = (this.currentVRamAddress >> 12) & 0x7;\n    var index = this.ppuctrl.getBackgroundPatternTableNum() * 0x1000 +\n                  this.nameTableRegister.load() * 0x10 + fineY;\n\n    this.patternTableHighLatch = this.load(index + 0x8);\n  },\n\n  //\n\n  /**\n   *\n   */\n  updateFlags: function() {\n    if(this.cycle === 1) {\n      if(this.scanLine === 241) {\n        this.ppustatus.setVBlank();\n        this.display.updateScreen();\n\n        //if(this.ppuctrl.enabledNmi() === true)\n        //  this.cpu.interrupt(this.cpu.INTERRUPTS.NMI);\n      } else if(this.scanLine === 261) {\n        this.ppustatus.clearVBlank();\n        this.ppustatus.clearZeroHit();\n        this.ppustatus.clearOverflow();\n      }\n    }\n\n    if(this.cycle === 10) {\n      if(this.scanLine === 241) {\n        if(this.ppuctrl.enabledNmi() === true)\n          this.cpu.interrupt(this.cpu.INTERRUPTS.NMI);\n      }\n    }\n\n    // @TODO: check this driving IRQ counter for MMC3Mapper timing is correct\n\n    if(this.rom.mapper.isMMC3Mapper === true) {\n      if(this.cycle === 340 && this.scanLine <= 240 &&\n          this.ppumask.isBackgroundVisible() === true &&\n          this.ppumask.isSpritesVisible() === true)\n        this.rom.mapper.driveIrqCounter(this.cpu);\n    }\n  },\n\n  /**\n   *\n   */\n  countUpScrollCounters: function() {\n    if(this.ppumask.isBackgroundVisible() === false && this.ppumask.isSpritesVisible() === false)\n      return;\n\n    if(this.scanLine >= 240 && this.scanLine <= 260)\n      return;\n\n    if(this.scanLine === 261) {\n      if(this.cycle >= 280 && this.cycle <= 304) {\n        this.currentVRamAddress &= ~0x7BE0;\n        this.currentVRamAddress |= (this.temporalVRamAddress & 0x7BE0)\n      }\n    }\n\n    if(this.cycle === 0 || (this.cycle >= 258 && this.cycle <= 320))\n      return;\n\n    if((this.cycle % 8) === 0) {\n      var v = this.currentVRamAddress;\n\n      if((v & 0x1F) === 31) {\n        v &= ~0x1F;\n        v ^= 0x400;\n      } else {\n        v++;\n      }\n\n      this.currentVRamAddress = v;\n    }\n\n    if(this.cycle === 256) {\n      var v = this.currentVRamAddress;\n\n      if((v & 0x7000) !== 0x7000) {\n        v += 0x1000;\n      } else {\n        v &= ~0x7000;\n        var y = (v & 0x3E0) >> 5;\n\n        if(y === 29) {\n          y = 0;\n          v ^= 0x800;\n        } else if(y === 31) {\n          y = 0;\n        } else {\n          y++;\n        }\n\n        v = (v & ~0x3E0) | (y << 5);\n      }\n\n      this.currentVRamAddress = v;\n    }\n\n    if(this.cycle === 257) {\n      this.currentVRamAddress &= ~0x41F;\n      this.currentVRamAddress |= (this.temporalVRamAddress & 0x41F)\n    }\n  },\n\n  /**\n   * cycle:    0 - 340\n   * scanLine: 0 - 261\n   */\n  countUpCycle: function() {\n    this.cycle++;\n\n    if(this.cycle > 340) {\n      this.cycle = 0;\n      this.scanLine++;\n\n      if(this.scanLine > 261) {\n        this.scanLine = 0;\n        this.frame++;\n      }\n    }\n  },\n\n  //\n\n  /**\n   *\n   */\n  incrementVRamAddress: function() {\n    this.currentVRamAddress += this.ppuctrl.isIncrementAddressSet() ? 32 : 1;\n    this.currentVRamAddress &= 0x7FFF;\n    this.ppuaddr.store(this.currentVRamAddress & 0xFF);\n  },\n\n  // sprites\n\n  /**\n   * Refer to https://wiki.nesdev.com/w/index.php/PPU_sprite_evaluation\n   */\n  evaluateSprites: function() {\n    if(this.scanLine >= 240)\n      return;\n\n    if(this.cycle === 0) {\n      this.processSpritePixels();\n\n      for(var i = 0, il = this.oamRam2.getCapacity(); i < il; i++)\n        this.oamRam2.store(i, 0xFF);\n    } else if(this.cycle === 65) {\n      var height = this.ppuctrl.isSpriteSize16() ? 16 : 8;\n      var n = 0;\n\n      for(var i = 0, il = this.spritesManager.getNum(); i < il; i++) {\n        var s = this.spritesManager.get(i);\n\n        if(s.on(this.scanLine, height) === true) {\n          if(n < 8) {\n            this.spritesManager2.copy(n++, s);\n          } else {\n            this.ppustatus.setOverflow();\n            break;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   *\n   */\n  processSpritePixels: function() {\n    var ay = this.scanLine - 1;\n\n    for(var i = 0, il = this.spritePixels.length; i < il; i++) {\n      this.spritePixels[i] = -1;\n      this.spriteIds[i] = -1;\n      this.spritePriorities[i] = -1;\n    }\n\n    var height = this.ppuctrl.isSpriteSize16() === true ? 16 : 8;\n    var n = 0;\n\n    for(var i = 0, il = this.spritesManager2.getNum(); i < il; i++) {\n      var s = this.spritesManager2.get(i);\n\n      if(s.isEmpty())\n        break;\n\n      var bx = s.getXPosition();\n      var by = s.getYPosition();\n      var j = ay - by;\n      var cy = s.doFlipVertically() ? height - j - 1 : j;\n      var horizontal = s.doFlipHorizontally();\n      var ptIndex = (height === 8) ? s.getTileIndex() : s.getTileIndexForSize16();\n      var msb = s.getPalletNum();\n\n      for(var k = 0; k < 8; k++) {\n        var cx = horizontal ? 7 - k : k;\n        var x = bx + k;\n\n        if(x >= 256)\n          break;\n\n        var lsb = this.getPatternTableElement(ptIndex, cx, cy, height);\n\n        if(lsb !== 0) {\n          var pIndex = (msb << 2) | lsb;\n\n          if(this.spritePixels[x] === -1) {\n            this.spritePixels[x] = this.PALETTES[this.load(0x3F10 + pIndex)];\n            this.spriteIds[x] = s.getId();\n            this.spritePriorities[x] = s.getPriority();\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   *\n   */\n  getPatternTableElement: function(index, x, y, ySize) {\n    var ax = x % 8;\n    var a, b;\n\n    if(ySize === 8) {\n      var ay = y % 8;\n      var offset = this.ppuctrl.getSpritesPatternTableNum() === 1 ? 0x1000 : 0;\n      a = this.load(offset + index * 0x10 + ay);\n      b = this.load(offset + index * 0x10 + 0x8 + ay);\n    } else {\n      var ay = y % 8;\n      ay += (y >> 3) * 0x10;\n      a = this.load(index + ay);\n      b = this.load(index + ay + 0x8);\n    }\n\n    return ((a >> (7 - ax)) & 1) | (((b >> (7 - ax)) & 1) << 1);\n  },\n\n  // dump methods\n\n  /**\n   *\n   */\n  dump: function() {\n    var buffer = '';\n\n    buffer += 'PPU Ctrl: ' + this.ppuctrl.dump() + '\\n';\n    buffer += 'PPU Mask: ' + this.ppumask.dump() + '\\n';\n    buffer += 'PPU Status: ' + this.ppustatus.dump() + '\\n';\n    buffer += 'OAM Address: ' + this.oamaddr.dump() + '\\n';\n    buffer += 'OAM Data: ' + this.oamdata.dump() + '\\n';\n    buffer += 'PPU Scroll: ' + this.ppuscroll.dump() + '\\n';\n    buffer += 'PPU Addr: ' + this.ppuaddr.dump() + '\\n';\n    buffer += 'PPU Data: ' + this.ppudata.dump() + '\\n';\n    buffer += 'OAM DMA: ' + this.oamdma.dump() + '\\n';\n    buffer += '\\n';\n\n    return buffer;\n  },\n\n  /**\n   *\n   */\n  dumpVRAM: function() {\n    var buffer = '';\n    var previousIsZeroLine = false;\n    var offset = 0;\n    var end = 0x10000;\n\n    for(var i = offset; i < end; i++) {\n      if(i % 0x10 == 0) {\n        if(previousIsZeroLine) {\n          var skipZero = false;\n          while(this._checkNext16BytesIsZero(i+0x10)) {\n            i += 0x10;\n            skipZero = true;\n          }\n          if(skipZero)\n            buffer += '...\\n';\n        }\n        buffer += Utility.convertDecToHexString(i-offset, 4) + ' ';\n        previousIsZeroLine = true;\n      }\n\n      var value = this.load(i);\n      buffer += Utility.convertDecToHexString(value, 2, true) + ' ';\n      if(value != 0)\n        previousIsZeroLine = false;\n\n      if(i % 0x10 == 0xf)\n        buffer += '\\n';\n    }\n    return buffer;\n  },\n\n  /**\n   *\n   */\n  _checkNext16BytesIsZero: function(offset) {\n    if(offset + 0x10 >= 0x10000)\n      return false;\n\n    var sum = 0;\n    for(var i = offset; i < offset + 0x10; i++) {\n      sum += this.load(i);\n    }\n    return sum == 0;\n  },\n\n  /**\n   *\n   */\n  dumpSPRRAM: function() {\n    return this.oamRam.dump();\n  }\n});\n\n/**\n *\n */\nfunction PpuControlRegister() {\n  Register8bit.call(this);\n}\n\nPpuControlRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isPpuControlRegister: true,\n\n  //\n\n  NMI_VBLANK_BIT: 7,\n  MASTER_SLAVE_BIT: 6,\n  SPRITES_SIZE_BIT: 5,\n  BACKGROUND_PATTERN_TABLE_BIT: 4,\n  SPRITES_PATTERN_TABLE_BIT: 3,\n  INCREMENT_ADDRESS_BIT: 2,\n\n  NAME_TABLE_ADDRESS_BIT: 0,\n  NAME_TABLE_ADDRESS_BITS_WIDTH: 2,\n\n  //\n\n  /**\n   *\n   */\n  isIncrementAddressSet: function() {\n    return this.isBitSet(this.INCREMENT_ADDRESS_BIT);\n  },\n\n  /**\n   *\n   */\n  enabledNmi: function() {\n    return this.isBitSet(this.NMI_VBLANK_BIT);\n  },\n\n  /**\n   *\n   */\n  isSpriteSize16: function() {\n    return this.isBitSet(this.SPRITES_SIZE_BIT);\n  },\n\n  /**\n   *\n   */\n  getBackgroundPatternTableNum: function() {\n    return this.loadBit(this.BACKGROUND_PATTERN_TABLE_BIT);\n  },\n\n  /**\n   *\n   */\n  getSpritesPatternTableNum: function() {\n    return this.loadBit(this.SPRITES_PATTERN_TABLE_BIT);\n  },\n\n  /**\n   *\n   */\n  getNameTableAddress: function() {\n    return this.loadBits(this.NAME_TABLE_ADDRESS_BIT, this.NAME_TABLE_ADDRESS_BITS_WIDTH);\n  }\n});\n\n/**\n *\n */\nfunction PpuMaskRegister() {\n  Register8bit.call(this);\n}\n\nPpuMaskRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isPpuMaskRegister: true,\n\n  //\n\n  GREYSCALE_BIT: 0,\n  LEFTMOST_BACKGROUND_VISIBLE_BIT: 1,\n  LEFTMOST_SPRITES_VISIBLE_BIT: 2,\n  BACKGROUND_VISIBLE_BIT: 3,\n  SPRITES_VISIBLE_BIT: 4,\n  EMPHASIZE_RED_BIT: 5,\n  EMPHASIZE_GREEN_BIT: 6,\n  EMPHASIZE_BLUE_BIT: 7,\n\n  //\n\n  /**\n   *\n   */\n  isGreyscale: function() {\n    return this.isBitSet(this.GREYSCALE_BIT);\n  },\n\n  /**\n   *\n   */\n  isLeftMostBackgroundVisible: function() {\n    return this.isBitSet(this.LEFTMOST_BACKGROUND_VISIBLE_BIT);\n  },\n\n  /**\n   *\n   */\n  isLeftMostSpritesVisible: function() {\n    return this.isBitSet(this.LEFTMOST_SPRITES_VISIBLE_BIT);\n  },\n\n  /**\n   *\n   */\n  isBackgroundVisible: function() {\n    return this.isBitSet(this.BACKGROUND_VISIBLE_BIT);\n  },\n\n  /**\n   *\n   */\n  isSpritesVisible: function() {\n    return this.isBitSet(this.SPRITES_VISIBLE_BIT);\n  },\n\n  /**\n   *\n   */\n  emphasisRed: function() {\n    return this.isBitSet(this.EMPHASIZE_RED_BIT);\n  },\n\n  /**\n   *\n   */\n  emphasisGreen: function() {\n    return this.isBitSet(this.EMPHASIZE_GREEN_BIT);\n  },\n\n  /**\n   *\n   */\n  emphasisBlue: function() {\n    return this.isBitSet(this.EMPHASIZE_BLUE_BIT);\n  }\n});\n\n/**\n *\n */\nfunction PpuStatusRegister() {\n  Register8bit.call(this);\n}\n\nPpuStatusRegister.prototype = Object.assign(Object.create(Register8bit.prototype), {\n  isPpuStatusRegister: true,\n\n  //\n\n  VBLANK_BIT: 7,\n  SPRITE_ZERO_HIT_BIT: 6,\n  SPRITE_OVERFLOW_BIT: 5,\n\n  //\n\n  /**\n   *\n   */\n  setVBlank: function() {\n    this.setBit(this.VBLANK_BIT);\n  },\n\n  /**\n   *\n   */\n  clearVBlank: function() {\n    this.clearBit(this.VBLANK_BIT);\n  },\n\n  /**\n   *\n   */\n  setZeroHit: function() {\n    this.setBit(this.SPRITE_ZERO_HIT_BIT);\n  },\n\n  /**\n   *\n   */\n  clearZeroHit: function() {\n    this.clearBit(this.SPRITE_ZERO_HIT_BIT);\n  },\n\n  /**\n   *\n   */\n  setOverflow: function() {\n    this.setBit(this.SPRITE_OVERFLOW_BIT);\n  },\n\n  /**\n   *\n   */\n  clearOverflow: function() {\n    this.clearBit(this.SPRITE_OVERFLOW_BIT);\n  }\n});\n\n/**\n *\n */\nfunction SpritesManager(memory) {\n  this.sprites = [];\n  this.init(memory);\n}\n\nObject.assign(SpritesManager.prototype, {\n  isSpritesManager: true,\n\n  /**\n   *\n   */\n  init: function(memory) {\n    for(var i = 0, il = memory.getCapacity() / 4; i < il; i++) {\n      this.sprites.push(new Sprite(i, i, memory));\n    }\n  },\n\n  /**\n   *\n   */\n  getNum: function() {\n    return this.sprites.length;\n  },\n\n  /**\n   *\n   */\n  get: function(index) {\n    return this.sprites[index];\n  },\n\n  /**\n   *\n   */\n  copy: function(index, sprite) {\n    this.sprites[index].copy(sprite);\n  }\n});\n\n/**\n *\n */\nfunction Sprite(index, id, memory) {\n  this.index = index;\n  this.id = id;\n  this.memory = memory;\n}\n\nObject.assign(Sprite.prototype, {\n  isSprite: true,\n\n  //\n\n  /**\n   *\n   */\n  getId: function() {\n    return this.id;\n  },\n\n  /**\n   *\n   */\n  setId: function(id) {\n    this.id = id;\n  },\n\n  /**\n   *\n   */\n  getByte0: function() {\n    return this.memory.load(this.index * 4 + 0);\n  },\n\n  /**\n   *\n   */\n  getByte1: function() {\n    return this.memory.load(this.index * 4 + 1);\n  },\n\n  /**\n   *\n   */\n  getByte2: function() {\n    return this.memory.load(this.index * 4 + 2);\n  },\n\n  /**\n   *\n   */\n  getByte3: function() {\n    return this.memory.load(this.index * 4 + 3);\n  },\n\n  /**\n   *\n   */\n  setByte0: function(value) {\n    this.memory.store(this.index * 4 + 0, value);\n  },\n\n  /**\n   *\n   */\n  setByte1: function(value) {\n    this.memory.store(this.index * 4 + 1, value);\n  },\n\n  /**\n   *\n   */\n  setByte2: function(value) {\n    this.memory.store(this.index * 4 + 2, value);\n  },\n\n  /**\n   *\n   */\n  setByte3: function(value) {\n    this.memory.store(this.index * 4 + 3, value);\n  },\n\n  /**\n   *\n   */\n  copy: function(sprite) {\n    this.setId(sprite.getId());\n    this.setByte0(sprite.getByte0());\n    this.setByte1(sprite.getByte1());\n    this.setByte2(sprite.getByte2());\n    this.setByte3(sprite.getByte3());\n  },\n\n  /**\n   *\n   */\n  isEmpty: function() {\n    return this.getByte0() === 0xFF && this.getByte1() === 0xFF &&\n             this.getByte2() === 0xFF && this.getByte3() === 0xFF;\n  },\n\n  /**\n   *\n   */\n  isVisible: function() {\n    return this.getByte0() < 0xEF;\n  },\n\n  /**\n   *\n   */\n  getYPosition: function() {\n    return this.getByte0() - 1;\n  },\n\n  /**\n   *\n   */\n  getXPosition: function() {\n    return this.getByte3();\n  },\n\n  /**\n   *\n   */\n  getTileIndex: function() {\n    return this.getByte1();\n  },\n\n  /**\n   *\n   */\n  getTileIndexForSize16: function() {\n    return ((this.getByte1() & 1) * 0x1000) + (this.getByte1() >> 1) * 0x20;\n  },\n\n  /**\n   *\n   */\n  getPalletNum: function() {\n    return this.getByte2() & 0x3;\n  },\n\n  /**\n   *\n   */\n  getPriority: function() {\n    return (this.getByte2() >> 5) & 1;\n  },\n\n  /**\n   *\n   */\n  doFlipHorizontally: function() {\n    return ((this.getByte2() >> 6) & 1) ? true : false;\n  },\n\n  /**\n   *\n   */\n  doFlipVertically: function() {\n    return ((this.getByte2() >> 7) & 1) ? true : false;\n  },\n\n  /**\n   *\n   */\n  on: function(y, length) {\n    return (y >= this.getYPosition()) && (y < this.getYPosition() + length);\n  }\n});\n\n module.exports = {Ppu};",
			args: ["Register16bit", "Register8bit", "Memory", "Utility"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 403.62031170513376,
			y: -844.2941958520564,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 116,
		id: "nodular_1694680846661",
		type: "Function",
		position: {
			x: -210.5689311311573,
			y: -593.565928598179,
		},
		data: {
			label: "Memory.js",
			lang: "node",
			funcnode: true,
			returnArgs: ["Memory"],
			loading: false,
			func: "\n\n\n/**\n * Generic 8bit-word Memory.\n */\n\n/**\n * @param {ArrayBuffer|integer} arg -\n */\nfunction Memory(arg) {\n  this.data = new Uint8Array(arg);\n}\n\nObject.assign(Memory.prototype, {\n  isMemory: true,\n\n  /**\n   *\n   */\n  clear: function() {\n    for(var i = 0, il = this.getCapacity(); i < il; i++)\n      this.storeWithoutMapping(i, 0);\n  },\n\n  /**\n   *\n   */\n  getCapacity: function() {\n    return this.data.byteLength;\n  },\n\n  /**\n   *\n   */\n  load: function(address) {\n    return this.data[address];\n  },\n\n  /**\n   *\n   */\n  loadWithoutMapping: function(address) {\n    return this.data[address];\n  },\n\n  /**\n   *\n   */\n  store: function(address, value) {\n    this.data[address] = value;\n  },\n\n  /**\n   *\n   */\n  storeWithoutMapping: function(address, value) {\n    this.data[address] = value;\n  },\n\n  /**\n   *\n   */\n  dump: function() {\n    var buffer = '';\n    var previousIsZeroLine = false;\n    var offset = this._getStartDumpAddress();\n    var end = this._getEndDumpAddress();\n    for(var i = offset; i < end; i++) {\n      if(i % 0x10 === 0) {\n        if(previousIsZeroLine) {\n          var skipZero = false;\n          while(this._checkNext16BytesIsZero(i+0x10)) {\n            i += 0x10;\n            skipZero = true;\n          }\n          if(skipZero)\n            buffer += '...\\n';\n        }\n        buffer += Utility.convertDecToHexString(i-offset, 4) + ' ';\n        previousIsZeroLine = true;\n      }\n\n      var value = this._loadForDump(i);\n      buffer += Utility.convertDecToHexString(value, 2, true) + ' ';\n      if(value != 0)\n        previousIsZeroLine = false;\n\n      if(i % 0x10 === 0xf)\n        buffer += '\\n';\n    }\n    return buffer;\n  },\n\n  /**\n   *\n   */\n  _loadForDump: function(address) {\n    return this.loadWithoutMapping(address);\n  },\n\n  /**\n   *\n   */\n  _getStartDumpAddress: function() {\n    return 0;\n  },\n\n  /**\n   *\n   */\n  _getEndDumpAddress: function() {\n    return this.getCapacity();\n  },\n\n  /**\n   *\n   */\n  _checkNext16BytesIsZero: function(offset) {\n    if(offset + 0x10 >= this._getEndDumpAddress())\n      return false;\n\n    var sum = 0;\n    for(var i = offset; i < offset + 0x10; i++) {\n      sum += this._loadForDump(i);\n    }\n    return sum === 0;\n  }\n});\n\n module.exports = {Memory};",
			args: ["Utility"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -210.5689311311573,
			y: -593.565928598179,
		},
		dragging: false,
	},
	{
		width: 158,
		height: 269,
		id: "nodular_1694681138014",
		type: "Function",
		position: {
			x: 1081.0303617465665,
			y: -369.153711367157,
		},
		data: {
			label: "LoadNes.js",
			lang: "node",
			funcnode: true,
			returnArgs: [],
			loading: false,
			func: "\n\nfunction NesJs() {}\n\nNesJs.Nes = Nes;\nNesJs.Rom = Rom;\nNesJs.Audio = Audio;\nNesJs.Display = Display;\nNesJs.Joypad = Joypad;\n\nasync function LoadNES() {\n\tconst rom = await fetch('https://raw.githubusercontent.com/HFx6/nodular/ui-update/src/utils/roms/zelda.nes').then((response) => {\n\t\treturn response.arrayBuffer();\n\t})\n\n\t//Load the Rom\n\t//Set arrayBuffer to arraybuffer from rom\n\t// console.log(rom);\n\t// const arrayBuffer = await new Uint8Array(rom.match(/../g).map(h => parseInt(h, 16))).buffer;\n\t// console.log(arrayBuffer); //Set romBuffer to new Uint8Array(arrayBuffer)\n\t// const romBuffer = new Uint8Array(arrayBuffer);\n\tvar nes = new NesJs.Nes();\n\n\tnes.setRom(new NesJs.Rom(rom));\n\tnes.setDisplay(new NesJs.Display(canvas));\n\t// nes.setAudio(new NesJs.Audio());\n\n\t// window.onkeydown = function(e) {\n\t// \tnes.handleKeyDown(e);\n\t// };\n\t// window.onkeyup = function(e) {\n\t// \tnes.handleKeyUp(e);\n\t// };\n\n\tnes.bootup();\n\tnes.run();\n\n}\n\nLoadNES();",
			args: ["Nes", "Rom", "Audio", "Display", "Joypad", "canvas"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 1081.0303617465665,
			y: -369.153711367157,
		},
		dragging: false,
	},
];
