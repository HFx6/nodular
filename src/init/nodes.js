export default [
	{
		width: 188,
		height: 248,
		id: "nodular_1693117134023",
		type: "javascriptNode",
		position: {
			x: 1070.7692649560145,
			y: -408.1950663131147,
		},
		data: {
			label: "chip8.js",
			lang: "node",
			loading: false,
			func: '//This is the Emulator Class which will initialize the hardware and also any and all DOM Debug features on the html page\nimport { TIME_60_HZ } from "EmulatorConstants.js";\nimport { CPU } from "cpu.js";\nimport { Display } from "display.js";\nimport { Keyboard } from "keyboard.js";\nimport { Controls } from "controls.js";\nimport { Speaker } from "speaker.js";\n\n//#region Initialize\n//Create new instances of the hardware\nconst display = new Display();\nconst keyboard = new Keyboard();\nconst speaker = new Speaker();\n\n//Attatch the hardware to a new instance of the CPU\nconst cpu = new CPU(display, keyboard, speaker);\n//#endregion\n\n//Loads the pages controls and handles their events\nconst controls = new Controls(cpu);\n\n\n//Variables for calculating FPS\nvar now, then, delta;\n\nfunction init() {\n    //#region Start Emulator\n    //Get Start\n    then = Date.now();\n\n    //Call the loop\n    //Infinite Function\n    emuCycle();\n    //#endregion\n}\n\n//#region EmuCycle\n//This should run at 60Hz but can be changed by fps counter\nfunction emuCycle() {\n    var timePassed = (Date.now() - now) / 1000;\n    //Framerate Calculations\n    now = Date.now();\n    delta = now - then;\n    var fps = Math.round(1 / timePassed);\n\n    //This will force 60Hz\n    if (delta > TIME_60_HZ) {\n        //Contextual Comments from https://gist.github.com/elundmark\n        // update time stuffs\n        // Just `then = now` is not enough.\n        // Lets say we set fps at 10 which means\n        // each frame must take 100ms\n        // Now frame executes in 16ms (60fps) so\n        // the loop iterates 7 times (16*7 = 112ms) until\n        // delta > interval === true\n        // Eventually this lowers down the FPS as\n        // 112*10 = 1120ms (NOT 1000ms).\n        // So we have to get rid of that extra 12ms\n        // by subtracting delta (112) % interval (100).\n        // Hope that makes sense.\n        then = now - (delta % TIME_60_HZ);\n\n        //Call the cpu cycle method\n        //each cycle is 10 steps\n        cpu.cycle();\n        if (!cpu.registers.paused) {\n            cpu.debug.ShowFPS(fps);\n        }\n    }\n\n    //Recursion\n    requestAnimationFrame(emuCycle);\n}\n\n//#endregion\n\n//Call Initialization Function\ninit();',
			args: [
				"TIME_60_HZ ",
				"CPU",
				"Display",
				"Keyboard",
				"Controls",
				"Speaker",
			],
			funcedit: true,
			argTypes: ["chip8"],
			returnType: "",
			returnArgs: [],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: true,
		dragging: false,
		positionAbsolute: {
			x: 1070.7692649560145,
			y: -408.1950663131147,
		},
	},
	{
		width: 216,
		height: 112,
		id: "nodular_1693117135705",
		type: "javascriptNode",
		position: {
			x: 576.500396909747,
			y: 141.43117372196053,
		},
		data: {
			label: "controls.js",
			lang: "node",
			loading: false,
			func: "import { ROMS } from \"EmulatorConstants.js\";\nimport { Settings } from \"settings.js\";\n\n//#region Page Controls\n//CPU\nconst speedStepText = document.getElementById('speedStep'); //Changable\nconst stepCPU = document.getElementById('step');\nconst pauseBtn = document.getElementById('pause');\nconst quirk = document.getElementById('quirkType'); //Changable\n\n//Display\nconst displayScale = document.getElementById('displayScale'); //Changable\n\n//const fpsScale = document.getElementById('fps'); //TODO: may move to cpu\n\nconst bgColorInput = document.getElementById('bgColor'); //Changable\nconst colorInput = document.getElementById('color'); //Changable\n\nconst fps = document.getElementById('fpsControl');\nconst showfps = document.getElementById('showfps');\n\n//Sound\nconst volumeControl = document.getElementById('volumeControl'); //Changable\nconst volumeLevel = document.getElementById('volumeNumber');\nconst oscillatorType = document.getElementById('oscillator'); //Changable\nconst muteControl = document.getElementById('sound'); //Changable\n\n//ROMS\nconst romSelect = document.getElementById('roms');\nconst loadBtn = document.getElementById('load');\n\n//Debug\nconst debugChk = document.getElementById('debug');\n\nconst settings = new Settings(); //Create new instance of settings\n//#endregion\n\n//Variable to hold the CPU instance\nvar processor;\n\nexport class Controls {\n    constructor(cpu) {\n        //CPU Instance\n        processor = cpu;\n\n        //#region Controls Event Listeners\n        //CPU\n        pauseBtn.addEventListener('click', this.pause);\n        stepCPU.addEventListener('click', this.stepNext);\n        speedStepText.addEventListener('input', this.ChangeSpeed);\n        quirk.addEventListener('click', this.setQuirk)\n\n        //Display\n        displayScale.addEventListener('input', this.ChangeScale);\n        bgColorInput.addEventListener('change', this.changeBGColor);\n        colorInput.addEventListener('change', this.changeColor);\n        showfps.addEventListener('click', this.ShowFpsCounter);\n\n        //Sound\n        volumeControl.addEventListener('change', this.changeVolume);\n        volumeControl.addEventListener('input', this.sliderChange)\n\n        oscillatorType.addEventListener('click', this.changeOscillator);\n        muteControl.addEventListener('click', this.MuteAudio);\n\n        //ROMS\n        loadBtn.addEventListener('click', this.loadSelectedRom);\n\n        //Debug\n        debugChk.addEventListener('click', this.showDebugOptions)\n\n        //Window\n\n        //#endregion\n\n        this.loadControls();\n    }\n\n    //Loads the controls with values from the emulator\n    loadControls() {\n        settings.load(processor); //Load Local Storage int CPU\n\n        //#region Controls Values Load\n        //CPU\n        speedStepText.value = processor.speed;\n        quirk.value = processor.quirk;\n\n        //Display\n        displayScale.value = processor.display.scale;\n\n        bgColorInput.value = '#000000';\n        colorInput.value = '#FFFFFF'\n\n        //Sound\n        volumeControl.value = processor.speaker.volumeLevel;\n        volumeLevel.innerHTML = processor.speaker.volumeLevel;\n\n        oscillatorType.value = processor.speaker.wave;\n\n        //#endregion\n\n        //ROMS\n        this.loadRomNames(); //Loads the roms from the roms folder\n    }\n\n\n\n    //////////////////////////Methods to handle the controls///////////////////////////////////////\n\n    //#region Controls Functions\n    //#region CPU\n    //Pause the CPU\n    pause() {\n        //Check if CPU is already paused\n        if (processor.registers.paused) {\n            //Set register to false and change control text to Pause\n            processor.registers.paused = false;\n            pauseBtn.innerHTML = \"Pause\";\n        } else {\n            //Set register to true and change control text to Play\n            processor.registers.paused = true;\n            pauseBtn.innerHTML = \"Play\";\n        }\n    }\n\n    //Step the CPU by one instruction\n    stepNext() {\n        //call CPU step method\n        processor.step();\n        //Render the display\n        processor.display.render();\n    }\n\n    //Change cpu speed\n    //This changes how many instructions per CPU cycle\n    ChangeSpeed() {\n        processor.speed = speedStepText.value;\n\n        settings.save(\"speed\", speedStepText.value); //Save value\n    }\n\n    //Turns on or off cpu quirk which handles different types of chip8 cpus\n    setQuirk() {\n        processor.quirk = quirk.value;\n\n        settings.save(\"quirk\", quirk.value); //Save value\n    }\n    //#endregion\n\n    //#region  Display\n    //Change the scale of the display on the page\n    ChangeScale() {\n        processor.display.scale = displayScale.value;\n\n        processor.display.render();\n\n        settings.save(\"scale\", displayScale.value);\n    }\n\n    //Changes the background color of the display\n    changeBGColor() {\n      console.log(processor.display.bgColor, bgColorInput.value);  processor.display.bgColor = bgColorInput.value;\n     console.log(processor.display.bgColor, bgColorInput.value);   processor.display.render();\n\n        settings.save(\"bgColor\", bgColorInput.value);\n    }\n\n    //Changes the foreground color of the display\n    changeColor() {\n        processor.display.color = colorInput.value;\n        processor.display.render();\n\n        settings.save(\"color\", colorInput.value);\n    }\n\n    ShowFpsCounter() {\n        if (showfps.checked) {\n            fps.style.display = \"block\";\n        } else {\n            fps.style.display = \"none\";\n        }\n    }\n    //#endregion\n\n    //#region Sound\n    //Changes the volume of the speaker\n    changeVolume() {\n        //Set the volumeLevel to the Control value\n        processor.speaker.volumeLevel = volumeControl.value;\n        settings.save(\"volume\", volumeControl.value);\n    }\n    //Shows the volume level to user\n    sliderChange() {\n        volumeLevel.innerHTML = volumeControl.value;\n    }\n\n\n    //Changes the Oscillator type in the speaker\n    changeOscillator() {\n        //Set the wave to the Control value\n        processor.speaker.wave = oscillatorType.value;\n\n        settings.save(\"wave\", oscillatorType.value);\n    }\n\n    //Mutes the speaker\n    MuteAudio() {\n        //Check if the control is checked\n        if (muteControl.checked) {\n            //Mute the speaker. This will set it's volume to 0\n            processor.speaker.mute();\n            //settings.save(\"mute\", true);\n        } else {\n            //unmute the speaker giving it the volume control value\n            processor.speaker.unMute(volumeControl.value);\n            //settings.save(\"mute\", false);\n        }\n    }\n    //#endregion\n\n    //#region ROMS\n    //Loads a preset list of rom names from the EmulatorConstants file and adds them to the control\n    loadRomNames(cpu) {\n        //Map to the ROMS array\n        ROMS.map(rom => {\n            //Create a new option element\n            var option = document.createElement(\"option\");\n            //Fill details\n            option.value = rom;\n            option.text = rom;\n            //Append to the romSelect control\n            romSelect.appendChild(option);\n        });\n\n        //Call the loadSelectedRom method\n        this.loadSelectedRom();\n    }\n\n    //Loads a selected rom into the program\n    //ToDo: Change to take in a value so that user can load their own roms\n    async loadSelectedRom() {\n        //console.log(romSelect.value);\n\n        //Call the loadRom method from the CPU\n        await processor.loadRom(romSelect.value);\n        //Set the pauseBtn control text to read Pause as loading will unpause the CPU\n        //this.pauseBtn.innerHTML = \"Pause\";\n    }\n    //#endregion\n\n    //#region Debug\n    showDebugOptions() {\n        let debugPanel = document.getElementById('debugPanel');\n\n        if (debugChk.checked) {\n            debugPanel.style.display = \"block\"\n            processor.debug.Active = true;\n        } else {\n            debugPanel.style.display = \"none\"\n        }\n    }\n    //#endregion\n\n    //#endregion\n}",
			args: ["ROMS", "Settings"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Controls"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 576.500396909747,
			y: 141.43117372196053,
		},
	},
	{
		width: 332,
		height: 78,
		id: "nodular_1693117138939",
		type: "javascriptNode",
		position: {
			x: -151.00385528588595,
			y: -130.03692818820892,
		},
		data: {
			label: "disassembler.js",
			lang: "node",
			loading: false,
			func: "//Imports\nimport { INSTRUCTION_SET } from 'InstructionSet.js';\n\n//Export class\nexport class Disassembler {\n\n  //Disassemble a given opcode\n  disassemble(opcode) {\n      //Constants\n      //instruction set to found instruction from the InstructionSet\n      const instruction = INSTRUCTION_SET.find(\n          //opcode & bitwise instruction.mask === instruction.pattern\n          (instruction) => (opcode & instruction.mask) === instruction.pattern\n      );\n      //args = instruction.argurments\n      const args = instruction.arguments.map(\n          //opcode & arg.mask >> arg.shift\n          (arg) => (opcode & arg.mask) >> arg.shift\n      );\n\n      //Return instruction, args\n      return {\n          instruction,\n          args\n      };\n  }\n}",
			args: ["INSTRUCTION_SET "],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Disassembler"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -151.00385528588595,
			y: -130.03692818820892,
		},
	},
	{
		width: 329,
		height: 316,
		id: "nodular_1693117141000",
		type: "javascriptNode",
		position: {
			x: 465.1573635153359,
			y: -585.5780755716614,
		},
		data: {
			label: "cpu.js",
			lang: "node",
			loading: false,
			func: "//This is the CPU which interacts with the rest of the hardware. It's main task is to performe a CPU Cycle measured in steps per cycle\n//Each Cycle will run  10 steps taking in OPCodes and executing them.\nimport { SPRITE_WIDTH } from \"CharSet.js\";\nimport { STEP_SPEED } from \"CPUConstants.js\";\nimport { LOAD_PROGRAM_ADDRESS, MEMORY_SIZE } from \"MemoryConstants.js\";\nimport { Memory } from \"memory.js\"\nimport { Registers } from \"registers.js\";\nimport { Debug } from \"debug.js\";\nimport { Disassembler } from 'disassembler.js';\n\n\nexport class CPU {\n    constructor(display, keyboard, speaker) {\n        //Hardware\n        this.display = display;\n        this.keyboard = keyboard;\n        this.speaker = speaker;\n\n        //CPU Memory\n        this.memory = new Memory();\n        //CPU Registers\n        this.registers = new Registers();\n\n        //Instruction Speed\n        this.speed = STEP_SPEED;\n        //Handles Shift Quirk for Variations of Chip 8\n        this.quirk = \"Shift and Load Qurk\";\n        //Holds the current OpCode Instruction\n\n        this.opcode\n        //Opcode Disassembler\n        this.disassember = new Disassembler();\n\n        this.drawFlag = false;\n\n        this.debug = new Debug();\n    }\n\n    //Resets the CPU\n    reset() {\n        //Reset Memory, Registers, and Display\n        this.memory.reset();\n        this.registers.reset();\n        this.display.reset();\n\n        this.debug.reset();\n    }\n\n    ///Loads a selected rom into an arrayBuffer then calls loadRomIntoMemory\n    async loadRom(romName) {\n        //Get Rom Data\n        const rom = await fetch('src/utils/roms/INVADERS?raw-hex').then((response) => { return response.text(); })\n\n        //Load the Rom\n        //Set arrayBuffer to arraybuffer from rom\n    console.log(rom);  const arrayBuffer = await new Uint8Array(rom.match(/../g).map(h=>parseInt(h,16))).buffer;\n       console.log(arrayBuffer); //Set romBuffer to new Uint8Array(arrayBuffer)\n        const romBuffer = new Uint8Array(arrayBuffer);\n\n   console.log(arrayBuffer, romBuffer);     //Load rombuffer array into memory\n        this.loadRomIntoMemory(romBuffer);\n\n        //Set pause button text\n        document.getElementById('pause').innerHTML = \"Pause\";\n    }\n\n    //Load a given romBuffer into memory\n    loadRomIntoMemory(romBuffer) {\n        //Reset the emulator\n        this.reset(); //Reset Registers, Memory, and Display\n\n        //Check romBuffer Length + Loader address is less than memory size\n        console.assert(romBuffer.length + LOAD_PROGRAM_ADDRESS <= MEMORY_SIZE, \"Error rom is too large\");\n\n        //Insert rom into memory at location 0x200 which is the address where programs start in chip8\n        this.memory.memory.set(romBuffer, LOAD_PROGRAM_ADDRESS);\n    }\n\n    //CPU Cycle\n    //One CPU Cycle\n    cycle() {\n        //Since this will execute a batch of instructions based on speed will need to have the pause check inside\n        for (let i = 0; i < this.speed; i++) {\n            //Check if paused\n            //Used for programs that check for pause and await input like connect4 and tictac\n            if (!this.registers.paused) {\n                //Execute an instruction step\n                this.step();\n            }\n        }\n\n        //Check if paused\n        if (!this.registers.paused) {\n            //Update system timers\n            this.registers.updateTimers();\n        }\n\n        //Call play sound\n        this.speaker.playSound(this.registers.ST);\n\n        //Render only if flag is true\n        if (this.drawFlag) {\n            //Render display\n            this.display.render();\n            //Set draw flag to false\n            this.drawFlag = false;\n        }\n    }\n\n    //Step executes a cpu instruction and logs registers and instructions\n    //One Chip8 Instruction\n    step() {\n        //Get opcode from memory. Opcode is two bytes\n        this.opcode = this.memory.getOpCode(this.registers.PC); //Error is here\n\n        //Check that the opcode is not 0\n        if (this.opcode !== 0) {\n            //Execute instruction sending opcode\n            this.executeInstruction(this.opcode);\n\n            //If debug mode is active\n            if (this.debug.Active) {\n                // show registers\n                this.debug.DebugRegisters(this);\n            }\n        }\n    }\n\n    //Using Disassembler\n    executeInstruction(opcode) {\n        //Increment the program counter for next instruction\n        //Each instruction is 2 bytes to increment by 2\n        this.registers.PC += 2;\n\n        //Test Disassembler Debug\n        const {\n            instruction,\n            args\n        } = this.disassember.disassemble(opcode);\n        const {\n            id\n        } = instruction;\n\n        //To hex or not to hex?\n        this.debug.logOpcode(`${instruction.id}: 0x${opcode.toString(16)}`)\n\n        //Details on each instruction can be found inside the Constants/InstructinoSet.js file\n        //This includes name, mask, pattern, and arguments\n        switch (id) {\n            //Chip8 Instructions\n            //00E0\n            case 'CLS':\n                this.display.reset();\n                break;\n                //00EE\n            case 'RET':\n                this.registers.PC = this.registers.stackPop();\n                break;\n                //1NNN\n            case 'JP_ADDR':\n                this.registers.PC = args[0];\n                break;\n                //2NNN\n            case 'CALL_ADDR':\n                this.registers.stackPush(this.registers.PC);\n                this.registers.PC = args[0];\n                break;\n                //3XKK\n            case 'SE_VX_KK':\n                if (this.registers.V[args[0]] === args[1]) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //4XKK\n            case 'SNE_VX_KK':\n                if (this.registers.V[args[0]] !== args[1]) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //5XY0\n            case 'SE_VX_VY':\n                if (this.registers.V[args[0]] === this.registers.V[args[1]]) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //6XKK\n            case 'LD_VX_KK':\n                this.registers.V[args[0]] = args[1];\n                break;\n                //7XKK\n            case 'ADD_VX_KK':\n                this.registers.V[args[0]] += args[1];\n                break;\n                //8XY0\n            case 'LD_VX_VY':\n                this.registers.V[args[0]] = this.registers.V[args[1]];\n                break;\n                //8XY1\n            case 'OR_VX_VY':\n                this.registers.V[args[0]] |= this.registers.V[args[1]];\n                break;\n                //8XY2\n            case 'AND_VX_VY':\n                this.registers.V[args[0]] &= this.registers.V[args[1]];\n                break;\n                ////8XY3\n            case 'XOR_VX_VY':\n                this.registers.V[args[0]] ^= this.registers.V[args[1]];\n                break;\n                //8XY4\n            case 'ADD_VX_VY':\n                let sum = (this.registers.V[args[0]] += this.registers.V[args[1]]);\n\n                this.registers.V[0xF] = 0;\n\n                if (sum > 0xFF) {\n                    this.registers.V[0xF] = 1;\n                }\n\n                this.registers.V[args[0]] = sum;\n                break;\n                //8XY5\n            case 'SUB_VX_VY':\n                this.registers.V[0xF] = 0;\n\n                if (this.registers.V[args[0]] > this.registers.V[args[1]]) {\n                    this.registers.V[0xF] = 1;\n                }\n\n                this.registers.V[args[0]] -= this.registers.V[args[1]];\n                break;\n                //8XY6\n            case 'SHR_VX_VY':\n                //Set Vf to result of (Vx & 0x1)\n                this.registers.V[0xF] = (this.registers.V[args[0]] & 0x1);\n\n                //Quirk Behavior\n                if (this.quirk === \"No Quirk\") {\n                    //Original CHIP 8\n                    //Set Vx = Vy shifted to the right 1 bit\n                    this.registers.V[args[0]] = this.registers.V[args[1]] >>= 1;\n                } else {\n                    //Default\n                    //CHIP48 and SCHIP behavior\n                    //Shift Vx to the right 1 bit\n                    this.registers.V[args[0]] >>= 1;\n                }\n                break;\n                //8XY7\n            case 'SUBN_VX_VY':\n                this.registers.V[0xF] = 0;\n\n                if (this.registers.V[args[1]] > this.registers.V[args[0]]) {\n                    this.registers.V[0xF] = 1;\n                }\n\n                this.registers.V[args[0]] = this.registers.V[args[1]] - this.registers.V[args[0]];\n\n                break;\n                //8XYE\n            case 'SHL_VX_VY':\n                this.registers.V[0xF] = (this.registers.V[args[0]] & 0x80);\n                this.registers.V[args[0]] <<= 1;\n                break;\n                //9XY0\n            case 'SNE_VX_VY':\n                if (this.registers.V[args[0]] !== this.registers.V[args[1]]) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //ANNN\n            case 'LD_I_ADDR':\n                this.registers.I = args[0];\n                break;\n                //BNNN\n            case 'JP_V0_ADDR':\n                this.registers.PC = (args[0]) + this.registers.V[0];\n                break;\n                //CXKK\n            case 'RND_VX_KK':\n                let rand = Math.floor(Math.random() * 0xFF);\n\n                this.registers.V[args[0]] = rand & (opcode & 0xFF);\n                break;\n                //DXYN\n            case 'DRW_VX_VY_N':\n                let width = SPRITE_WIDTH;\n                let height = (opcode & 0xF);\n\n                this.registers.V[0xF] = 0;\n\n                for (let row = 0; row < height; row++) {\n                    let sprite = this.memory.memory[this.registers.I + row];\n\n                    for (let col = 0; col < width; col++) {\n                        if ((sprite & 0x80) > 0) {\n                            //If setPixel returns 1, a pixel was erased and set VF to 1\n                            if (this.display.setPixel(this.registers.V[args[0]] + col, this.registers.V[args[1]] + row)) {\n                                this.registers.V[0xF] = 1;\n                            }\n                        }\n                        //Shift the sprite left 1, this will move to the next col/bit\n                        //Ex. 10010000 << 1 will become 0010000\n                        sprite <<= 1;\n                    }\n                }\n\n                this.drawFlag = true;\n                break;\n                //EX9E\n            case 'SKP_VX':\n                if (this.keyboard.isKeyPressed(this.registers.V[args[0]])) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //EXA1\n            case 'SKNP_VX':\n                if (!this.keyboard.isKeyPressed(this.registers.V[args[0]])) {\n                    this.registers.PC += 2;\n                }\n                break;\n                //FX07\n            case 'LD_VX_DT':\n                this.registers.V[args[0]] = this.registers.DT;\n                break;\n                //FX0A\n                //Used in Connect4 and TicTac\n            case 'LD_VX_K':\n                this.registers.paused = true;\n\n                this.keyboard.onNextKeyPress = function(key) {\n                    this.registers.V[args[0]] = key;\n                    this.registers.paused = false;\n                }.bind(this);\n                break;\n                //FX15\n            case 'LD_DT_VX':\n                this.registers.DT = this.registers.V[args[0]];\n                break;\n                //FX18\n            case 'LD_ST_VX':\n                this.registers.ST = this.registers.V[args[0]];\n                break;\n                //FX1E\n            case 'ADD_I_VX':\n                this.registers.I += this.registers.V[args[0]];\n                break;\n                //FX29\n            case 'LD_F_VX':\n                this.registers.I = this.registers.V[args[0]] * 5;\n                break;\n                //FX33\n            case 'LD_B_VX':\n                //Get Hundreds place\n                this.memory.memory[this.registers.I] = parseInt(this.registers.V[args[0]] / 100);\n                //Get Tens place\n                this.memory.memory[this.registers.I + 1] = parseInt((this.registers.V[args[0]] % 100) / 10);\n                //Get Ones place\n                this.memory.memory[this.registers.I + 2] = parseInt(this.registers.V[args[0]] % 10);\n                break;\n                //FX55\n            case 'LD_I_VX':\n                for (let registerIndex = 0; registerIndex <= args[0]; registerIndex++) {\n                    this.memory.memory[this.registers.I + registerIndex] = this.registers.V[registerIndex];\n                }\n\n                //Check for quirk\n                if (this.quirk === \"No Quirk\") {\n                    this.registers.I += args[0] + 1;\n                } else if (this.quirk === \"Shift and Load Quirk\") {\n                    this.registers.I += args[0];\n                }\n                break;\n                //FX65\n            case 'LD_VX_I':\n                for (let registerIndex = 0; registerIndex <= args[0]; registerIndex++) {\n                    this.registers.V[registerIndex] = this.memory.memory[this.registers.I + registerIndex];\n                }\n\n                //Check for quirk\n                if (this.quirk === \"No Quirk\") {\n                    this.registers.I += args[0] + 1;\n                } else if (this.quirk === \"Shift and Load Qurk\") {\n                    this.registers.I += args[0];\n                }\n                break;\n\n\n            default:\n                console.error(`Instruction with id ${id} not found`, instruction, args);\n        }\n    }\n}",
			args: [
				"SPRITE_WIDTH",
				"STEP_SPEED",
				"LOAD_PROGRAM_ADDRESS",
				"MEMORY_SIZE",
				"Memory",
				"Registers",
				"Debug",
				"Disassembler",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["CPU"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 465.1573635153359,
			y: -585.5780755716614,
		},
	},
	{
		width: 144,
		height: 78,
		id: "nodular_1693117142602",
		type: "javascriptNode",
		position: {
			x: 48.05044902775171,
			y: -231.57090501598555,
		},
		data: {
			label: "debug.js",
			lang: "node",
			loading: false,
			func: '//Export Class\n//Used to log all debug features\nexport class Debug {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Debug Properties\n        this.opcodeLogs = new Array();\n\n        this.Active = false;\n    }\n\n    //Reset function\n    reset() {\n        this.opcodeLogs.fill(0);\n    }\n\n    logOpcode(msg) {\n        this.opcodeLogs.push(msg);\n    }\n\n    printLast() {\n        console.log(this.opcodeLogs[this.opcodeLogs.length - 1]);\n    }\n\n    //Updates the Register UI\n    DebugRegisters(cpu) {\n        //Load Registers\n        //16 bit V register\n        cpu.registers.V.forEach((x, index) => {\n            document.getElementById(`V${index}`).innerHTML = `0x${x.toString(16)}`;\n        });\n        //I register\n        document.getElementById("I").innerHTML = `0x${cpu.registers.I.toString(16)}`;\n        //Program Counter\n        document.getElementById("PC").innerHTML = `0x${cpu.registers.PC.toString(16)}`;\n        //Delay Timer\n        document.getElementById("DT").innerHTML = `0x${cpu.registers.DT.toString(16)}`;\n        //Sound Timer\n        document.getElementById(\'ST\').innerHTML = `0x${cpu.registers.ST.toString(16)}`;\n    }\n\n    //Updates the fpsCounter UI\n    ShowFPS(fps) {\n        //Get DOM element\n        let counter = document.getElementById(\'fpsCounter\');\n\n        //Set innerHTML to fps variable\n        counter.innerHTML = fps;\n    }\n}',
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Debug"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 48.05044902775171,
			y: -231.57090501598555,
		},
	},
	{
		width: 276,
		height: 214,
		id: "nodular_1693117144264",
		type: "javascriptNode",
		position: {
			x: 371.3594361021523,
			y: -241.31033746751854,
		},
		data: {
			label: "display.js",
			lang: "node",
			loading: false,
			func: "import { BG_COLOR, COLOR, DISPLAY_HEIGHT, DISPLAY_WIDTH, SCALE } from \"DisplayConstants.js\";\n\nexport class Display {\n    constructor() {\n        //Display properties\n        this.scale = SCALE; //Screen Scale\n       console.log(`this is the bg color${BG_COLOR}`); this.bgColor = BG_COLOR; //Background Color\n        this.color = COLOR; //Fore Color\n\n        //Get Screen and Context\n        this.screen = document.querySelector('canvas'); //Screen\n        this.context = this.screen.getContext('2d'); //2D Context\n\n        //Create a frameBuffer to hold all of the pixels\n        this.frameBuffer = new Array(DISPLAY_WIDTH * DISPLAY_HEIGHT); //Frame Buffer array\n\n        //Call Reset\n        this.reset();\n    }\n\n    //Reset the display\n    reset() {\n        //Clear the array of pixels by filling with 0s\n        this.frameBuffer.fill(0);\n        //Set the fill style to background color\n        this.context.fillStyle = this.bgColor;\n        //Fill the screen\n        this.context.fillRect(0, 0, this.screen.width, this.screen.height);\n\n        //Render display\n        this.render();\n    }\n\n    //Scales the screen by multiplying the scale against the default height and width\n    scaleScreen() {\n        //Set screen width and height and scale it\n        this.screen.width = DISPLAY_WIDTH * this.scale;\n        this.screen.height = DISPLAY_HEIGHT * this.scale;\n    }\n\n    //Sets a pixel to 1 or 0 inside the frameBuffer by XOR pixels\n    setPixel(x, y) {\n        //Constant Pixel X and Pixel Y location\n        //Calculate using modulo to handle screen wrap\n        const px = x % DISPLAY_WIDTH;\n        const py = y % DISPLAY_HEIGHT;\n\n        //Set pixelLocation to px + (py * width of the display constant)\n        let pixelLoc = px + (py * DISPLAY_WIDTH);\n\n        //Set pixel inside frameBuffer[pixelLoc as index] to XOR bitwise operation 0 or 1\n        this.frameBuffer[pixelLoc] ^= 1;\n\n        //Opposite Return if pixel was erased. 1 true for erased, 0 false for nothing erased\n        return !this.frameBuffer[pixelLoc];\n    }\n\n    render() {\n        //Scale the screen first\n        this.scaleScreen();\n\n        //Clear the canvas\n        this.context.clearRect(0, 0, this.screen.width, this.screen.height);\n        //Set background color\n        this.context.fillStyle = this.bgColor;\n        //Fill the canvas\n        this.context.fillRect(0, 0, this.screen.width, this.screen.height);\n\n        //Loop through the display width * height\n        for (let i = 0; i < DISPLAY_WIDTH * DISPLAY_HEIGHT; i++) {\n            //Get x location (i mod width) * scale\n            let x = (i % DISPLAY_WIDTH) * this.scale;\n\n            //Get y = Math.floor(i divide width) * scale\n            let y = Math.floor(i / DISPLAY_WIDTH) * this.scale;\n\n            //Check the frame buffer at location i for 0 or 1\n            if (this.frameBuffer[i]) {\n                //Set the fillstyle to color\n                this.context.fillStyle = this.color;\n\n                //Fill a new rectangle at location x,y setting its size to scale variable\n                this.context.fillRect(x, y, this.scale, this.scale);\n            }\n        }\n    }\n\n}",
			args: [
				"BG_COLOR",
				"COLOR",
				"DISPLAY_HEIGHT",
				"DISPLAY_WIDTH",
				"SCALE",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Display"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 371.3594361021523,
			y: -241.31033746751854,
		},
	},
	{
		width: 302,
		height: 112,
		id: "nodular_1693117151624",
		type: "javascriptNode",
		position: {
			x: 490.78278807907964,
			y: 5.69408312499149,
		},
		data: {
			label: "keyboard.js",
			lang: "node",
			loading: false,
			func: "//Imports\nimport { KEYMAP, NUMBER_OF_KEYS } from \"KeyboardConstants.js\";\n\n//Export Class\nexport class Keyboard {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Keyboard properties\n        //Keymap set to constant KEYMAP\n        this.KEYMAP = KEYMAP;\n        //keyPressed Array to size of keyboard fill with false\n        this.keyPressed = new Array(NUMBER_OF_KEYS).fill(false);\n\n        //onNextKeyPress to hold \n        this.onNextKeyPress = null;\n\n        //Add keydown and keyup event listeners to the window\n        window.addEventListener('keydown', this.onKeyDown.bind(this), false);\n        window.addEventListener('keyup', this.onKeyUp.bind(this), false);\n    }\n\n    //check if the provided keycode is pressed(true) in the array\n    isKeyPressed(keyCode) {\n        //Return value from keyPressed array using the provided value as an index     \n        return this.keyPressed[keyCode];\n    }\n\n    //onKeyDown Event for the window\n    onKeyDown(event) {\n        //Get key from keymap\n        let key = this.KEYMAP[event.which];\n\n        //Check that the key exists in the keymap\n        if (key != undefined) {\n            //Set keypressed at index key to true\n            this.keyPressed[key] = true;\n\n            // Make sure onNextKeyPress is initialized and the pressed key is actually mapped to a Chip-8 key\n            if (this.onNextKeyPress !== null && key) {\n                //parseInt the key pressed for onNextKeyPress\n                this.onNextKeyPress(parseInt(key));\n                //Set onNextKeyPress to null\n                this.onNextKeyPress = null;\n            }\n        }\n    }\n\n    //onKeyUp Event for the window\n    onKeyUp(event) {\n        //Get key from keymap\n        let key = this.KEYMAP[event.which];\n\n        //Check that the key exists in the keymap\n        if (!key != undefined) {\n            //Set keypressed at index key to true\n            this.keyPressed[key] = false;\n        }\n    }\n}",
			args: ["KEYMAP", "NUMBER_OF_KEYS "],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Keyboard"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 490.78278807907964,
			y: 5.69408312499149,
		},
	},
	{
		width: 321,
		height: 146,
		id: "nodular_1693117152644",
		type: "javascriptNode",
		position: {
			x: -153.58276896662431,
			y: -552.0129389559072,
		},
		data: {
			label: "memory.js",
			lang: "node",
			loading: false,
			func: '//Imports from constants folder\nimport { MEMORY_SIZE, SPRITE_SET_ADDRESS } from "MemoryConstants.js";\nimport { SPRITES } from "CharSet.js";\n\n//Export Class\nexport class Memory {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Memory properties\n        //Create a new Uint8Array called memory and set it\'s size to 4kb of memory\n        this.memory = new Uint8Array(MEMORY_SIZE);\n        //Call reset on creation\n        this.reset();\n    }\n\n    //Reset Memory\n    reset() {\n        //Clear out the array by filling it with 0\n        this.memory.fill(0)\n        //Load sprites into the array at the sprite_set_address\n        this.memory.set(SPRITES, SPRITE_SET_ADDRESS);\n    }\n\n    //Set Memory at location index\n    setMemory(index, value) {\n        //Verify memory location\n        this.assertMemory(index);\n        //Set location value\n        this.memory[index] = value;\n    }\n\n    //Get Memory at location index\n    getMemory(index) {\n        //Verify memory location\n        this.assertMemory(index);\n        //Return memory location value\n        return this.memory[index];\n    }\n\n    //Get Opcode from memory at location index\n    //Opcodes are two bytes\n    getOpCode(index) {\n        //Get the high byte from the index\n        const highByte = this.getMemory(index);\n        //Get the low byte from the index + 1\n        const lowByte = this.getMemory(index + 1);\n        //Return the opcode\n        return (highByte << 8) | lowByte;\n    }\n\n    //Verify Memory is within the bounds of the array\n    assertMemory(index) {\n        console.assert(index >= 0 && index < MEMORY_SIZE, `Error trying to access memory at index ${index}`);\n    }\n}',
			args: ["MEMORY_SIZE", "SPRITE_SET_ADDRESS", "SPRITES"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Memory"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -153.58276896662431,
			y: -552.0129389559072,
		},
	},
	{
		width: 156,
		height: 78,
		id: "nodular_1693117153766",
		type: "javascriptNode",
		position: {
			x: 637.8159645663707,
			y: 281.28050312244034,
		},
		data: {
			label: "speaker.js",
			lang: "node",
			loading: false,
			func: '//Class to be exported to other classes\nexport class Speaker {\n    //Called when creating an instance of the class\n    constructor() {\n        //Speaker properties\n        this.isMute = false;\n        this.soundEnabled = false; //Holds whether the sound is enabled or not. Object defined in speaker init function\n        this.volumeLevel = 0.3; //Holds the volume level of the speaker\n        this.wave = "square"; //Holds the wave of the oscillator\n\n        //Initialize speaker\n        speakerInit(this);\n    }\n\n    //Funtions\n    //Enables the sound Card\n    enableSound() {\n        this.soundEnabled = true;\n    }\n\n    //Disables the sound Card\n    disableSound() {\n        this.soundEnabled = false;\n    }\n\n    //User Controlled\n    mute() {\n        //Set audio level to 0\n        this.volumeLevel = 0.0;\n    }\n\n    unMute(value) {\n        //Set audio level to incoming value\n        //This will help when volume has been changed while the speaker is muted\n        this.volumeLevel = value;\n    }\n\n    //Play Sound based on sound timer value\n    playSound(st) {\n        if (st > 0) {\n            //Play\n            this.enableSound();\n        } else {\n            //Stop\n            this.disableSound();\n        }\n    }\n}\n\n//Initialization function\n//This creates the property soundEnabled for the speaker as well as creating the gain and audio context. It does not need to be exported.\nfunction speakerInit(speaker) {\n    //Check if browser supports audio context\n    if ("AudioContext" in window || "webkitAudioContext" in window) {\n        //Create audioContext and masterGain\n        const audioContext = new(AudioContext || webkitAudioContext)(); //Create an audio Context\n        const masterGain = new GainNode(audioContext); //Create a masterGain GainNode\n\n        //connect the masterGain to the audio context\n        masterGain.connect(audioContext.destination);\n\n        //Create variables soundEnabled and Oscillator\n        let soundEnabled = false;\n        let oscillator;\n\n        //Create an object and define its properties to speaker\n        Object.defineProperties(speaker, {\n            //Sound Enabled Property\n            soundEnabled: {\n                //Getter\n                get: function() {\n                    return soundEnabled;\n                },\n                //Setter\n                set: function(value) {\n                    //if incomming value already is equal to soundEnabled exit function\n                    if (value === soundEnabled) {\n                        return\n                    }\n\n                    //Set soundEnabled to incoming value\n                    soundEnabled = value;\n\n                    //Check soundEnabled true\n                    if (soundEnabled) {\n                        //Set masterGain gain value here so volume control works\n                        masterGain.gain.value = speaker.volumeLevel;\n                        //Start Oscillator giving it the audiocontext and the wave\n                        oscillator = new OscillatorNode(audioContext, {\n                            type: speaker.wave\n                        });\n                        //Connect the oscillator to the mastergain\n                        oscillator.connect(masterGain);\n                        //Start the oscillator\n                        oscillator.start();\n                    } else {\n                        //Stop the Oscillator\n                        oscillator.stop();\n                    }\n                }\n            }\n        })\n    }\n}',
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Speaker"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 637.8159645663707,
			y: 281.28050312244034,
		},
	},
	{
		width: 365,
		height: 146,
		id: "nodular_1693117154441",
		type: "javascriptNode",
		position: {
			x: -200.4843658665788,
			y: -390.51568588345805,
		},
		data: {
			label: "registers.js",
			lang: "node",
			loading: false,
			func: "//Imports\nimport { LOAD_PROGRAM_ADDRESS } from \"MemoryConstants.js\";\nimport { NUMBER_OF_REGISTERS, STACK_DEEP } from \"RegisterConstants.js\";\n\n//Export Class\nexport class Registers {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Register properties\n        this.V = new Uint8Array(NUMBER_OF_REGISTERS); //16 8-bit registers\n        this.I = 0; //Memory Address\n        this.stack = new Uint16Array(STACK_DEEP); //Operation Stack\n        this.SP = -1; //Stack pointer\n        this.PC = LOAD_PROGRAM_ADDRESS; //Program Counter set to Program starting address\n\n        this.DT = 0; //Delay Timer\n        this.ST = 0; //Sound Timer\n\n        this.paused = false; //Pause register\n    }\n\n    //Reset all variables\n    reset() {\n        this.V.fill(0);\n        this.I = 0;\n        this.stack.fill(0);\n        this.SP = -1;\n        this.PC = LOAD_PROGRAM_ADDRESS;\n\n        this.DT = 0;\n        this.ST = 0;\n\n        this.paused = false;\n    }\n\n    //Push new value to stack\n    stackPush(value) {\n        //Increase the Stack Position\n        this.SP++;\n        //Assert the Stack is not Overflowing\n        this.assertStackOverflow();\n        //Push a value to the stack at index Stack Position\n        this.stack[this.SP] = value\n    }\n\n    //Pop a new value from the stack\n    stackPop() {\n        //Set value to Stack index of Stack Position\n        const value = this.stack[this.SP];\n        //Decrease Stack Position\n        this.SP--;\n        //Assert the Stack is not Underflow\n        this.assertStackUnderflow();\n        //Return the value\n        return value;\n    }\n\n    //Assert the Stack is not Overflowing\n    assertStackOverflow() {\n        //Assert the Stack is less than the Stack Depth\n        console.assert(this.SP < STACK_DEEP, 'Error stack Overflow')\n    }\n\n    //Assert the Stack is not Underflowed\n    assertStackUnderflow() {\n        //Assert the Stack Position is greater than or equal to -1\n        console.assert(this.SP >= -1, 'Error stack underflow')\n    }\n\n    //Update system timers\n    updateTimers() {\n        if (this.DT > 0) {\n            this.DT -= 1;\n        }\n\n        if (this.ST > 0) {\n            this.ST -= 1;\n        }\n    }\n}",
			args: ["LOAD_PROGRAM_ADDRESS", "NUMBER_OF_REGISTERS", "STACK_DEEP"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Registers"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -200.4843658665788,
			y: -390.51568588345805,
		},
	},
	{
		width: 156,
		height: 78,
		id: "nodular_1693117155179",
		type: "javascriptNode",
		position: {
			x: 134.9107112530283,
			y: 216.91323268785234,
		},
		data: {
			label: "settings.js",
			lang: "node",
			loading: false,
			func: 'export class Settings {\n    constructor() {\n\n    }\n\n    save(name, value) {\n        // Check browser support\n        if (typeof(Storage) !== "undefined") {\n            // Store\n            localStorage.setItem(name, value);\n            console.log(`${name} ${value}`)\n\n        } else {\n            alert("Sorry, your browser does not support Web Storage...");\n        }\n    }\n\n    load(cpu) {\n        // Check browser support\n        if (typeof(Storage) !== "undefined") {\n            //Load\n            if (localStorage.length > 0) {\n                //CPU \n                cpu.speed = localStorage.getItem("speed");\n                cpu.quirk = localStorage.getItem("quirk");\n\n                // //Display\n                cpu.display.scale = localStorage.getItem("scale");\n\n                cpu.display.bgColor = localStorage.getItem("bgColor");\n                cpu.display.color = localStorage.getItem("color");\n\n                // // //Sound\n                cpu.speaker.volumeLevel = localStorage.getItem("volume");\n                cpu.speaker.wave = localStorage.getItem("wave");\n\n                //cpu.speaker.isMute = localStorage.getItem("mute");\n            }\n\n\n        } else {\n            alert("Sorry, your browser does not support Web Storage...");\n        }\n    }\n}',
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Settings"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 134.9107112530283,
			y: 216.91323268785234,
		},
	},
	{
		width: 192,
		height: 78,
		id: "nodular_1693715258313",
		type: "javascriptNode",
		position: {
			x: -104.88488967104527,
			y: -888.5738236877601,
		},
		data: {
			label: "CPUConstants.js",
			lang: "node",
			loading: false,
			func: "export const STEP_SPEED = 10; //Execution Speed",
			args: [],
			funcedit: true,
			returnArgs: ["STEP_SPEED"],
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		positionAbsolute: {
			x: -104.88488967104527,
			y: -888.5738236877601,
		},
		selected: false,
		dragging: false,
	},
	{
		width: 207,
		height: 112,
		id: "nodular_1693715259397",
		type: "javascriptNode",
		position: {
			x: -629.3998105503122,
			y: -886.9158843871168,
		},
		data: {
			label: "CharSet.js",
			lang: "node",
			loading: false,
			func: "export const SPRITE_WIDTH = 8;\n\nexport const SPRITES = [\n    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n    0x20, 0x60, 0x20, 0x20, 0x70, // 1\n    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n    0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n    0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n    0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n    0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n    0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n    0xF0, 0x80, 0xF0, 0x80, 0x80  // F\n];",
			args: [],
			returnArgs: ["SPRITE_WIDTH", "SPRITES"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -629.3998105503122,
			y: -886.9158843871168,
		},
		dragging: false,
	},
	{
		width: 224,
		height: 248,
		id: "nodular_1693715260792",
		type: "javascriptNode",
		position: {
			x: -885.1660924351049,
			y: -325.59024669125785,
		},
		data: {
			label: "DisplayConstants.js",
			lang: "node",
			loading: false,
			func: '//Export Constants\nexport const DISPLAY_WIDTH = 64; //Width\nexport const DISPLAY_HEIGHT = 32; //Height\n//export const SPRITE_HIGHT = 5;\nexport const SCALE = 10;\nexport const BG_COLOR = "#282828"; //Background\nexport const COLOR = "#FFB000"; //Foreground',
			args: [],
			returnArgs: [
				"DISPLAY_WIDTH",
				"DISPLAY_HEIGHT",
				"SPRITE_HIGHT",
				"SCALE",
				"BG_COLOR",
				"COLOR",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -885.1660924351049,
			y: -325.59024669125785,
		},
		dragging: false,
	},
	{
		width: 211,
		height: 112,
		id: "nodular_1693715262960",
		type: "javascriptNode",
		position: {
			x: 487.56917327292496,
			y: -791.6170387327379,
		},
		data: {
			label: "EmulatorConstants.js",
			lang: "node",
			loading: false,
			func: "//Export Constants\nexport const TIME_60_HZ = 1000 / 60; //60Hz\n//List of Roms Array\nexport const ROMS = [\n    '15PUZZLE',\n    'BLINKY',\n    'BLITZ',\n    'BRIX',\n    'CONNECT4',\n    'GUESS',\n    'HIDDEN',\n    'INVADERS',\n    'KALEID',\n    'MAZE',\n    'MERLIN',\n    'MISSILE',\n    'PONG',\n    'PONG2',\n    'PUZZLE',\n    'SYZYGY',\n    'TANK',\n    'TETRIS',\n    'TICTAC',\n    'UFO',\n    'VBRIX',\n    'VERS',\n    'WIPEOFF'\n]",
			args: [],
			returnArgs: ["TIME_60_HZ", "ROMS"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 487.56917327292496,
			y: -791.6170387327379,
		},
		dragging: false,
	},
	{
		width: 369,
		height: 316,
		id: "nodular_1693715265116",
		type: "javascriptNode",
		position: {
			x: -964.0644592284737,
			y: -28.37661124001273,
		},
		data: {
			label: "InstructionSet.js",
			lang: "node",
			loading: false,
			func: "//Export Constants\n\texport const MASK_NNN = { mask: 0x0fff }; //NNN\n\texport const MASK_N = { mask: 0x000f }; //Nibble\n\texport const MASK_X = { mask: 0x0f00, shift: 8 }; //X\n\texport const MASK_Y = { mask: 0x00f0, shift: 4 }; //Y\n\texport const MASK_KK = { mask: 0x00ff }; //KK\n\texport const MASK_HIGHEST_BYTE = 0xf000; //High byte\n\texport const MASK_HIGHEST_AND_LOWEST_BYTE = 0xf00f; //High and Low byte\n\t//Instruction Set Array\n\texport const INSTRUCTION_SET = [\n\t\n\t\t//Clear the display.\n\t\t{\n\t\t\tkey: 2,\n\t\t\tid: 'CLS',\n\t\t\tname: 'CLS',\n\t\t\tmask: 0xffff,\n\t\t\tpattern: 0x00e0,\n\t\t\targuments: [],\n\t\t},\n\t\n\t\t//Return from a subroutine\n\t\t//The interpreter sets the program counter to the address at the top of the stack, then subtracts 1 from the stack pointer.\n\t\t{\n\t\t\tkey: 3,\n\t\t\tid: 'RET',\n\t\t\tname: 'RET',\n\t\t\tmask: 0xffff,\n\t\t\tpattern: 0x00ee,\n\t\t\targuments: [],\n\t\t},\n\t\n\t\t//Jump to location nnn.\n\t\t//The interpreter sets the program counter to nnn.\n\t\t{\n\t\t\tkey: 4,\n\t\t\tid: 'JP_ADDR',\n\t\t\tname: 'JP',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x1000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Call subroutine at nnn.\n\t\t//The interpreter increments the stack pointer, then puts the current PC on the top of the stack. The PC is then set to nnn.\n\t\t{\n\t\t\tkey: 5,\n\t\t\tid: 'CALL_ADDR',\n\t\t\tname: 'CALL',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x2000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\t\n\t\t//Skip next instruction if Vx = kk.\n\t\t//The interpreter compares register Vx to kk, and if they are equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 6,\n\t\t\tid: 'SE_VX_KK',\n\t\t\tname: 'SE',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x3000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx != kk.\n\t\t//The interpreter compares register Vx to kk, and if they are not equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 7,\n\t\t\tid: 'SNE_VX_KK',\n\t\t\tname: 'SNE',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x4000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx = Vy.\n\t\t//The interpreter compares register Vx to register Vy, and if they are equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 8,\n\t\t\tid: 'SE_VX_VY',\n\t\t\tname: 'SE',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x5000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = kk.\n\t\t//The interpreter puts the value kk into register Vx.\n\t\t{\n\t\t\tkey: 9,\n\t\t\tid: 'LD_VX_KK',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x6000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Set Vx = Vx + kk.\n\t\t//Adds the value kk to the value of register Vx, then stores the result in Vx.\n\t\t{\n\t\t\tkey: 10,\n\t\t\tid: 'ADD_VX_KK',\n\t\t\tname: 'ADD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x7000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Set Vx = Vy.\n\t\t//Stores the value of register Vy in register Vx.\n\t\t{\n\t\t\tkey: 11,\n\t\t\tid: 'LD_VX_VY',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx OR Vy.\n\t\t//Performs a bitwise OR on the values of Vx and Vy, then stores the result in Vx. A bitwise OR compares \n\t\t//the corrseponding bits from two values, and if either bit is 1, then the same bit in the result is also 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 12,\n\t\t\tid: 'OR_VX_VY',\n\t\t\tname: 'OR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8001,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx AND Vy.\n\t\t//Performs a bitwise AND on the values of Vx and Vy, then stores the result in Vx. A bitwise AND compares the corrseponding \n\t\t//bits from two values, and if both bits are 1, then the same bit in the result is also 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 13,\n\t\t\tid: 'AND_VX_VY',\n\t\t\tname: 'AND',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8002,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx XOR Vy.\n\t\t//Performs a bitwise exclusive OR on the values of Vx and Vy, then stores the result in Vx. An exclusive OR compares the \n\t\t//corrseponding bits from two values, and if the bits are not both the same, then the corresponding bit in the result is set to 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 14,\n\t\t\tid: 'XOR_VX_VY',\n\t\t\tname: 'XOR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8003,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx + Vy, set VF = carry.\n\t\t//The values of Vx and Vy are added together. If the result is greater than 8 bits (i.e., > 255,) VF is set to 1, otherwise 0.\n\t\t//Only the lowest 8 bits of the result are kept, and stored in Vx.\n\t\t{\n\t\t\tkey: 15,\n\t\t\tid: 'ADD_VX_VY',\n\t\t\tname: 'ADD',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8004,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx - Vy, set VF = NOT borrow.\n\t\t//If Vx > Vy, then VF is set to 1, otherwise 0. Then Vy is subtracted from Vx, and the results stored in Vx.\n\t\t{\n\t\t\tkey: 16,\n\t\t\tid: 'SUB_VX_VY',\n\t\t\tname: 'SUB',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8005,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx SHR 1.\n\t\t//If the least-significant bit of Vx is 1, then VF is set to 1, otherwise 0. Then Vx is divided by 2.\n\t\t{\n\t\t\tkey: 17,\n\t\t\tid: 'SHR_VX_VY',\n\t\t\tname: 'SHR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8006,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vy - Vx, set VF = NOT borrow.\n\t\t//If Vy > Vx, then VF is set to 1, otherwise 0. Then Vx is subtracted from Vy, and the results stored in Vx.\n\t\t{\n\t\t\tkey: 18,\n\t\t\tid: 'SUBN_VX_VY',\n\t\t\tname: 'SUBN',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8007,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx SHL 1.\n\t\t//If the most-significant bit of Vx is 1, then VF is set to 1, otherwise to 0. Then Vx is multiplied by 2.\n\t\t{\n\t\t\tkey: 19,\n\t\t\tid: 'SHL_VX_VY',\n\t\t\tname: 'SHL',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x800e,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx != Vy.\n\t\t//The values of Vx and Vy are compared, and if they are not equal, the program counter is increased by 2.\n\t\t{\n\t\t\tkey: 20,\n\t\t\tid: 'SNE_VX_VY',\n\t\t\tname: 'SNE',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x9000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set I = nnn.\n\t\t//The value of register I is set to nnn.\n\t\t{\n\t\t\tkey: 21,\n\t\t\tid: 'LD_I_ADDR',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xa000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Jump to location nnn + V0.\n\t\t//The program counter is set to nnn plus the value of V0.\n\t\t{\n\t\t\tkey: 22,\n\t\t\tid: 'JP_V0_ADDR',\n\t\t\tname: 'JP',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xb000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Set Vx = random byte AND kk.\n\t\t//The interpreter generates a random number from 0 to 255, which is then ANDed with the value kk. \n\t\t//The results are stored in Vx. See instruction 8xy2 for more information on AND.\n\t\t{\n\t\t\tkey: 23,\n\t\t\tid: 'RND_VX_KK',\n\t\t\tname: 'RND',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xc000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.\n\t\t//The interpreter reads n bytes from memory, starting at the address stored in I. These bytes are then displayed \n\t\t//as sprites on screen at coordinates (Vx, Vy). Sprites are XORed onto the existing screen. If this causes any pixels \n\t\t//to be erased, VF is set to 1, otherwise it is set to 0. If the sprite is positioned so part of it is outside the coordinates \n\t\t//of the display, it wraps around to the opposite side of the screen. See instruction 8xy3 for more information on XOR, and section \n\t\t//2.4, Display, for more information on the Chip-8 screen and sprites.\n\t\t{\n\t\t\tkey: 24,\n\t\t\tid: 'DRW_VX_VY_N',\n\t\t\tname: 'DRW',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xd000,\n\t\t\targuments: [MASK_X, MASK_Y, MASK_N],\n\t\t},\n\t\n\t\t//Skip next instruction if key with the value of Vx is pressed.\n\t\t//Checks the keyboard, and if the key corresponding to the value of Vx is currently in the down position, PC is increased by 2.\n\t\t{\n\t\t\tkey: 25,\n\t\t\tid: 'SKP_VX',\n\t\t\tname: 'SKP',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xe09e,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Skip next instruction if key with the value of Vx is not pressed.\n\t\t//Checks the keyboard, and if the key corresponding to the value of Vx is currently in the up position, PC is increased by 2.\n\t\t{\n\t\t\tkey: 26,\n\t\t\tid: 'SKNP_VX',\n\t\t\tname: 'SKNP',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xe0a1,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set Vx = delay timer value.\n\t\t//The value of DT is placed into Vx.\n\t\t{\n\t\t\tkey: 27,\n\t\t\tid: 'LD_VX_DT',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf007,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Wait for a key press, store the value of the key in Vx.\n\t\t//All execution stops until a key is pressed, then the value of that key is stored in Vx.\n\t\t{\n\t\t\tkey: 28,\n\t\t\tid: 'LD_VX_K',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf00a,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set delay timer = Vx.\n\t\t//DT is set equal to the value of Vx.\n\t\t{\n\t\t\tkey: 29,\n\t\t\tid: 'LD_DT_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf015,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set sound timer = Vx.\n\t\t//ST is set equal to the value of Vx.\n\t\t{\n\t\t\tkey: 30,\n\t\t\tid: 'LD_ST_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf018,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set I = I + Vx.\n\t\t//The values of I and Vx are added, and the results are stored in I.\n\t\t{\n\t\t\tkey: 31,\n\t\t\tid: 'ADD_I_VX',\n\t\t\tname: 'ADD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf01e,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set I = location of sprite for digit Vx.\n\t\t//The value of I is set to the location for the hexadecimal sprite corresponding to the value \n\t\t//of Vx. See section 2.4, Display, for more information on the Chip-8 hexadecimal font.\n\t\t{\n\t\t\tkey: 32,\n\t\t\tid: 'LD_F_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf029,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Store BCD representation of Vx in memory locations I, I+1, and I+2.\n\t\t//The interpreter takes the decimal value of Vx, and places the hundreds digit in memory at \n\t\t//location in I, the tens digit at location I+1, and the ones digit at location I+2.\n\t\t{\n\t\t\tkey: 33,\n\t\t\tid: 'LD_B_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf033,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Store registers V0 through Vx in memory starting at location I.\n\t\t//The interpreter copies the values of registers V0 through Vx into memory, starting at the address in I.\n\t\t{\n\t\t\tkey: 34,\n\t\t\tid: 'LD_I_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf055,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Read registers V0 through Vx from memory starting at location I.\n\t\t//The interpreter reads values from memory starting at location I into registers V0 through Vx.\n\t\t{\n\t\t\tkey: 35,\n\t\t\tid: 'LD_VX_I',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf065,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\n\t\n\t\t//Chip48 Instructions\n\t\n\t\t{\n\t\t\tkey: 36,\n\t\t\tid: 'SCD nibble',\n\t\t\tname: 'SCD',\n\t\t\tmask: MASK_N,\n\t\t\tpattern: 0x00C0,\n\t\t\targuments: [],\n\t\t}\n\t];\n\t\n\t//TODO: Add Super chip8 instructions",
			args: [],
			returnArgs: [
				"MASK_NNN",
				"MASK_N",
				"MASK_X",
				"MASK_Y",
				"MASK_KK",
				"MASK_HIGHEST_BYTE",
				"MASK_HIGHEST_AND_LOWEST_BYTE",
				"INSTRUCTION_SET",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -964.0644592284737,
			y: -28.37661124001273,
		},
		dragging: false,
	},
	{
		width: 235,
		height: 112,
		id: "nodular_1693715270047",
		type: "javascriptNode",
		position: {
			x: 41.750527191993456,
			y: 31.816941547270332,
		},
		data: {
			label: "KeyboardConstants.js",
			lang: "node",
			loading: false,
			func: "//Export Constants\n\texport const NUMBER_OF_KEYS = 16; //Number of keys in the keypad\n\t\n\t//Keymap of the keyboard\n\texport const KEYMAP = {\n\t\t\t49: 0x1, // 1\n\t\t\t50: 0x2, // 2\n\t\t\t51: 0x3, // 3\n\t\t\t52: 0xc, // 4\n\t\t\t81: 0x4, // Q\n\t\t\t87: 0x5, // W\n\t\t\t69: 0x6, // E\n\t\t\t82: 0xD, // R\n\t\t\t65: 0x7, // A\n\t\t\t83: 0x8, // S\n\t\t\t68: 0x9, // D\n\t\t\t70: 0xE, // F\n\t\t\t90: 0xA, // Z\n\t\t\t88: 0x0, // X\n\t\t\t67: 0xB, // C\n\t\t\t86: 0xF  // V\n\t}",
			args: [],
			returnArgs: ["NUMBER_OF_KEYS", "KEYMAP"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 41.750527191993456,
			y: 31.816941547270332,
		},
		dragging: false,
	},
	{
		width: 298,
		height: 146,
		id: "nodular_1693715271068",
		type: "javascriptNode",
		position: {
			x: -732.1496694316074,
			y: -738.2122902678527,
		},
		data: {
			label: "MemoryConstants.js",
			lang: "node",
			loading: false,
			func: "export const MEMORY_SIZE = 4095; //Max Memory Size\n\texport const LOAD_PROGRAM_ADDRESS = 0x200; //Program Address Start Location\n\texport const SPRITE_SET_ADDRESS = 0x000; //Sprite Load Location",
			args: [],
			returnArgs: [
				"MEMORY_SIZE",
				"LOAD_PROGRAM_ADDRESS",
				"SPRITE_SET_ADDRESS",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -732.1496694316074,
			y: -738.2122902678527,
		},
		dragging: false,
	},
	{
		width: 279,
		height: 112,
		id: "nodular_1693716362447",
		type: "javascriptNode",
		position: {
			x: -931.8430809093092,
			y: -543.3614837273406,
		},
		data: {
			label: "RegisterConstants.js",
			lang: "node",
			loading: false,
			func: "export const NUMBER_OF_REGISTERS = 16; //Number of different registers 8 bytes each\n\texport const STACK_DEEP = 16; //Stack Depth",
			args: [],
			funcedit: true,
			returnArgs: ["NUMBER_OF_REGISTERS", "STACK_DEEP"],
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		positionAbsolute: {
			x: -931.8430809093092,
			y: -543.3614837273406,
		},
		selected: false,
		dragging: false,
	},
];
