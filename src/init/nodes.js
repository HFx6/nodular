export default [
	{
		width: 188,
		height: 248,
		id: "nodular_1693117134023",
		type: "javascriptNode",
		position: {
			x: 1070.7692649560145,
			y: -408.1950663131147,
		},
		data: {
			label: "chip8.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: '//This is the Emulator Class which will initialize the hardware and also any and all DOM Debug features on the html page\nimport { TIME_60_HZ } from "EmulatorConstants.js";\nimport { CPU } from "cpu.js";\nimport { Display } from "display.js";\nimport { Keyboard } from "keyboard.js";\nimport { Controls } from "controls.js";\nimport { Speaker } from "speaker.js";\n\n//#region Initialize\n//Create new instances of the hardware\nconst display = new Display();\nconst keyboard = new Keyboard();\nconst speaker = new Speaker();\n\n//Attatch the hardware to a new instance of the CPU\nconst cpu = new CPU(display, keyboard, speaker);\n//#endregion\n\n//Loads the pages controls and handles their events\nconst controls = new Controls(cpu);\n\n\n//Variables for calculating FPS\nvar now, then, delta;\n\nfunction init() {\n    //#region Start Emulator\n    //Get Start\n    then = Date.now();\n\n    //Call the loop\n    //Infinite Function\n    emuCycle();\n    //#endregion\n}\n\n//#region EmuCycle\n//This should run at 60Hz but can be changed by fps counter\nfunction emuCycle() {\n    var timePassed = (Date.now() - now) / 1000;\n    //Framerate Calculations\n    now = Date.now();\n    delta = now - then;\n    var fps = Math.round(1 / timePassed);\n\n    //This will force 60Hz\n    if (delta > TIME_60_HZ) {\n        //Contextual Comments from https://gist.github.com/elundmark\n        // update time stuffs\n        // Just `then = now` is not enough.\n        // Lets say we set fps at 10 which means\n        // each frame must take 100ms\n        // Now frame executes in 16ms (60fps) so\n        // the loop iterates 7 times (16*7 = 112ms) until\n        // delta > interval === true\n        // Eventually this lowers down the FPS as\n        // 112*10 = 1120ms (NOT 1000ms).\n        // So we have to get rid of that extra 12ms\n        // by subtracting delta (112) % interval (100).\n        // Hope that makes sense.\n        then = now - (delta % TIME_60_HZ);\n\n        //Call the cpu cycle method\n        //each cycle is 10 steps\n        cpu.cycle();\n        if (!cpu.registers.paused) {\n            cpu.debug.ShowFPS(fps);\n        }\n    }\n\n    //Recursion\n    requestAnimationFrame(emuCycle);\n}\n\n//#endregion\n\n//Call Initialization Function\ninit();',
			args: [
				"TIME_60_HZ ",
				"CPU",
				"Display",
				"Keyboard",
				"Controls",
				"Speaker",
			],
			funcedit: true,
			argTypes: ["chip8"],
			returnType: "",
			returnArgs: [],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 1070.7692649560145,
			y: -408.1950663131147,
		},
	},
	{
		width: 216,
		height: 112,
		id: "nodular_1693117135705",
		type: "javascriptNode",
		position: {
			x: 576.500396909747,
			y: 141.43117372196053,
		},
		data: {
			label: "controls.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "import { ROMS } from \"EmulatorConstants.js\";\nimport { Settings } from \"settings.js\";\n\n//#region Page Controls\n//CPU\nconst speedStepText = document.getElementById('speedStep'); //Changable\nconst stepCPU = document.getElementById('step');\nconst pauseBtn = document.getElementById('pause');\nconst quirk = document.getElementById('quirkType'); //Changable\n\n//Display\nconst displayScale = document.getElementById('displayScale'); //Changable\n\n//const fpsScale = document.getElementById('fps'); //TODO: may move to cpu\n\nconst bgColorInput = document.getElementById('bgColor'); //Changable\nconst colorInput = document.getElementById('color'); //Changable\n\nconst fps = document.getElementById('fpsControl');\nconst showfps = document.getElementById('showfps');\n\n//Sound\nconst volumeControl = document.getElementById('volumeControl'); //Changable\nconst volumeLevel = document.getElementById('volumeNumber');\nconst oscillatorType = document.getElementById('oscillator'); //Changable\nconst muteControl = document.getElementById('sound'); //Changable\n\n//ROMS\nconst romSelect = document.getElementById('roms');\nconst loadBtn = document.getElementById('load');\n\n//Debug\nconst debugChk = document.getElementById('debug');\n\nconst settings = new Settings(); //Create new instance of settings\n//#endregion\n\n//Variable to hold the CPU instance\nvar processor;\n\nexport class Controls {\n    constructor(cpu) {\n        //CPU Instance\n        processor = cpu;\n\n        //#region Controls Event Listeners\n        //CPU\n        pauseBtn.addEventListener('click', this.pause);\n        stepCPU.addEventListener('click', this.stepNext);\n        speedStepText.addEventListener('input', this.ChangeSpeed);\n        quirk.addEventListener('click', this.setQuirk)\n\n        //Display\n        displayScale.addEventListener('input', this.ChangeScale);\n        bgColorInput.addEventListener('change', this.changeBGColor);\n        colorInput.addEventListener('change', this.changeColor);\n        showfps.addEventListener('click', this.ShowFpsCounter);\n\n        //Sound\n        volumeControl.addEventListener('change', this.changeVolume);\n        volumeControl.addEventListener('input', this.sliderChange)\n\n        oscillatorType.addEventListener('click', this.changeOscillator);\n        muteControl.addEventListener('click', this.MuteAudio);\n\n        //ROMS\n        loadBtn.addEventListener('click', this.loadSelectedRom);\n\n        //Debug\n        debugChk.addEventListener('click', this.showDebugOptions)\n\n        //Window\n\n        //#endregion\n\n        this.loadControls();\n    }\n\n    //Loads the controls with values from the emulator\n    loadControls() {\n        settings.load(processor); //Load Local Storage int CPU\n\n        //#region Controls Values Load\n        //CPU\n        speedStepText.value = processor.speed;\n        quirk.value = processor.quirk;\n\n        //Display\n        displayScale.value = processor.display.scale;\n\n        bgColorInput.value = '#000000';\n        colorInput.value = '#FFFFFF'\n\n        //Sound\n        volumeControl.value = processor.speaker.volumeLevel;\n        volumeLevel.innerHTML = processor.speaker.volumeLevel;\n\n        oscillatorType.value = processor.speaker.wave;\n\n        //#endregion\n\n        //ROMS\n        this.loadRomNames(); //Loads the roms from the roms folder\n    }\n\n\n\n    //////////////////////////Methods to handle the controls///////////////////////////////////////\n\n    //#region Controls Functions\n    //#region CPU\n    //Pause the CPU\n    pause() {\n        //Check if CPU is already paused\n        if (processor.registers.paused) {\n            //Set register to false and change control text to Pause\n            processor.registers.paused = false;\n            pauseBtn.innerHTML = \"Pause\";\n        } else {\n            //Set register to true and change control text to Play\n            processor.registers.paused = true;\n            pauseBtn.innerHTML = \"Play\";\n        }\n    }\n\n    //Step the CPU by one instruction\n    stepNext() {\n        //call CPU step method\n        processor.step();\n        //Render the display\n        processor.display.render();\n    }\n\n    //Change cpu speed\n    //This changes how many instructions per CPU cycle\n    ChangeSpeed() {\n        processor.speed = speedStepText.value;\n\n        settings.save(\"speed\", speedStepText.value); //Save value\n    }\n\n    //Turns on or off cpu quirk which handles different types of chip8 cpus\n    setQuirk() {\n        processor.quirk = quirk.value;\n\n        settings.save(\"quirk\", quirk.value); //Save value\n    }\n    //#endregion\n\n    //#region  Display\n    //Change the scale of the display on the page\n    ChangeScale() {\n        processor.display.scale = displayScale.value;\n\n        processor.display.render();\n\n        settings.save(\"scale\", displayScale.value);\n    }\n\n    //Changes the background color of the display\n    changeBGColor() {\n      console.log(processor.display.bgColor, bgColorInput.value);  processor.display.bgColor = bgColorInput.value;\n     console.log(processor.display.bgColor, bgColorInput.value);   processor.display.render();\n\n        settings.save(\"bgColor\", bgColorInput.value);\n    }\n\n    //Changes the foreground color of the display\n    changeColor() {\n        processor.display.color = colorInput.value;\n        processor.display.render();\n\n        settings.save(\"color\", colorInput.value);\n    }\n\n    ShowFpsCounter() {\n        if (showfps.checked) {\n            fps.style.display = \"block\";\n        } else {\n            fps.style.display = \"none\";\n        }\n    }\n    //#endregion\n\n    //#region Sound\n    //Changes the volume of the speaker\n    changeVolume() {\n        //Set the volumeLevel to the Control value\n        processor.speaker.volumeLevel = volumeControl.value;\n        settings.save(\"volume\", volumeControl.value);\n    }\n    //Shows the volume level to user\n    sliderChange() {\n        volumeLevel.innerHTML = volumeControl.value;\n    }\n\n\n    //Changes the Oscillator type in the speaker\n    changeOscillator() {\n        //Set the wave to the Control value\n        processor.speaker.wave = oscillatorType.value;\n\n        settings.save(\"wave\", oscillatorType.value);\n    }\n\n    //Mutes the speaker\n    MuteAudio() {\n        //Check if the control is checked\n        if (muteControl.checked) {\n            //Mute the speaker. This will set it's volume to 0\n            processor.speaker.mute();\n            //settings.save(\"mute\", true);\n        } else {\n            //unmute the speaker giving it the volume control value\n            processor.speaker.unMute(volumeControl.value);\n            //settings.save(\"mute\", false);\n        }\n    }\n    //#endregion\n\n    //#region ROMS\n    //Loads a preset list of rom names from the EmulatorConstants file and adds them to the control\n    loadRomNames(cpu) {\n        //Map to the ROMS array\n        ROMS.map(rom => {\n            //Create a new option element\n            var option = document.createElement(\"option\");\n            //Fill details\n            option.value = rom;\n            option.text = rom;\n            //Append to the romSelect control\n            romSelect.appendChild(option);\n        });\n\n        //Call the loadSelectedRom method\n        this.loadSelectedRom();\n    }\n\n    //Loads a selected rom into the program\n    //ToDo: Change to take in a value so that user can load their own roms\n    async loadSelectedRom() {\n        //console.log(romSelect.value);\n\n        //Call the loadRom method from the CPU\n        await processor.loadRom(romSelect.value);\n        //Set the pauseBtn control text to read Pause as loading will unpause the CPU\n        //this.pauseBtn.innerHTML = \"Pause\";\n    }\n    //#endregion\n\n    //#region Debug\n    showDebugOptions() {\n        let debugPanel = document.getElementById('debugPanel');\n\n        if (debugChk.checked) {\n            debugPanel.style.display = \"block\"\n            processor.debug.Active = true;\n        } else {\n            debugPanel.style.display = \"none\"\n        }\n    }\n    //#endregion\n\n    //#endregion\n}",
			args: ["ROMS", "Settings"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Controls"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 576.500396909747,
			y: 141.43117372196053,
		},
	},
	{
		width: 332,
		height: 78,
		id: "nodular_1693117138939",
		type: "javascriptNode",
		position: {
			x: -151.00385528588595,
			y: -130.03692818820892,
		},
		data: {
			label: "disassembler.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Imports\nimport { INSTRUCTION_SET } from 'InstructionSet.js';\n\n//Export class\nexport class Disassembler {\n\n  //Disassemble a given opcode\n  disassemble(opcode) {\n      //Constants\n      //instruction set to found instruction from the InstructionSet\n      const instruction = INSTRUCTION_SET.find(\n          //opcode & bitwise instruction.mask === instruction.pattern\n          (instruction) => (opcode & instruction.mask) === instruction.pattern\n      );\n      //args = instruction.argurments\n      const args = instruction.arguments.map(\n          //opcode & arg.mask >> arg.shift\n          (arg) => (opcode & arg.mask) >> arg.shift\n      );\n\n      //Return instruction, args\n      return {\n          instruction,\n          args\n      };\n  }\n}",
			args: ["INSTRUCTION_SET "],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Disassembler"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -151.00385528588595,
			y: -130.03692818820892,
		},
	},
	{
		width: 329,
		height: 316,
		id: "nodular_1693117141000",
		type: "javascriptNode",
		position: {
			x: 465.1573635153359,
			y: -585.5780755716614,
		},
		data: {
			label: "cpu.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//This is the CPU which interacts with the rest of the hardware. It's main task is to performe a CPU Cycle measured in steps per cycle\n//Each Cycle will run  10 steps taking in OPCodes and executing them.\nimport {\n\tSPRITE_WIDTH\n} from \"CharSet.js\";\nimport {\n\tSTEP_SPEED\n} from \"CPUConstants.js\";\nimport {\n\tLOAD_PROGRAM_ADDRESS,\n\tMEMORY_SIZE\n} from \"MemoryConstants.js\";\nimport {\n\tMemory\n} from \"memory.js\"\nimport {\n\tRegisters\n} from \"registers.js\";\nimport {\n\tDebug\n} from \"debug.js\";\nimport {\n\tDisassembler\n} from 'disassembler.js';\n\n\nexport class CPU {\n\tconstructor(display, keyboard, speaker) {\n\t\t//Hardware\n\t\tthis.display = display;\n\t\tthis.keyboard = keyboard;\n\t\tthis.speaker = speaker;\n\n\t\t//CPU Memory\n\t\tthis.memory = new Memory();\n\t\t//CPU Registers\n\t\tthis.registers = new Registers();\n\n\t\t//Instruction Speed\n\t\tthis.speed = STEP_SPEED;\n\t\t//Handles Shift Quirk for Variations of Chip 8\n\t\tthis.quirk = \"Shift and Load Qurk\";\n\t\t//Holds the current OpCode Instruction\n\n\t\tthis.opcode\n\t\t//Opcode Disassembler\n\t\tthis.disassember = new Disassembler();\n\n\t\tthis.drawFlag = false;\n\n\t\tthis.debug = new Debug();\n\t}\n\n\t//Resets the CPU\n\treset() {\n\t\t//Reset Memory, Registers, and Display\n\t\tthis.memory.reset();\n\t\tthis.registers.reset();\n\t\tthis.display.reset();\n\n\t\tthis.debug.reset();\n\t}\n\n\t///Loads a selected rom into an arrayBuffer then calls loadRomIntoMemory\n\tasync loadRom(romName) {\n\t\t//Get Rom Data\n\t\tconst rom = await fetch('roms/INVADERS?raw-hex').then((response) => {\n\t\t\treturn response.text();\n\t\t})\n\n\t\t//Load the Rom\n\t\t//Set arrayBuffer to arraybuffer from rom\n\t\tconsole.log(rom);\n\t\tconst arrayBuffer = await new Uint8Array(rom.match(/../g).map(h => parseInt(h, 16))).buffer;\n\t\tconsole.log(arrayBuffer); //Set romBuffer to new Uint8Array(arrayBuffer)\n\t\tconst romBuffer = new Uint8Array(arrayBuffer);\n\n\t\tconsole.log(arrayBuffer, romBuffer); //Load rombuffer array into memory\n\t\tthis.loadRomIntoMemory(romBuffer);\n\n\t\t//Set pause button text\n\t\tdocument.getElementById('pause').innerHTML = \"Pause\";\n\t}\n\n\t//Load a given romBuffer into memory\n\tloadRomIntoMemory(romBuffer) {\n\t\t//Reset the emulator\n\t\tthis.reset(); //Reset Registers, Memory, and Display\n\n\t\t//Check romBuffer Length + Loader address is less than memory size\n\t\tconsole.assert(romBuffer.length + LOAD_PROGRAM_ADDRESS <= MEMORY_SIZE, \"Error rom is too large\");\n\n\t\t//Insert rom into memory at location 0x200 which is the address where programs start in chip8\n\t\tthis.memory.memory.set(romBuffer, LOAD_PROGRAM_ADDRESS);\n\t}\n\n\t//CPU Cycle\n\t//One CPU Cycle\n\tcycle() {\n\t\t//Since this will execute a batch of instructions based on speed will need to have the pause check inside\n\t\tfor (let i = 0; i < this.speed; i++) {\n\t\t\t//Check if paused\n\t\t\t//Used for programs that check for pause and await input like connect4 and tictac\n\t\t\tif (!this.registers.paused) {\n\t\t\t\t//Execute an instruction step\n\t\t\t\tthis.step();\n\t\t\t}\n\t\t}\n\n\t\t//Check if paused\n\t\tif (!this.registers.paused) {\n\t\t\t//Update system timers\n\t\t\tthis.registers.updateTimers();\n\t\t}\n\n\t\t//Call play sound\n\t\tthis.speaker.playSound(this.registers.ST);\n\n\t\t//Render only if flag is true\n\t\tif (this.drawFlag) {\n\t\t\t//Render display\n\t\t\tthis.display.render();\n\t\t\t//Set draw flag to false\n\t\t\tthis.drawFlag = false;\n\t\t}\n\t}\n\n\t//Step executes a cpu instruction and logs registers and instructions\n\t//One Chip8 Instruction\n\tstep() {\n\t\t//Get opcode from memory. Opcode is two bytes\n\t\tthis.opcode = this.memory.getOpCode(this.registers.PC); //Error is here\n\n\t\t//Check that the opcode is not 0\n\t\tif (this.opcode !== 0) {\n\t\t\t//Execute instruction sending opcode\n\t\t\tthis.executeInstruction(this.opcode);\n\n\t\t\t//If debug mode is active\n\t\t\tif (this.debug.Active) {\n\t\t\t\t// show registers\n\t\t\t\tthis.debug.DebugRegisters(this);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Using Disassembler\n\texecuteInstruction(opcode) {\n\t\t//Increment the program counter for next instruction\n\t\t//Each instruction is 2 bytes to increment by 2\n\t\tthis.registers.PC += 2;\n\n\t\t//Test Disassembler Debug\n\t\tconst {\n\t\t\tinstruction,\n\t\t\targs\n\t\t} = this.disassember.disassemble(opcode);\n\t\tconst {\n\t\t\tid\n\t\t} = instruction;\n\n\t\t//To hex or not to hex?\n\t\tthis.debug.logOpcode(`${instruction.id}: 0x${opcode.toString(16)}`)\n\n\t\t//Details on each instruction can be found inside the Constants/InstructinoSet.js file\n\t\t//This includes name, mask, pattern, and arguments\n\t\tswitch (id) {\n\t\t\t//Chip8 Instructions\n\t\t\t//00E0\n\t\t\tcase 'CLS':\n\t\t\t\tthis.display.reset();\n\t\t\t\tbreak;\n\t\t\t\t//00EE\n\t\t\tcase 'RET':\n\t\t\t\tthis.registers.PC = this.registers.stackPop();\n\t\t\t\tbreak;\n\t\t\t\t//1NNN\n\t\t\tcase 'JP_ADDR':\n\t\t\t\tthis.registers.PC = args[0];\n\t\t\t\tbreak;\n\t\t\t\t//2NNN\n\t\t\tcase 'CALL_ADDR':\n\t\t\t\tthis.registers.stackPush(this.registers.PC);\n\t\t\t\tthis.registers.PC = args[0];\n\t\t\t\tbreak;\n\t\t\t\t//3XKK\n\t\t\tcase 'SE_VX_KK':\n\t\t\t\tif (this.registers.V[args[0]] === args[1]) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//4XKK\n\t\t\tcase 'SNE_VX_KK':\n\t\t\t\tif (this.registers.V[args[0]] !== args[1]) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//5XY0\n\t\t\tcase 'SE_VX_VY':\n\t\t\t\tif (this.registers.V[args[0]] === this.registers.V[args[1]]) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//6XKK\n\t\t\tcase 'LD_VX_KK':\n\t\t\t\tthis.registers.V[args[0]] = args[1];\n\t\t\t\tbreak;\n\t\t\t\t//7XKK\n\t\t\tcase 'ADD_VX_KK':\n\t\t\t\tthis.registers.V[args[0]] += args[1];\n\t\t\t\tbreak;\n\t\t\t\t//8XY0\n\t\t\tcase 'LD_VX_VY':\n\t\t\t\tthis.registers.V[args[0]] = this.registers.V[args[1]];\n\t\t\t\tbreak;\n\t\t\t\t//8XY1\n\t\t\tcase 'OR_VX_VY':\n\t\t\t\tthis.registers.V[args[0]] |= this.registers.V[args[1]];\n\t\t\t\tbreak;\n\t\t\t\t//8XY2\n\t\t\tcase 'AND_VX_VY':\n\t\t\t\tthis.registers.V[args[0]] &= this.registers.V[args[1]];\n\t\t\t\tbreak;\n\t\t\t\t////8XY3\n\t\t\tcase 'XOR_VX_VY':\n\t\t\t\tthis.registers.V[args[0]] ^= this.registers.V[args[1]];\n\t\t\t\tbreak;\n\t\t\t\t//8XY4\n\t\t\tcase 'ADD_VX_VY':\n\t\t\t\tlet sum = (this.registers.V[args[0]] += this.registers.V[args[1]]);\n\n\t\t\t\tthis.registers.V[0xF] = 0;\n\n\t\t\t\tif (sum > 0xFF) {\n\t\t\t\t\tthis.registers.V[0xF] = 1;\n\t\t\t\t}\n\n\t\t\t\tthis.registers.V[args[0]] = sum;\n\t\t\t\tbreak;\n\t\t\t\t//8XY5\n\t\t\tcase 'SUB_VX_VY':\n\t\t\t\tthis.registers.V[0xF] = 0;\n\n\t\t\t\tif (this.registers.V[args[0]] > this.registers.V[args[1]]) {\n\t\t\t\t\tthis.registers.V[0xF] = 1;\n\t\t\t\t}\n\n\t\t\t\tthis.registers.V[args[0]] -= this.registers.V[args[1]];\n\t\t\t\tbreak;\n\t\t\t\t//8XY6\n\t\t\tcase 'SHR_VX_VY':\n\t\t\t\t//Set Vf to result of (Vx & 0x1)\n\t\t\t\tthis.registers.V[0xF] = (this.registers.V[args[0]] & 0x1);\n\n\t\t\t\t//Quirk Behavior\n\t\t\t\tif (this.quirk === \"No Quirk\") {\n\t\t\t\t\t//Original CHIP 8\n\t\t\t\t\t//Set Vx = Vy shifted to the right 1 bit\n\t\t\t\t\tthis.registers.V[args[0]] = this.registers.V[args[1]] >>= 1;\n\t\t\t\t} else {\n\t\t\t\t\t//Default\n\t\t\t\t\t//CHIP48 and SCHIP behavior\n\t\t\t\t\t//Shift Vx to the right 1 bit\n\t\t\t\t\tthis.registers.V[args[0]] >>= 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//8XY7\n\t\t\tcase 'SUBN_VX_VY':\n\t\t\t\tthis.registers.V[0xF] = 0;\n\n\t\t\t\tif (this.registers.V[args[1]] > this.registers.V[args[0]]) {\n\t\t\t\t\tthis.registers.V[0xF] = 1;\n\t\t\t\t}\n\n\t\t\t\tthis.registers.V[args[0]] = this.registers.V[args[1]] - this.registers.V[args[0]];\n\n\t\t\t\tbreak;\n\t\t\t\t//8XYE\n\t\t\tcase 'SHL_VX_VY':\n\t\t\t\tthis.registers.V[0xF] = (this.registers.V[args[0]] & 0x80);\n\t\t\t\tthis.registers.V[args[0]] <<= 1;\n\t\t\t\tbreak;\n\t\t\t\t//9XY0\n\t\t\tcase 'SNE_VX_VY':\n\t\t\t\tif (this.registers.V[args[0]] !== this.registers.V[args[1]]) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//ANNN\n\t\t\tcase 'LD_I_ADDR':\n\t\t\t\tthis.registers.I = args[0];\n\t\t\t\tbreak;\n\t\t\t\t//BNNN\n\t\t\tcase 'JP_V0_ADDR':\n\t\t\t\tthis.registers.PC = (args[0]) + this.registers.V[0];\n\t\t\t\tbreak;\n\t\t\t\t//CXKK\n\t\t\tcase 'RND_VX_KK':\n\t\t\t\tlet rand = Math.floor(Math.random() * 0xFF);\n\n\t\t\t\tthis.registers.V[args[0]] = rand & (opcode & 0xFF);\n\t\t\t\tbreak;\n\t\t\t\t//DXYN\n\t\t\tcase 'DRW_VX_VY_N':\n\t\t\t\tlet width = SPRITE_WIDTH;\n\t\t\t\tlet height = (opcode & 0xF);\n\n\t\t\t\tthis.registers.V[0xF] = 0;\n\n\t\t\t\tfor (let row = 0; row < height; row++) {\n\t\t\t\t\tlet sprite = this.memory.memory[this.registers.I + row];\n\n\t\t\t\t\tfor (let col = 0; col < width; col++) {\n\t\t\t\t\t\tif ((sprite & 0x80) > 0) {\n\t\t\t\t\t\t\t//If setPixel returns 1, a pixel was erased and set VF to 1\n\t\t\t\t\t\t\tif (this.display.setPixel(this.registers.V[args[0]] + col, this.registers.V[args[1]] + row)) {\n\t\t\t\t\t\t\t\tthis.registers.V[0xF] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Shift the sprite left 1, this will move to the next col/bit\n\t\t\t\t\t\t//Ex. 10010000 << 1 will become 0010000\n\t\t\t\t\t\tsprite <<= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.drawFlag = true;\n\t\t\t\tbreak;\n\t\t\t\t//EX9E\n\t\t\tcase 'SKP_VX':\n\t\t\t\tif (this.keyboard.isKeyPressed(this.registers.V[args[0]])) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//EXA1\n\t\t\tcase 'SKNP_VX':\n\t\t\t\tif (!this.keyboard.isKeyPressed(this.registers.V[args[0]])) {\n\t\t\t\t\tthis.registers.PC += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//FX07\n\t\t\tcase 'LD_VX_DT':\n\t\t\t\tthis.registers.V[args[0]] = this.registers.DT;\n\t\t\t\tbreak;\n\t\t\t\t//FX0A\n\t\t\t\t//Used in Connect4 and TicTac\n\t\t\tcase 'LD_VX_K':\n\t\t\t\tthis.registers.paused = true;\n\n\t\t\t\tthis.keyboard.onNextKeyPress = function(key) {\n\t\t\t\t\tthis.registers.V[args[0]] = key;\n\t\t\t\t\tthis.registers.paused = false;\n\t\t\t\t}.bind(this);\n\t\t\t\tbreak;\n\t\t\t\t//FX15\n\t\t\tcase 'LD_DT_VX':\n\t\t\t\tthis.registers.DT = this.registers.V[args[0]];\n\t\t\t\tbreak;\n\t\t\t\t//FX18\n\t\t\tcase 'LD_ST_VX':\n\t\t\t\tthis.registers.ST = this.registers.V[args[0]];\n\t\t\t\tbreak;\n\t\t\t\t//FX1E\n\t\t\tcase 'ADD_I_VX':\n\t\t\t\tthis.registers.I += this.registers.V[args[0]];\n\t\t\t\tbreak;\n\t\t\t\t//FX29\n\t\t\tcase 'LD_F_VX':\n\t\t\t\tthis.registers.I = this.registers.V[args[0]] * 5;\n\t\t\t\tbreak;\n\t\t\t\t//FX33\n\t\t\tcase 'LD_B_VX':\n\t\t\t\t//Get Hundreds place\n\t\t\t\tthis.memory.memory[this.registers.I] = parseInt(this.registers.V[args[0]] / 100);\n\t\t\t\t//Get Tens place\n\t\t\t\tthis.memory.memory[this.registers.I + 1] = parseInt((this.registers.V[args[0]] % 100) / 10);\n\t\t\t\t//Get Ones place\n\t\t\t\tthis.memory.memory[this.registers.I + 2] = parseInt(this.registers.V[args[0]] % 10);\n\t\t\t\tbreak;\n\t\t\t\t//FX55\n\t\t\tcase 'LD_I_VX':\n\t\t\t\tfor (let registerIndex = 0; registerIndex <= args[0]; registerIndex++) {\n\t\t\t\t\tthis.memory.memory[this.registers.I + registerIndex] = this.registers.V[registerIndex];\n\t\t\t\t}\n\n\t\t\t\t//Check for quirk\n\t\t\t\tif (this.quirk === \"No Quirk\") {\n\t\t\t\t\tthis.registers.I += args[0] + 1;\n\t\t\t\t} else if (this.quirk === \"Shift and Load Quirk\") {\n\t\t\t\t\tthis.registers.I += args[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t//FX65\n\t\t\tcase 'LD_VX_I':\n\t\t\t\tfor (let registerIndex = 0; registerIndex <= args[0]; registerIndex++) {\n\t\t\t\t\tthis.registers.V[registerIndex] = this.memory.memory[this.registers.I + registerIndex];\n\t\t\t\t}\n\n\t\t\t\t//Check for quirk\n\t\t\t\tif (this.quirk === \"No Quirk\") {\n\t\t\t\t\tthis.registers.I += args[0] + 1;\n\t\t\t\t} else if (this.quirk === \"Shift and Load Qurk\") {\n\t\t\t\t\tthis.registers.I += args[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tdefault:\n\t\t\t\tconsole.error(`Instruction with id ${id} not found`, instruction, args);\n\t\t}\n\t}\n}",
			args: [
				"SPRITE_WIDTH",
				"STEP_SPEED",
				"LOAD_PROGRAM_ADDRESS",
				"MEMORY_SIZE",
				"Memory",
				"Registers",
				"Debug",
				"Disassembler",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["CPU"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: true,
		dragging: false,
		positionAbsolute: {
			x: 465.1573635153359,
			y: -585.5780755716614,
		},
	},
	{
		width: 144,
		height: 78,
		id: "nodular_1693117142602",
		type: "javascriptNode",
		position: {
			x: 48.05044902775171,
			y: -231.57090501598555,
		},
		data: {
			label: "debug.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: '//Export Class\n//Used to log all debug features\nexport class Debug {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Debug Properties\n        this.opcodeLogs = new Array();\n\n        this.Active = false;\n    }\n\n    //Reset function\n    reset() {\n        this.opcodeLogs.fill(0);\n    }\n\n    logOpcode(msg) {\n        this.opcodeLogs.push(msg);\n    }\n\n    printLast() {\n        console.log(this.opcodeLogs[this.opcodeLogs.length - 1]);\n    }\n\n    //Updates the Register UI\n    DebugRegisters(cpu) {\n        //Load Registers\n        //16 bit V register\n        cpu.registers.V.forEach((x, index) => {\n            document.getElementById(`V${index}`).innerHTML = `0x${x.toString(16)}`;\n        });\n        //I register\n        document.getElementById("I").innerHTML = `0x${cpu.registers.I.toString(16)}`;\n        //Program Counter\n        document.getElementById("PC").innerHTML = `0x${cpu.registers.PC.toString(16)}`;\n        //Delay Timer\n        document.getElementById("DT").innerHTML = `0x${cpu.registers.DT.toString(16)}`;\n        //Sound Timer\n        document.getElementById(\'ST\').innerHTML = `0x${cpu.registers.ST.toString(16)}`;\n    }\n\n    //Updates the fpsCounter UI\n    ShowFPS(fps) {\n        //Get DOM element\n        let counter = document.getElementById(\'fpsCounter\');\n\n        //Set innerHTML to fps variable\n        counter.innerHTML = fps;\n    }\n}',
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Debug"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 48.05044902775171,
			y: -231.57090501598555,
		},
	},
	{
		width: 276,
		height: 214,
		id: "nodular_1693117144264",
		type: "javascriptNode",
		position: {
			x: 371.3594361021523,
			y: -241.31033746751854,
		},
		data: {
			label: "display.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "import { BG_COLOR, COLOR, DISPLAY_HEIGHT, DISPLAY_WIDTH, SCALE } from \"DisplayConstants.js\";\n\nexport class Display {\n    constructor() {\n        //Display properties\n        this.scale = SCALE; //Screen Scale\n       console.log(`this is the bg color${BG_COLOR}`); this.bgColor = BG_COLOR; //Background Color\n        this.color = COLOR; //Fore Color\n\n        //Get Screen and Context\n        this.screen = canvas; //Screen\n        this.context = this.screen.getContext('2d'); //2D Context\n\n        //Create a frameBuffer to hold all of the pixels\n        this.frameBuffer = new Array(DISPLAY_WIDTH * DISPLAY_HEIGHT); //Frame Buffer array\n\n        //Call Reset\n        this.reset();\n    }\n\n    //Reset the display\n    reset() {\n        //Clear the array of pixels by filling with 0s\n        this.frameBuffer.fill(0);\n        //Set the fill style to background color\n        this.context.fillStyle = this.bgColor;\n        //Fill the screen\n        this.context.fillRect(0, 0, this.screen.width, this.screen.height);\n\n        //Render display\n        this.render();\n    }\n\n    //Scales the screen by multiplying the scale against the default height and width\n    scaleScreen() {\n        //Set screen width and height and scale it\n        this.screen.width = DISPLAY_WIDTH * this.scale;\n        this.screen.height = DISPLAY_HEIGHT * this.scale;\n    }\n\n    //Sets a pixel to 1 or 0 inside the frameBuffer by XOR pixels\n    setPixel(x, y) {\n        //Constant Pixel X and Pixel Y location\n        //Calculate using modulo to handle screen wrap\n        const px = x % DISPLAY_WIDTH;\n        const py = y % DISPLAY_HEIGHT;\n\n        //Set pixelLocation to px + (py * width of the display constant)\n        let pixelLoc = px + (py * DISPLAY_WIDTH);\n\n        //Set pixel inside frameBuffer[pixelLoc as index] to XOR bitwise operation 0 or 1\n        this.frameBuffer[pixelLoc] ^= 1;\n\n        //Opposite Return if pixel was erased. 1 true for erased, 0 false for nothing erased\n        return !this.frameBuffer[pixelLoc];\n    }\n\n    render() {\n        //Scale the screen first\n        this.scaleScreen();\n\n        //Clear the canvas\n        this.context.clearRect(0, 0, this.screen.width, this.screen.height);\n        //Set background color\n        this.context.fillStyle = this.bgColor;\n        //Fill the canvas\n        this.context.fillRect(0, 0, this.screen.width, this.screen.height);\n\n        //Loop through the display width * height\n        for (let i = 0; i < DISPLAY_WIDTH * DISPLAY_HEIGHT; i++) {\n            //Get x location (i mod width) * scale\n            let x = (i % DISPLAY_WIDTH) * this.scale;\n\n            //Get y = Math.floor(i divide width) * scale\n            let y = Math.floor(i / DISPLAY_WIDTH) * this.scale;\n\n            //Check the frame buffer at location i for 0 or 1\n            if (this.frameBuffer[i]) {\n                //Set the fillstyle to color\n                this.context.fillStyle = this.color;\n\n                //Fill a new rectangle at location x,y setting its size to scale variable\n                this.context.fillRect(x, y, this.scale, this.scale);\n            }\n        }\n    }\n\n}",
			args: [
				"BG_COLOR",
				"COLOR",
				"DISPLAY_HEIGHT",
				"DISPLAY_WIDTH",
				"SCALE",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Display"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 371.3594361021523,
			y: -241.31033746751854,
		},
	},
	{
		width: 302,
		height: 112,
		id: "nodular_1693117151624",
		type: "javascriptNode",
		position: {
			x: 490.78278807907964,
			y: 5.69408312499149,
		},
		data: {
			label: "keyboard.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Imports\nimport {\n\tKEYMAP,\n\tNUMBER_OF_KEYS\n} from \"KeyboardConstants.js\";\n\n//Export Class\nexport class Keyboard {\n\t//Called when a new instance of the class is created\n\tconstructor() {\n\t\t//Keyboard properties\n\t\t//Keymap set to constant KEYMAP\n\t\tthis.KEYMAP = KEYMAP;\n\t\t//keyPressed Array to size of keyboard fill with false\n\t\tthis.keyPressed = new Array(NUMBER_OF_KEYS).fill(false);\n\n\t\t//onNextKeyPress to hold \n\t\tthis.onNextKeyPress = null;\n\n\t\t//Add keydown and keyup event listeners to the window\n\t\tdocument.addEventListener('keydown', this.onKeyDown.bind(this), false);\n\t\tdocument.addEventListener('keyup', this.onKeyUp.bind(this), false);\n\t}\n\n\t//check if the provided keycode is pressed(true) in the array\n\tisKeyPressed(keyCode) {\n\t\t//Return value from keyPressed array using the provided value as an index     \n\t\treturn this.keyPressed[keyCode];\n\t}\n\n\t//onKeyDown Event for the window\n\tonKeyDown(event) {\n\t\t//Get key from keymap\n\t\tlet key = this.KEYMAP[event.which];\n\n\t\t//Check that the key exists in the keymap\n\t\tif (key != undefined) {\n\t\t\t//Set keypressed at index key to true\n\t\t\tthis.keyPressed[key] = true;\n\n\t\t\t// Make sure onNextKeyPress is initialized and the pressed key is actually mapped to a Chip-8 key\n\t\t\tif (this.onNextKeyPress !== null && key) {\n\t\t\t\t//parseInt the key pressed for onNextKeyPress\n\t\t\t\tthis.onNextKeyPress(parseInt(key));\n\t\t\t\t//Set onNextKeyPress to null\n\t\t\t\tthis.onNextKeyPress = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t//onKeyUp Event for the window\n\tonKeyUp(event) {\n\t\t//Get key from keymap\n\t\tlet key = this.KEYMAP[event.which];\n\n\t\t//Check that the key exists in the keymap\n\t\tif (!key != undefined) {\n\t\t\t//Set keypressed at index key to true\n\t\t\tthis.keyPressed[key] = false;\n\t\t}\n\t}\n}",
			args: ["KEYMAP", "NUMBER_OF_KEYS "],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Keyboard"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 490.78278807907964,
			y: 5.69408312499149,
		},
	},
	{
		width: 321,
		height: 146,
		id: "nodular_1693117152644",
		type: "javascriptNode",
		position: {
			x: -153.58276896662431,
			y: -552.0129389559072,
		},
		data: {
			label: "memory.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: '//Imports from constants folder\nimport { MEMORY_SIZE, SPRITE_SET_ADDRESS } from "MemoryConstants.js";\nimport { SPRITES } from "CharSet.js";\n\n//Export Class\nexport class Memory {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Memory properties\n        //Create a new Uint8Array called memory and set it\'s size to 4kb of memory\n        this.memory = new Uint8Array(MEMORY_SIZE);\n        //Call reset on creation\n        this.reset();\n    }\n\n    //Reset Memory\n    reset() {\n        //Clear out the array by filling it with 0\n        this.memory.fill(0)\n        //Load sprites into the array at the sprite_set_address\n        this.memory.set(SPRITES, SPRITE_SET_ADDRESS);\n    }\n\n    //Set Memory at location index\n    setMemory(index, value) {\n        //Verify memory location\n        this.assertMemory(index);\n        //Set location value\n        this.memory[index] = value;\n    }\n\n    //Get Memory at location index\n    getMemory(index) {\n        //Verify memory location\n        this.assertMemory(index);\n        //Return memory location value\n        return this.memory[index];\n    }\n\n    //Get Opcode from memory at location index\n    //Opcodes are two bytes\n    getOpCode(index) {\n        //Get the high byte from the index\n        const highByte = this.getMemory(index);\n        //Get the low byte from the index + 1\n        const lowByte = this.getMemory(index + 1);\n        //Return the opcode\n        return (highByte << 8) | lowByte;\n    }\n\n    //Verify Memory is within the bounds of the array\n    assertMemory(index) {\n        console.assert(index >= 0 && index < MEMORY_SIZE, `Error trying to access memory at index ${index}`);\n    }\n}',
			args: ["MEMORY_SIZE", "SPRITE_SET_ADDRESS", "SPRITES"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Memory"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -153.58276896662431,
			y: -552.0129389559072,
		},
	},
	{
		width: 156,
		height: 78,
		id: "nodular_1693117153766",
		type: "javascriptNode",
		position: {
			x: 637.8159645663707,
			y: 281.28050312244034,
		},
		data: {
			label: "speaker.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: '//Class to be exported to other classes\nexport class Speaker {\n\t//Called when creating an instance of the class\n\tconstructor() {\n\t\t//Speaker properties\n\t\tthis.isMute = false;\n\t\tthis.soundEnabled = false; //Holds whether the sound is enabled or not. Object defined in speaker init function\n\t\tthis.volumeLevel = 0.3; //Holds the volume level of the speaker\n\t\tthis.wave = "square"; //Holds the wave of the oscillator\n\n\t\t//Initialize speaker\n\t\tspeakerInit(this);\n\t}\n\n\t//Funtions\n\t//Enables the sound Card\n\tenableSound() {\n\t\tthis.soundEnabled = true;\n\t}\n\n\t//Disables the sound Card\n\tdisableSound() {\n\t\tthis.soundEnabled = false;\n\t}\n\n\t//User Controlled\n\tmute() {\n\t\t//Set audio level to 0\n\t\tthis.volumeLevel = 0.0;\n\t}\n\n\tunMute(value) {\n\t\t//Set audio level to incoming value\n\t\t//This will help when volume has been changed while the speaker is muted\n\t\tthis.volumeLevel = value;\n\t}\n\n\t//Play Sound based on sound timer value\n\tplaySound(st) {\n\t\tif (st > 0) {\n\t\t\t//Play\n\t\t\tthis.enableSound();\n\t\t} else {\n\t\t\t//Stop\n\t\t\tthis.disableSound();\n\t\t}\n\t}\n}\n\n//Initialization function\n//This creates the property soundEnabled for the speaker as well as creating the gain and audio context. It does not need to be exported.\nfunction speakerInit(speaker) {\n\t//Check if browser supports audio context\n\tif (false) {\n\t\t//Create audioContext and masterGain\n\t\tconst audioContext = new(AudioContext || webkitAudioContext)(); //Create an audio Context\n\t\tconst masterGain = new GainNode(audioContext); //Create a masterGain GainNode\n\n\t\t//connect the masterGain to the audio context\n\t\tmasterGain.connect(audioContext.destination);\n\n\t\t//Create variables soundEnabled and Oscillator\n\t\tlet soundEnabled = false;\n\t\tlet oscillator;\n\n\t\t//Create an object and define its properties to speaker\n\t\tObject.defineProperties(speaker, {\n\t\t\t//Sound Enabled Property\n\t\t\tsoundEnabled: {\n\t\t\t\t//Getter\n\t\t\t\tget: function() {\n\t\t\t\t\treturn soundEnabled;\n\t\t\t\t},\n\t\t\t\t//Setter\n\t\t\t\tset: function(value) {\n\t\t\t\t\t//if incomming value already is equal to soundEnabled exit function\n\t\t\t\t\tif (value === soundEnabled) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t//Set soundEnabled to incoming value\n\t\t\t\t\tsoundEnabled = value;\n\n\t\t\t\t\t//Check soundEnabled true\n\t\t\t\t\tif (soundEnabled) {\n\t\t\t\t\t\t//Set masterGain gain value here so volume control works\n\t\t\t\t\t\tmasterGain.gain.value = speaker.volumeLevel;\n\t\t\t\t\t\t//Start Oscillator giving it the audiocontext and the wave\n\t\t\t\t\t\toscillator = new OscillatorNode(audioContext, {\n\t\t\t\t\t\t\ttype: speaker.wave\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//Connect the oscillator to the mastergain\n\t\t\t\t\t\toscillator.connect(masterGain);\n\t\t\t\t\t\t//Start the oscillator\n\t\t\t\t\t\toscillator.start();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Stop the Oscillator\n\t\t\t\t\t\toscillator.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}',
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Speaker"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 637.8159645663707,
			y: 281.28050312244034,
		},
	},
	{
		width: 365,
		height: 146,
		id: "nodular_1693117154441",
		type: "javascriptNode",
		position: {
			x: -200.4843658665788,
			y: -390.51568588345805,
		},
		data: {
			label: "registers.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Imports\nimport { LOAD_PROGRAM_ADDRESS } from \"MemoryConstants.js\";\nimport { NUMBER_OF_REGISTERS, STACK_DEEP } from \"RegisterConstants.js\";\n\n//Export Class\nexport class Registers {\n    //Called when a new instance of the class is created\n    constructor() {\n        //Register properties\n        this.V = new Uint8Array(NUMBER_OF_REGISTERS); //16 8-bit registers\n        this.I = 0; //Memory Address\n        this.stack = new Uint16Array(STACK_DEEP); //Operation Stack\n        this.SP = -1; //Stack pointer\n        this.PC = LOAD_PROGRAM_ADDRESS; //Program Counter set to Program starting address\n\n        this.DT = 0; //Delay Timer\n        this.ST = 0; //Sound Timer\n\n        this.paused = false; //Pause register\n    }\n\n    //Reset all variables\n    reset() {\n        this.V.fill(0);\n        this.I = 0;\n        this.stack.fill(0);\n        this.SP = -1;\n        this.PC = LOAD_PROGRAM_ADDRESS;\n\n        this.DT = 0;\n        this.ST = 0;\n\n        this.paused = false;\n    }\n\n    //Push new value to stack\n    stackPush(value) {\n        //Increase the Stack Position\n        this.SP++;\n        //Assert the Stack is not Overflowing\n        this.assertStackOverflow();\n        //Push a value to the stack at index Stack Position\n        this.stack[this.SP] = value\n    }\n\n    //Pop a new value from the stack\n    stackPop() {\n        //Set value to Stack index of Stack Position\n        const value = this.stack[this.SP];\n        //Decrease Stack Position\n        this.SP--;\n        //Assert the Stack is not Underflow\n        this.assertStackUnderflow();\n        //Return the value\n        return value;\n    }\n\n    //Assert the Stack is not Overflowing\n    assertStackOverflow() {\n        //Assert the Stack is less than the Stack Depth\n        console.assert(this.SP < STACK_DEEP, 'Error stack Overflow')\n    }\n\n    //Assert the Stack is not Underflowed\n    assertStackUnderflow() {\n        //Assert the Stack Position is greater than or equal to -1\n        console.assert(this.SP >= -1, 'Error stack underflow')\n    }\n\n    //Update system timers\n    updateTimers() {\n        if (this.DT > 0) {\n            this.DT -= 1;\n        }\n\n        if (this.ST > 0) {\n            this.ST -= 1;\n        }\n    }\n}",
			args: ["LOAD_PROGRAM_ADDRESS", "NUMBER_OF_REGISTERS", "STACK_DEEP"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Registers"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: -200.4843658665788,
			y: -390.51568588345805,
		},
	},
	{
		width: 156,
		height: 78,
		id: "nodular_1693117155179",
		type: "javascriptNode",
		position: {
			x: 134.9107112530283,
			y: 216.91323268785234,
		},
		data: {
			label: "settings.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "export class Settings {\n\tconstructor() {\n\n\t}\n\n\tsave(name, value) {\n\t\n\t}\n\n\tload(cpu) {\n\n\t}\n}",
			args: [],
			funcedit: true,
			argTypes: [],
			returnType: "",
			returnArgs: ["Settings"],
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		dragging: false,
		positionAbsolute: {
			x: 134.9107112530283,
			y: 216.91323268785234,
		},
	},
	{
		width: 192,
		height: 78,
		id: "nodular_1693715258313",
		type: "javascriptNode",
		position: {
			x: -104.88488967104527,
			y: -888.5738236877601,
		},
		data: {
			label: "CPUConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "export const STEP_SPEED = 10; //Execution Speed",
			args: [],
			funcedit: true,
			returnArgs: ["STEP_SPEED"],
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		positionAbsolute: {
			x: -104.88488967104527,
			y: -888.5738236877601,
		},
		selected: false,
		dragging: false,
	},
	{
		width: 207,
		height: 112,
		id: "nodular_1693715259397",
		type: "javascriptNode",
		position: {
			x: -629.3998105503122,
			y: -886.9158843871168,
		},
		data: {
			label: "CharSet.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "export const SPRITE_WIDTH = 8;\n\nexport const SPRITES = [\n    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n    0x20, 0x60, 0x20, 0x20, 0x70, // 1\n    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n    0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n    0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n    0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n    0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n    0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n    0xF0, 0x80, 0xF0, 0x80, 0x80  // F\n];",
			args: [],
			returnArgs: ["SPRITE_WIDTH", "SPRITES"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -629.3998105503122,
			y: -886.9158843871168,
		},
		dragging: false,
	},
	{
		width: 224,
		height: 248,
		id: "nodular_1693715260792",
		type: "javascriptNode",
		position: {
			x: -885.1660924351049,
			y: -325.59024669125785,
		},
		data: {
			label: "DisplayConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: '//Export Constants\nexport const DISPLAY_WIDTH = 64; //Width\nexport const DISPLAY_HEIGHT = 32; //Height\n//export const SPRITE_HIGHT = 5;\nexport const SCALE = 10;\nexport const BG_COLOR = "#282828"; //Background\nexport const COLOR = "#FFB000"; //Foreground',
			args: [],
			returnArgs: [
				"DISPLAY_WIDTH",
				"DISPLAY_HEIGHT",
				"SPRITE_HIGHT",
				"SCALE",
				"BG_COLOR",
				"COLOR",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -885.1660924351049,
			y: -325.59024669125785,
		},
		dragging: false,
	},
	{
		width: 211,
		height: 112,
		id: "nodular_1693715262960",
		type: "javascriptNode",
		position: {
			x: 487.56917327292496,
			y: -791.6170387327379,
		},
		data: {
			label: "EmulatorConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Export Constants\nexport const TIME_60_HZ = 1000 / 60; //60Hz\n//List of Roms Array\nexport const ROMS = [\n    '15PUZZLE',\n    'BLINKY',\n    'BLITZ',\n    'BRIX',\n    'CONNECT4',\n    'GUESS',\n    'HIDDEN',\n    'INVADERS',\n    'KALEID',\n    'MAZE',\n    'MERLIN',\n    'MISSILE',\n    'PONG',\n    'PONG2',\n    'PUZZLE',\n    'SYZYGY',\n    'TANK',\n    'TETRIS',\n    'TICTAC',\n    'UFO',\n    'VBRIX',\n    'VERS',\n    'WIPEOFF'\n]",
			args: [],
			returnArgs: ["TIME_60_HZ", "ROMS"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 487.56917327292496,
			y: -791.6170387327379,
		},
		dragging: false,
	},
	{
		width: 369,
		height: 316,
		id: "nodular_1693715265116",
		type: "javascriptNode",
		position: {
			x: -964.0644592284737,
			y: -28.37661124001273,
		},
		data: {
			label: "InstructionSet.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Export Constants\n\texport const MASK_NNN = { mask: 0x0fff }; //NNN\n\texport const MASK_N = { mask: 0x000f }; //Nibble\n\texport const MASK_X = { mask: 0x0f00, shift: 8 }; //X\n\texport const MASK_Y = { mask: 0x00f0, shift: 4 }; //Y\n\texport const MASK_KK = { mask: 0x00ff }; //KK\n\texport const MASK_HIGHEST_BYTE = 0xf000; //High byte\n\texport const MASK_HIGHEST_AND_LOWEST_BYTE = 0xf00f; //High and Low byte\n\t//Instruction Set Array\n\texport const INSTRUCTION_SET = [\n\t\n\t\t//Clear the display.\n\t\t{\n\t\t\tkey: 2,\n\t\t\tid: 'CLS',\n\t\t\tname: 'CLS',\n\t\t\tmask: 0xffff,\n\t\t\tpattern: 0x00e0,\n\t\t\targuments: [],\n\t\t},\n\t\n\t\t//Return from a subroutine\n\t\t//The interpreter sets the program counter to the address at the top of the stack, then subtracts 1 from the stack pointer.\n\t\t{\n\t\t\tkey: 3,\n\t\t\tid: 'RET',\n\t\t\tname: 'RET',\n\t\t\tmask: 0xffff,\n\t\t\tpattern: 0x00ee,\n\t\t\targuments: [],\n\t\t},\n\t\n\t\t//Jump to location nnn.\n\t\t//The interpreter sets the program counter to nnn.\n\t\t{\n\t\t\tkey: 4,\n\t\t\tid: 'JP_ADDR',\n\t\t\tname: 'JP',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x1000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Call subroutine at nnn.\n\t\t//The interpreter increments the stack pointer, then puts the current PC on the top of the stack. The PC is then set to nnn.\n\t\t{\n\t\t\tkey: 5,\n\t\t\tid: 'CALL_ADDR',\n\t\t\tname: 'CALL',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x2000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\t\n\t\t//Skip next instruction if Vx = kk.\n\t\t//The interpreter compares register Vx to kk, and if they are equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 6,\n\t\t\tid: 'SE_VX_KK',\n\t\t\tname: 'SE',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x3000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx != kk.\n\t\t//The interpreter compares register Vx to kk, and if they are not equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 7,\n\t\t\tid: 'SNE_VX_KK',\n\t\t\tname: 'SNE',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x4000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx = Vy.\n\t\t//The interpreter compares register Vx to register Vy, and if they are equal, increments the program counter by 2.\n\t\t{\n\t\t\tkey: 8,\n\t\t\tid: 'SE_VX_VY',\n\t\t\tname: 'SE',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x5000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = kk.\n\t\t//The interpreter puts the value kk into register Vx.\n\t\t{\n\t\t\tkey: 9,\n\t\t\tid: 'LD_VX_KK',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x6000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Set Vx = Vx + kk.\n\t\t//Adds the value kk to the value of register Vx, then stores the result in Vx.\n\t\t{\n\t\t\tkey: 10,\n\t\t\tid: 'ADD_VX_KK',\n\t\t\tname: 'ADD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0x7000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Set Vx = Vy.\n\t\t//Stores the value of register Vy in register Vx.\n\t\t{\n\t\t\tkey: 11,\n\t\t\tid: 'LD_VX_VY',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx OR Vy.\n\t\t//Performs a bitwise OR on the values of Vx and Vy, then stores the result in Vx. A bitwise OR compares \n\t\t//the corrseponding bits from two values, and if either bit is 1, then the same bit in the result is also 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 12,\n\t\t\tid: 'OR_VX_VY',\n\t\t\tname: 'OR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8001,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx AND Vy.\n\t\t//Performs a bitwise AND on the values of Vx and Vy, then stores the result in Vx. A bitwise AND compares the corrseponding \n\t\t//bits from two values, and if both bits are 1, then the same bit in the result is also 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 13,\n\t\t\tid: 'AND_VX_VY',\n\t\t\tname: 'AND',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8002,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx XOR Vy.\n\t\t//Performs a bitwise exclusive OR on the values of Vx and Vy, then stores the result in Vx. An exclusive OR compares the \n\t\t//corrseponding bits from two values, and if the bits are not both the same, then the corresponding bit in the result is set to 1. Otherwise, it is 0.\n\t\t{\n\t\t\tkey: 14,\n\t\t\tid: 'XOR_VX_VY',\n\t\t\tname: 'XOR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8003,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx + Vy, set VF = carry.\n\t\t//The values of Vx and Vy are added together. If the result is greater than 8 bits (i.e., > 255,) VF is set to 1, otherwise 0.\n\t\t//Only the lowest 8 bits of the result are kept, and stored in Vx.\n\t\t{\n\t\t\tkey: 15,\n\t\t\tid: 'ADD_VX_VY',\n\t\t\tname: 'ADD',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8004,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx - Vy, set VF = NOT borrow.\n\t\t//If Vx > Vy, then VF is set to 1, otherwise 0. Then Vy is subtracted from Vx, and the results stored in Vx.\n\t\t{\n\t\t\tkey: 16,\n\t\t\tid: 'SUB_VX_VY',\n\t\t\tname: 'SUB',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8005,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx SHR 1.\n\t\t//If the least-significant bit of Vx is 1, then VF is set to 1, otherwise 0. Then Vx is divided by 2.\n\t\t{\n\t\t\tkey: 17,\n\t\t\tid: 'SHR_VX_VY',\n\t\t\tname: 'SHR',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8006,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vy - Vx, set VF = NOT borrow.\n\t\t//If Vy > Vx, then VF is set to 1, otherwise 0. Then Vx is subtracted from Vy, and the results stored in Vx.\n\t\t{\n\t\t\tkey: 18,\n\t\t\tid: 'SUBN_VX_VY',\n\t\t\tname: 'SUBN',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x8007,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set Vx = Vx SHL 1.\n\t\t//If the most-significant bit of Vx is 1, then VF is set to 1, otherwise to 0. Then Vx is multiplied by 2.\n\t\t{\n\t\t\tkey: 19,\n\t\t\tid: 'SHL_VX_VY',\n\t\t\tname: 'SHL',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x800e,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Skip next instruction if Vx != Vy.\n\t\t//The values of Vx and Vy are compared, and if they are not equal, the program counter is increased by 2.\n\t\t{\n\t\t\tkey: 20,\n\t\t\tid: 'SNE_VX_VY',\n\t\t\tname: 'SNE',\n\t\t\tmask: MASK_HIGHEST_AND_LOWEST_BYTE,\n\t\t\tpattern: 0x9000,\n\t\t\targuments: [MASK_X, MASK_Y],\n\t\t},\n\t\n\t\t//Set I = nnn.\n\t\t//The value of register I is set to nnn.\n\t\t{\n\t\t\tkey: 21,\n\t\t\tid: 'LD_I_ADDR',\n\t\t\tname: 'LD',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xa000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Jump to location nnn + V0.\n\t\t//The program counter is set to nnn plus the value of V0.\n\t\t{\n\t\t\tkey: 22,\n\t\t\tid: 'JP_V0_ADDR',\n\t\t\tname: 'JP',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xb000,\n\t\t\targuments: [MASK_NNN],\n\t\t},\n\t\n\t\t//Set Vx = random byte AND kk.\n\t\t//The interpreter generates a random number from 0 to 255, which is then ANDed with the value kk. \n\t\t//The results are stored in Vx. See instruction 8xy2 for more information on AND.\n\t\t{\n\t\t\tkey: 23,\n\t\t\tid: 'RND_VX_KK',\n\t\t\tname: 'RND',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xc000,\n\t\t\targuments: [MASK_X, MASK_KK],\n\t\t},\n\t\n\t\t//Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.\n\t\t//The interpreter reads n bytes from memory, starting at the address stored in I. These bytes are then displayed \n\t\t//as sprites on screen at coordinates (Vx, Vy). Sprites are XORed onto the existing screen. If this causes any pixels \n\t\t//to be erased, VF is set to 1, otherwise it is set to 0. If the sprite is positioned so part of it is outside the coordinates \n\t\t//of the display, it wraps around to the opposite side of the screen. See instruction 8xy3 for more information on XOR, and section \n\t\t//2.4, Display, for more information on the Chip-8 screen and sprites.\n\t\t{\n\t\t\tkey: 24,\n\t\t\tid: 'DRW_VX_VY_N',\n\t\t\tname: 'DRW',\n\t\t\tmask: MASK_HIGHEST_BYTE,\n\t\t\tpattern: 0xd000,\n\t\t\targuments: [MASK_X, MASK_Y, MASK_N],\n\t\t},\n\t\n\t\t//Skip next instruction if key with the value of Vx is pressed.\n\t\t//Checks the keyboard, and if the key corresponding to the value of Vx is currently in the down position, PC is increased by 2.\n\t\t{\n\t\t\tkey: 25,\n\t\t\tid: 'SKP_VX',\n\t\t\tname: 'SKP',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xe09e,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Skip next instruction if key with the value of Vx is not pressed.\n\t\t//Checks the keyboard, and if the key corresponding to the value of Vx is currently in the up position, PC is increased by 2.\n\t\t{\n\t\t\tkey: 26,\n\t\t\tid: 'SKNP_VX',\n\t\t\tname: 'SKNP',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xe0a1,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set Vx = delay timer value.\n\t\t//The value of DT is placed into Vx.\n\t\t{\n\t\t\tkey: 27,\n\t\t\tid: 'LD_VX_DT',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf007,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Wait for a key press, store the value of the key in Vx.\n\t\t//All execution stops until a key is pressed, then the value of that key is stored in Vx.\n\t\t{\n\t\t\tkey: 28,\n\t\t\tid: 'LD_VX_K',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf00a,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set delay timer = Vx.\n\t\t//DT is set equal to the value of Vx.\n\t\t{\n\t\t\tkey: 29,\n\t\t\tid: 'LD_DT_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf015,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set sound timer = Vx.\n\t\t//ST is set equal to the value of Vx.\n\t\t{\n\t\t\tkey: 30,\n\t\t\tid: 'LD_ST_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf018,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set I = I + Vx.\n\t\t//The values of I and Vx are added, and the results are stored in I.\n\t\t{\n\t\t\tkey: 31,\n\t\t\tid: 'ADD_I_VX',\n\t\t\tname: 'ADD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf01e,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Set I = location of sprite for digit Vx.\n\t\t//The value of I is set to the location for the hexadecimal sprite corresponding to the value \n\t\t//of Vx. See section 2.4, Display, for more information on the Chip-8 hexadecimal font.\n\t\t{\n\t\t\tkey: 32,\n\t\t\tid: 'LD_F_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf029,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Store BCD representation of Vx in memory locations I, I+1, and I+2.\n\t\t//The interpreter takes the decimal value of Vx, and places the hundreds digit in memory at \n\t\t//location in I, the tens digit at location I+1, and the ones digit at location I+2.\n\t\t{\n\t\t\tkey: 33,\n\t\t\tid: 'LD_B_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf033,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Store registers V0 through Vx in memory starting at location I.\n\t\t//The interpreter copies the values of registers V0 through Vx into memory, starting at the address in I.\n\t\t{\n\t\t\tkey: 34,\n\t\t\tid: 'LD_I_VX',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf055,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\t//Read registers V0 through Vx from memory starting at location I.\n\t\t//The interpreter reads values from memory starting at location I into registers V0 through Vx.\n\t\t{\n\t\t\tkey: 35,\n\t\t\tid: 'LD_VX_I',\n\t\t\tname: 'LD',\n\t\t\tmask: 0xf0ff,\n\t\t\tpattern: 0xf065,\n\t\t\targuments: [MASK_X],\n\t\t},\n\t\n\t\n\t\n\t\t//Chip48 Instructions\n\t\n\t\t{\n\t\t\tkey: 36,\n\t\t\tid: 'SCD nibble',\n\t\t\tname: 'SCD',\n\t\t\tmask: MASK_N,\n\t\t\tpattern: 0x00C0,\n\t\t\targuments: [],\n\t\t}\n\t];\n\t\n\t//TODO: Add Super chip8 instructions",
			args: [],
			returnArgs: [
				"MASK_NNN",
				"MASK_N",
				"MASK_X",
				"MASK_Y",
				"MASK_KK",
				"MASK_HIGHEST_BYTE",
				"MASK_HIGHEST_AND_LOWEST_BYTE",
				"INSTRUCTION_SET",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -964.0644592284737,
			y: -28.37661124001273,
		},
		dragging: false,
	},
	{
		width: 235,
		height: 112,
		id: "nodular_1693715270047",
		type: "javascriptNode",
		position: {
			x: 41.750527191993456,
			y: 31.816941547270332,
		},
		data: {
			label: "KeyboardConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "//Export Constants\n\texport const NUMBER_OF_KEYS = 16; //Number of keys in the keypad\n\t\n\t//Keymap of the keyboard\n\texport const KEYMAP = {\n\t\t\t49: 0x1, // 1\n\t\t\t50: 0x2, // 2\n\t\t\t51: 0x3, // 3\n\t\t\t52: 0xc, // 4\n\t\t\t81: 0x4, // Q\n\t\t\t87: 0x5, // W\n\t\t\t69: 0x6, // E\n\t\t\t82: 0xD, // R\n\t\t\t65: 0x7, // A\n\t\t\t83: 0x8, // S\n\t\t\t68: 0x9, // D\n\t\t\t70: 0xE, // F\n\t\t\t90: 0xA, // Z\n\t\t\t88: 0x0, // X\n\t\t\t67: 0xB, // C\n\t\t\t86: 0xF  // V\n\t}",
			args: [],
			returnArgs: ["NUMBER_OF_KEYS", "KEYMAP"],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: 41.750527191993456,
			y: 31.816941547270332,
		},
		dragging: false,
	},
	{
		width: 298,
		height: 146,
		id: "nodular_1693715271068",
		type: "javascriptNode",
		position: {
			x: -732.1496694316074,
			y: -738.2122902678527,
		},
		data: {
			label: "MemoryConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "export const MEMORY_SIZE = 4095; //Max Memory Size\n\texport const LOAD_PROGRAM_ADDRESS = 0x200; //Program Address Start Location\n\texport const SPRITE_SET_ADDRESS = 0x000; //Sprite Load Location",
			args: [],
			returnArgs: [
				"MEMORY_SIZE",
				"LOAD_PROGRAM_ADDRESS",
				"SPRITE_SET_ADDRESS",
			],
			funcedit: true,
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		selected: false,
		positionAbsolute: {
			x: -732.1496694316074,
			y: -738.2122902678527,
		},
		dragging: false,
	},
	{
		width: 279,
		height: 112,
		id: "nodular_1693716362447",
		type: "javascriptNode",
		position: {
			x: -931.8430809093092,
			y: -543.3614837273406,
		},
		data: {
			label: "RegisterConstants.js",
			lang: "node",
			funcnode: true,
			loading: false,
			func: "export const NUMBER_OF_REGISTERS = 16; //Number of different registers 8 bytes each\n\texport const STACK_DEEP = 16; //Stack Depth",
			args: [],
			funcedit: true,
			returnArgs: ["NUMBER_OF_REGISTERS", "STACK_DEEP"],
			argTypes: [],
			returnType: "",
			argTypeColors: [],
			hasfunc: true,
			funceval: null,
		},
		positionAbsolute: {
			x: -931.8430809093092,
			y: -543.3614837273406,
		},
		selected: false,
		dragging: false,
	},
	{
		width: 656,
		height: 360,
		id: "nodular_1694151916161",
		type: "canvasNode",
		position: {
			x: 1533.5619409124138,
			y: -462.22461089369153,
		},
		data: {
			label: "canvas",
			func: null,
			args: [],
			funcedit: false,
			hasfunc: false,
			returnType: "",
			returnTypeColor: {
				backgroundColor: "#A0D468",
			},
			funceval: "",
		},
		positionAbsolute: {
			x: 1533.5619409124138,
			y: -462.22461089369153,
		},
		selected: false,
		dragging: false,
	},
];
